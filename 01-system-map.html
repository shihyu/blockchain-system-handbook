<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>1. 系統全圖與分層 - 工程師等級 Web3 系統全圖（完整版）</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">工程師等級 Web3 系統全圖（完整版）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="1-系統全圖與分層"><a class="header" href="#1-系統全圖與分層">1. 系統全圖與分層</a></h1>
<h2 id="11-分層模型"><a class="header" href="#11-分層模型">1.1 分層模型</a></h2>
<p>區塊鏈系統的分層架構，與傳統網路的 OSI 七層模型有著異曲同工之妙。每一層都有明確的職責邊界，上層依賴下層提供的抽象，下層則不需要知道上層的業務邏輯。這種分層思維對於工程師而言至關重要——當系統出問題時，你可以快速定位問題發生在哪一層，而不是在整個技術堆疊中大海撈針。</p>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────────┐
│ L7 產品層: App / Portal / Mobile / Bot                         │
├─────────────────────────────────────────────────────────────────┤
│ L6 服務層: API, AuthN/AuthZ, Risk Engine, Policy Engine        │
├─────────────────────────────────────────────────────────────────┤
│ L5 交易層: Tx Builder, Simulation, Bundler, Relayer            │
├─────────────────────────────────────────────────────────────────┤
│ L4 簽名層: EOA, Smart Account(AA), MPC, Multisig               │
├─────────────────────────────────────────────────────────────────┤
│ L3 鏈互動層: RPC, Node Cluster, Sequencer, Mempool             │
├─────────────────────────────────────────────────────────────────┤
│ L2 協議層: L1/L2 VM, Consensus, DA, Bridge, Oracle             │
├─────────────────────────────────────────────────────────────────┤
│ L1 密碼學層: Hash, Merkle, Signatures, ZK/Commitment           │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="l7-產品層"><a class="header" href="#l7-產品層">L7 產品層</a></h3>
<p>產品層是使用者直接接觸的介面。這裡包含了 Web 前端（React/Vue）、行動端 App（iOS/Android）、Telegram Bot、Discord Bot 等各種載體。從工程角度來看，產品層最重要的設計考量是「狀態同步」——鏈上狀態和前端顯示之間必然存在延遲，你必須設計良好的 loading/pending/confirmed 狀態機，避免使用者看到過期資料後做出錯誤操作。</p>
<p>常見的反模式是前端直接依賴單一 RPC 節點取得餘額，然後在交易送出後立刻刷新頁面期待看到最新狀態。實務上應該採用樂觀更新（Optimistic Update）搭配後端事件確認的雙軌策略。</p>
<h3 id="l6-服務層"><a class="header" href="#l6-服務層">L6 服務層</a></h3>
<p>服務層是後端 API 閘道、身份驗證（AuthN）、權限控制（AuthZ）、風控引擎和策略引擎的集合。在 CeFi/半去中心化的系統中，這一層往往是最厚的一層。風控引擎需要即時判斷交易是否異常（例如：同一地址在 10 分鐘內連續發起 50 筆大額提現），策略引擎則負責執行業務規則（例如：單日提現上限、白名單地址才可轉帳）。</p>
<pre><code class="language-text">                    ┌──────────────────────┐
 使用者請求 ──────&gt;│    API Gateway       │
                    │  (Rate Limit, Auth)  │
                    └──────┬───────────────┘
                           │
              ┌────────────┼────────────────┐
              ▼            ▼                ▼
        ┌──────────┐ ┌──────────┐    ┌──────────┐
        │ AuthN/   │ │  Risk    │    │ Policy   │
        │ AuthZ    │ │  Engine  │    │ Engine   │
        └──────────┘ └──────────┘    └──────────┘
              │            │                │
              └────────────┼────────────────┘
                           ▼
                    ┌──────────────┐
                    │  Tx Builder  │ (L5)
                    └──────────────┘
</code></pre>
<h3 id="l5-交易層"><a class="header" href="#l5-交易層">L5 交易層</a></h3>
<p>交易層負責組裝鏈上交易。Tx Builder 根據業務意圖構建交易內容（呼叫哪個合約、傳入什麼參數、gas 設多少），Simulation 模組在實際送出前先用 <code>eth_call</code> 或類似機制模擬執行結果，確認不會失敗。Bundler 是 ERC-4337 Account Abstraction 架構中的關鍵角色，負責打包 UserOperation。Relayer 則是代付 gas 的中繼服務，讓使用者不需要持有原生代幣就能發起交易。</p>
<p>在高頻場景下，Tx Builder 需要處理 nonce 管理的難題。如果同時有 100 筆交易要送出，你不能讓它們搶同一個 nonce，必須建立 nonce pool 或 nonce manager 來確保每筆交易拿到唯一的遞增 nonce。</p>
<pre><code class="language-text">交易組裝流程:

  業務意圖 ──&gt; Tx Builder ──&gt; Simulation ──&gt; 簽名(L4) ──&gt; 廣播(L3)
                  │               │
                  │          失敗? 中止並回報
                  │
                  ├── 估算 Gas Price / Priority Fee
                  ├── 查詢 Nonce (Nonce Manager)
                  └── 編碼 Calldata (ABI Encoding)
</code></pre>
<h3 id="l4-簽名層"><a class="header" href="#l4-簽名層">L4 簽名層</a></h3>
<p>簽名層是區塊鏈系統中最敏感的一層，因為「控制私鑰就等於控制資產」。EOA（Externally Owned Account）是最基本的形態，一把私鑰對應一個地址。Smart Account（智能帳戶，也稱 Account Abstraction）將帳戶邏輯上鏈，可以實現社交恢復、多簽審批、gas 代付等功能。MPC（Multi-Party Computation）將私鑰分片，分散到多個節點，簽名時各節點各自用自己的分片參與計算，永遠不會在任何單點重組完整私鑰。Multisig 則是在合約層面實現 M-of-N 簽名，典型的如 Gnosis Safe。</p>
<p>實務上，企業級系統通常採用 MPC + 硬體安全模組（HSM）的組合。MPC 負責分散風險，HSM 負責保護個別分片的安全。冷熱錢包分離也是標準做法：熱錢包處理日常小額交易，冷錢包僅在大額結算時啟用。</p>
<h3 id="l3-鏈互動層"><a class="header" href="#l3-鏈互動層">L3 鏈互動層</a></h3>
<p>這一層是鏈下系統和鏈上世界的接口。RPC（Remote Procedure Call）是最常見的互動方式，透過 JSON-RPC 呼叫節點 API 來查詢狀態或送出交易。Node Cluster 是指自建或託管的多個全節點集群，提供負載均衡和故障轉移能力。Sequencer 是 Rollup L2 的排序器，決定交易在 L2 上的執行順序。Mempool 是交易送出後、被打包前的等候區。</p>
<p>RPC 層的穩定性直接影響整個系統的可用性。生產環境中，不應該只依賴單一 RPC 供應商（如 Alchemy 或 Infura），而應該建立 RPC fallback 機制：主節點不回應時自動切換到備援節點，並對回傳結果做交叉比對。</p>
<h3 id="l2-協議層"><a class="header" href="#l2-協議層">L2 協議層</a></h3>
<p>協議層是區塊鏈本體的核心。L1/L2 VM（虛擬機）執行智能合約；Consensus（共識機制）確保所有節點對狀態達成一致；DA（Data Availability，資料可用性）確保交易資料可被任何人取得和驗證；Bridge（跨鏈橋）連接不同區塊鏈；Oracle（預言機）將鏈外資料引入鏈上。</p>
<p>這一層的設計決定了區塊鏈的基本性質——安全性、去中心化程度和吞吐量。作為應用開發者，你不需要修改這一層，但必須深刻理解它的限制（例如：Ethereum 的 12 秒出塊時間、Solana 的 400ms slot 時間）才能做出正確的架構決策。</p>
<h3 id="l1-密碼學層"><a class="header" href="#l1-密碼學層">L1 密碼學層</a></h3>
<p>密碼學層是整個系統的數學根基。Hash 函數（SHA-256、Keccak-256）提供抗碰撞的指紋功能；Merkle Tree 允許高效驗證大量資料中的某個元素是否存在；數位簽名（ECDSA、EdDSA、BLS）確保交易的不可偽造性；ZK Proof（零知識證明）和 Commitment Scheme 則是最前沿的密碼學工具，允許在不揭露資料的情況下證明某個命題為真。</p>
<pre><code class="language-text">密碼學原語與上層功能對應:

  Hash (SHA-256, Keccak)  ────&gt; 區塊鏈接、地址生成、資料完整性
  Merkle Tree             ────&gt; 狀態根、交易根、SPV 輕客戶端驗證
  Digital Signature       ────&gt; 交易授權、身份認證
  ZK Proof                ────&gt; Rollup 驗證、隱私交易、身份證明
  Commitment Scheme       ────&gt; 預防搶跑（front-running）、隱藏出價
</code></pre>
<h2 id="12-信任邊界"><a class="header" href="#12-信任邊界">1.2 信任邊界</a></h2>
<p>信任邊界（Trust Boundary）是安全分析中最核心的概念之一。每當資料或控制權從一個信任域穿越到另一個信任域，就是潛在的攻擊面。區塊鏈系統的特殊之處在於，它橫跨了多個完全不同的信任域——從使用者的手機到去中心化的全球節點網路。</p>
<pre><code class="language-text">信任邊界示意圖:

  ┌────────────────────────────────────────────────────────────────┐
  │  使用者裝置 (Browser / Mobile)                                 │
  │  ┌──────────────┐                                              │
  │  │  私鑰 / 助記詞 │  &lt;── 邊界 A: 最敏感，一旦洩漏無法挽回      │
  │  └──────────────┘                                              │
  └──────────────────────┬─────────────────────────────────────────┘
                         │ HTTPS / WebSocket
  ┌──────────────────────▼─────────────────────────────────────────┐
  │  應用後端 (API Server / Signing Service)                        │
  │  ┌──────────────┐  ┌──────────────┐                            │
  │  │  HSM / MPC   │  │  業務邏輯    │  &lt;── 邊界 B: 後端被攻破    │
  │  └──────────────┘  └──────────────┘      可能導致未授權簽名     │
  └──────────────────────┬─────────────────────────────────────────┘
                         │ JSON-RPC
  ┌──────────────────────▼─────────────────────────────────────────┐
  │  RPC Provider / 節點集群                                        │
  │  &lt;── 邊界 C: RPC 回傳的資料可能被篡改或延遲                     │
  └──────────────────────┬─────────────────────────────────────────┘
                         │
  ┌──────────────────────▼─────────────────────────────────────────┐
  │  鏈上世界 (L1 / L2 / Bridge)                                    │
  │  &lt;── 邊界 D: 跨鏈橋的驗證者集合可能被攻破                       │
  └────────────────────────────────────────────────────────────────┘
</code></pre>
<ul>
<li>
<p><strong>邊界 A: 客戶端裝置與錢包私鑰</strong> — 這是整個系統中最脆弱的環節。使用者的裝置可能被植入惡意軟體、助記詞可能被截圖、剪貼簿可能被監聽。工程上的對策包括：不在前端存儲明文私鑰、使用硬體錢包簽名、對敏感操作增加二次確認。2022 年 Slope 錢包事件中，助記詞被日誌系統明文記錄並上傳到伺服器，導致數千個錢包被盜，就是邊界 A 失守的典型案例。</p>
</li>
<li>
<p><strong>邊界 B: 應用後端與簽名服務</strong> — 當系統使用託管式錢包（Custodial Wallet）或半託管架構時，後端伺服器持有簽名能力。如果後端被入侵（SQL Injection、RCE、內部人員作弊），攻擊者可以直接簽署並送出惡意交易。防禦策略包括：將簽名服務隔離到獨立的安全區域（Enclave）、所有簽名請求必須經過策略引擎審批、對大額交易實施時間鎖（Timelock）。</p>
</li>
<li>
<p><strong>邊界 C: RPC 提供者與鏈上真實狀態</strong> — RPC 節點是你觀察鏈上世界的「眼睛」。如果 RPC 供應商被攻擊或返回不正確的資料，你的系統就會基於錯誤的鏈上狀態做出決策。例如，RPC 可能回傳一個尚未真正被確認的交易狀態，導致你提前放行提現。對策包括：多 RPC 交叉驗證、自建全節點、用 Block Hash 做 anchoring 確認資料一致性。</p>
</li>
<li>
<p><strong>邊界 D: 跨鏈橋外部驗證集合</strong> — 跨鏈橋是區塊鏈生態中最常被攻擊的元件。Wormhole（3.2 億美元）、Ronin Bridge（6.25 億美元）、Nomad（1.9 億美元）等事件反覆證明這一點。橋的安全取決於其驗證機制：多簽橋依賴驗證者的誠實、輕客戶端橋依賴密碼學證明、樂觀橋依賴挑戰期內的欺詐證明。每種設計都有不同的攻擊面和信任假設。</p>
</li>
</ul>
<h2 id="13-關鍵風險對應"><a class="header" href="#13-關鍵風險對應">1.3 關鍵風險對應</a></h2>
<p>風險管理是區塊鏈系統工程的核心能力。與傳統系統不同的是，區塊鏈上的錯誤通常是不可逆的——一旦資產被轉走，沒有「系統管理員」可以回退交易。因此，防禦性設計必須從第一天就內建到架構中。</p>
<h3 id="單點私鑰風險"><a class="header" href="#單點私鑰風險">單點私鑰風險</a></h3>
<p><strong>風險描述：</strong> 當一把私鑰直接控制大量資產時，該私鑰的洩漏或丟失等同於全部資產的損失。這是區塊鏈系統中最致命的單點故障。</p>
<p><strong>對策：使用 MPC 或 Multisig + 硬體隔離。</strong> MPC（多方計算）將私鑰分為 N 個分片，分散到不同的地理位置和管理者手中，簽名時只需要 T 個分片參與（T &lt; N），任何單一分片都無法獨立完成簽名。Multisig（多重簽名）在合約層面實現類似效果，典型的 3-of-5 多簽要求 5 個簽名者中至少 3 個同意才能執行交易。</p>
<pre><code class="language-text">MPC 簽名流程:

  分片 1 (美國 HSM)  ─┐
  分片 2 (歐洲 HSM)  ─┤── MPC Protocol ──&gt; 簽名結果
  分片 3 (亞洲 HSM)  ─┘    (2-of-3)

  注意: 完整私鑰永遠不會在任何單一節點上被重組
</code></pre>
<p><strong>案例：</strong> 2023 年 Atomic Wallet 被駭事件，估計損失超過 1 億美元。攻擊者利用私鑰管理的漏洞，直接提取用戶資產。如果該系統採用 MPC 架構，攻擊者需要同時攻破多個獨立的安全域，難度會大幅提升。</p>
<h3 id="rpc-欺騙風險"><a class="header" href="#rpc-欺騙風險">RPC 欺騙風險</a></h3>
<p><strong>風險描述：</strong> 應用程式依賴 RPC 節點取得鏈上狀態。如果 RPC 節點被入侵、被 MITM 攻擊、或單純回傳過時資料，應用程式可能基於錯誤的資訊做出決策。</p>
<p><strong>對策：多來源 RPC 交叉驗證 + Block Hash Anchoring。</strong> 同時向 2-3 個獨立的 RPC 供應商查詢同一筆資料，比對結果是否一致。如果結果不一致，觸發告警並暫停依賴該資料的業務邏輯。Block Hash Anchoring 是進一步的驗證手段——從多個來源取得同一個區塊的 hash，確認大家看到的是同一條鏈。</p>
<pre><code class="language-python"># 偽碼: 多 RPC 交叉驗證
async def get_verified_balance(address):
    results = await asyncio.gather(
        rpc_alchemy.get_balance(address),
        rpc_infura.get_balance(address),
        rpc_self_hosted.get_balance(address),
    )
    if len(set(results)) == 1:
        return results[0]  # 三者一致，可信
    else:
        alert("RPC 結果不一致", results)
        return None  # 暫停，等待人工介入
</code></pre>
<h3 id="跨鏈訊息偽造風險"><a class="header" href="#跨鏈訊息偽造風險">跨鏈訊息偽造風險</a></h3>
<p><strong>風險描述：</strong> 攻擊者偽造來自源鏈的跨鏈訊息，欺騙目標鏈上的合約釋放資產。這是跨鏈橋被攻擊最常見的向量。</p>
<p><strong>對策：輕客戶端驗證或經濟安全模型明確化。</strong> 最安全的方式是在目標鏈上運行源鏈的輕客戶端，直接驗證源鏈的區塊頭和交易證明（例如 IBC 協議的做法）。當輕客戶端不可行時（例如在 EVM 上驗證 Bitcoin 區塊頭的成本過高），需要明確定義經濟安全模型——驗證者需要質押多少資產、被 slash 的金額是否足以覆蓋潛在損失。</p>
<h3 id="治理劫持風險"><a class="header" href="#治理劫持風險">治理劫持風險</a></h3>
<p><strong>風險描述：</strong> 攻擊者通過閃電貸等手段短暫獲取大量治理代幣，在單一區塊內提案並投票，將協議金庫的資產轉移到自己控制的地址。</p>
<p><strong>對策：Timelock + Guardian + Emergency Pause。</strong> Timelock 要求提案通過後必須等待一段時間（通常 24-48 小時）才能執行，給社群時間發現和反應。Guardian 是受信任的多簽地址，有權在緊急情況下取消尚在 Timelock 中的惡意提案。Emergency Pause 允許在發現攻擊時立即凍結合約的關鍵功能。</p>
<pre><code class="language-text">治理防禦層級:

  提案送出 ──&gt; 投票期 (3-7 天)
                  │
              投票通過
                  │
              Timelock (24-48 小時) ──&gt; Guardian 可取消
                  │
              執行提案 ──&gt; Emergency Pause 可凍結
</code></pre>
<h2 id="14-系統設計原則"><a class="header" href="#14-系統設計原則">1.4 系統設計原則</a></h2>
<p>這些原則不是教條，而是從無數次真實事故中提煉出來的工程經驗。每一條原則的背後都有血淋淋的案例支撐。</p>
<h3 id="最小信任"><a class="header" href="#最小信任">最小信任</a></h3>
<p><strong>盡量把可信計算搬到鏈上。</strong> 這是區塊鏈系統設計的第一原則。任何可以在鏈上驗證的邏輯，就不應該信任鏈下的回報。例如，不要讓後端 API 告訴前端「這筆交易成功了」，而是讓前端直接從鏈上查詢交易收據（Transaction Receipt）來確認。</p>
<p>實務上的漸進做法是：先識別系統中所有需要信任的環節，然後逐一評估哪些可以移到鏈上或用密碼學證明替代。不是所有東西都需要搬到鏈上——gas 成本和效能限制是真實的約束。關鍵是讓信任假設明確可見，而不是隱藏在程式碼的角落裡。</p>
<h3 id="可驗證性"><a class="header" href="#可驗證性">可驗證性</a></h3>
<p><strong>每一筆關鍵狀態轉移都可追溯。</strong> 這包括鏈上的交易紀錄，也包括鏈下的操作日誌。在出事時，你需要能夠回答：「是誰、在什麼時間、做了什麼操作、導致了這個結果？」</p>
<p>工程實踐上，這意味著：所有鏈下的簽名請求都要有 audit log、所有的配置變更都要有版本控制、所有的風控規則觸發都要有詳細紀錄。鏈上的部分天然具有可追溯性（區塊鏈本身就是一個不可篡改的日誌），但鏈下的部分需要你自己建設。</p>
<h3 id="漸進去中心化"><a class="header" href="#漸進去中心化">漸進去中心化</a></h3>
<p><strong>先可用，再逐步移除管理權限。</strong> 一個新上線的 DeFi 協議不可能在第一天就完全去中心化——你需要保留升級合約的能力來修復 Bug、需要保留暫停功能來應對攻擊、需要保留參數調整權來優化協議。但這些管理權限應該有明確的退出計畫：從單一管理者 → 多簽 → 時間鎖 → DAO 治理 → 最終不可升級。</p>
<pre><code class="language-text">漸進去中心化路徑:

  Phase 1: 團隊 EOA 控制 (快速迭代)
      │
  Phase 2: 多簽控制 (3-of-5 核心團隊)
      │
  Phase 3: 多簽 + Timelock (48 小時延遲)
      │
  Phase 4: DAO 投票 + Timelock + Guardian
      │
  Phase 5: 不可升級 (immutable)
</code></pre>
<h3 id="失效安全"><a class="header" href="#失效安全">失效安全</a></h3>
<p><strong>任何模組失敗時預設保守停機。</strong> 這是來自核電站和航空工業的工程原則。在區塊鏈系統中，「失效安全」意味著：RPC 節點不回應時，暫停所有提現而不是放行；風控引擎當機時，拒絕所有交易而不是跳過風控；價格預言機回傳異常值時，暫停清算而不是用錯誤價格清算。</p>
<p>反面案例：2020 年 11 月，Compound 因為 Coinbase Pro 上 DAI 的價格異常（被推高到 1.3 美元），預言機回報了錯誤的價格，導致價值 8,900 萬美元的部位被不當清算。如果系統有「價格偏離閾值時自動暫停」的失效安全機制，這筆損失可以避免。</p>
<h2 id="15-各層典型技術選型"><a class="header" href="#15-各層典型技術選型">1.5 各層典型技術選型</a></h2>
<p>以下表格列出每一層常見的技術選項，供團隊在做架構決策時參考。</p>
<div class="table-wrapper"><table><thead><tr><th>層級</th><th>技術選項</th><th>說明</th></tr></thead><tbody>
<tr><td>L7 產品層</td><td>React + wagmi, Flutter, Telegram Bot API</td><td>前端框架選擇取決於目標平台</td></tr>
<tr><td>L6 服務層</td><td>Node.js/Go API, OPA (策略引擎), Datadog (監控)</td><td>風控引擎需要低延遲</td></tr>
<tr><td>L5 交易層</td><td>ethers.js/viem, Pimlico (Bundler), OpenZeppelin Defender (Relayer)</td><td>Nonce 管理是難點</td></tr>
<tr><td>L4 簽名層</td><td>Fireblocks (MPC), Safe (Multisig), Turnkey, Privy</td><td>依據安全需求和用戶體驗選擇</td></tr>
<tr><td>L3 鏈互動層</td><td>Alchemy, Infura, QuickNode, 自建 Geth/Reth 節點</td><td>生產環境至少兩個獨立來源</td></tr>
<tr><td>L2 協議層</td><td>EVM, SVM, MoveVM, CosmWasm</td><td>決定了開發語言和工具鏈</td></tr>
<tr><td>L1 密碼學層</td><td>OpenSSL, libsecp256k1, arkworks (ZK), circom</td><td>不要自己實作密碼學原語</td></tr>
</tbody></table>
</div>
<h2 id="16-監控與可觀測性"><a class="header" href="#16-監控與可觀測性">1.6 監控與可觀測性</a></h2>
<p>一個完整的區塊鏈系統，監控不只是看伺服器 CPU 和記憶體。你需要監控的維度遠比傳統系統更多：</p>
<pre><code class="language-text">監控維度:

  ┌─────────────────────────────────────────────────────────────┐
  │                    基礎設施層                                │
  │  • 伺服器健康狀態 (CPU / Memory / Disk)                     │
  │  • RPC 節點回應時間與錯誤率                                  │
  │  • 節點同步狀態 (落後幾個區塊?)                              │
  ├─────────────────────────────────────────────────────────────┤
  │                    業務邏輯層                                │
  │  • 交易送出到確認的延遲                                      │
  │  • 交易失敗率與失敗原因分類                                   │
  │  • Gas 消耗趨勢                                              │
  ├─────────────────────────────────────────────────────────────┤
  │                    安全監控層                                 │
  │  • 錢包餘額變動 (大額即時告警)                                │
  │  • 合約事件異常 (非預期的 admin 呼叫)                        │
  │  • 跨鏈橋餘額與對帳差異                                      │
  ├─────────────────────────────────────────────────────────────┤
  │                    鏈上環境層                                 │
  │  • Gas Price 飆升 (可能正在被 MEV 攻擊)                      │
  │  • 區塊重組深度 (reorg 監控)                                  │
  │  • 預言機價格偏差                                             │
  └─────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>常見陷阱：</strong> 很多團隊只在出事後才開始建監控。正確的做法是在系統設計階段就定義好 SLI（Service Level Indicator）和 SLO（Service Level Objective），例如：「交易從送出到 finalized 的時間 P99 不超過 5 分鐘」、「RPC 回應時間 P95 不超過 200ms」。</p>
<h2 id="白話總結"><a class="header" href="#白話總結">白話總結</a></h2>
<p>把 Web3 系統想成一個現代化的金融核心系統。鏈是不可篡改的總帳本，記錄了每一筆交易的歷史；智能合約是寫在總帳上的交易規則，一旦部署就無法被單方面更改（除非設計了升級機制）；錢包和多簽是簽核流程，決定了誰有權動用資金；監控系統是稽核與風控中心，24/7 不間斷地檢查是否有異常發生。</p>
<p>與傳統金融系統最大的不同在於：區塊鏈上的錯誤是不可逆的。傳統銀行轉錯帳可以聯繫銀行回退，但鏈上轉錯地址就是永久損失。這意味著區塊鏈系統的每一層都必須比傳統系統更保守、更注重防禦。分層模型的價值在於讓你可以在每一層獨立地思考安全問題——L4 簽名層解決「誰有權簽名」，L6 服務層解決「這筆交易是否合理」，L3 鏈互動層解決「我看到的鏈上狀態是否真實」。每一層的失敗模式不同，對應的防禦手段也不同。</p>
<p>信任邊界是最需要投入安全資源的地方。每當資料從一個信任域傳遞到另一個信任域，就是攻擊者可以動手腳的地方。優秀的區塊鏈工程師不只寫功能正確的程式碼，更會不斷追問：「如果這個環節被攻破了，最壞的情況是什麼？我們能承受嗎？有沒有辦法把損失控制在可接受的範圍內？」</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="02-chain-models.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="02-chain-models.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
