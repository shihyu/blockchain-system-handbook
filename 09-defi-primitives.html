<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>9. DeFi 原語與組合性 - 工程師等級 Web3 系統全圖（完整版）</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">工程師等級 Web3 系統全圖（完整版）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="9-defi-原語與組合性"><a class="header" href="#9-defi-原語與組合性">9. DeFi 原語與組合性</a></h1>
<h2 id="91-基本原語"><a class="header" href="#91-基本原語">9.1 基本原語</a></h2>
<p>DeFi（Decentralized Finance，去中心化金融）的核心理念是將傳統金融服務拆解為可程式化、可組合的「原語」（primitives）。每個原語都是一個獨立的智能合約或合約系統，提供特定的金融功能。這些原語可以像樂高積木一樣自由組合，創造出傳統金融難以實現的複雜金融產品。</p>
<h3 id="ammautomated-market-maker自動做市商"><a class="header" href="#ammautomated-market-maker自動做市商">AMM（Automated Market Maker，自動做市商）</a></h3>
<p>AMM 是 DeFi 中最基礎的原語之一，它取代了傳統交易所的訂單簿模式，使用數學公式和流動性池來自動定價和撮合交易。</p>
<p><strong>恆定乘積公式 x * y = k</strong></p>
<p>Uniswap V2 引入的 <code>x * y = k</code> 是最經典的 AMM 公式。其中 x 和 y 分別代表池中兩種 token 的數量，k 是一個常數。當交易者買入 token A 時，池中 A 的數量減少，B 的數量增加，價格因此變動。這個公式保證了流動性在任何價格區間都可用，但代價是資本效率低——大部分流動性分散在不太可能被使用到的價格區間。</p>
<pre><code class="language-text">恆定乘積曲線 x * y = k：

    y (Token B)
    │
    │
    │╲
    │  ╲
    │    ╲             ← 大部分流動性在這裡
    │      ╲              但很少有交易在這個價格
    │        ╲
    │          ╲
    │            ╲
    │              ╲
    │                ╲___________
    │                            ← 實際交易集中在這個區域
    └──────────────────────────── x (Token A)

交易範例：
  池子初始狀態: x=1000 ETH, y=2,000,000 USDC (k=2,000,000,000)
  價格: 1 ETH = 2000 USDC

  買入 10 ETH：
  新 x = 1000 - 10 = 990
  新 y = k / 990 = 2,020,202 USDC
  用戶支付 = 2,020,202 - 2,000,000 = 20,202 USDC
  實際價格 = 20,202 / 10 = 2,020.2 USDC/ETH （含滑點）
</code></pre>
<p><strong>集中流動性（Concentrated Liquidity）</strong></p>
<p>Uniswap V3 引入了集中流動性的概念，允許流動性提供者（LP）將資金集中在特定的價格區間。例如，如果 LP 認為 ETH/USDC 的價格會在 1,800-2,200 之間波動，就只在這個區間提供流動性。這大幅提高了資本效率（理論上可達 4,000 倍），但也增加了 LP 的管理複雜度和無常損失（Impermanent Loss）的風險。</p>
<pre><code class="language-text">Uniswap V3 集中流動性 vs V2 均勻流動性：

V2（均勻分佈）：                    V3（集中在 $1800-$2200）：
流動性                              流動性
│████████████████████│               │                    │
│████████████████████│               │    ┌──────────┐    │
│████████████████████│               │    │██████████│    │
│████████████████████│               │    │██████████│    │
│████████████████████│               │    │██████████│    │
└────────────────────                └────────────────────
$0        $∞                         $1800       $2200
  相同的資金，V3 在目標區間的深度遠大於 V2
</code></pre>
<p><strong>常見 AMM 變體</strong>：</p>
<ul>
<li><strong>Curve（StableSwap）</strong>：針對穩定幣對優化的 AMM 曲線，在接近 1:1 的價格區間提供極低滑點。使用修改後的 <code>x + y = k</code> 和 <code>x * y = k</code> 的混合公式。</li>
<li><strong>Balancer</strong>：支援多資產池（最多 8 種 token）和自定義權重（例如 80/20 而非 50/50）。</li>
<li><strong>Maverick、Trader Joe V2</strong>：使用 bin-based 的流動性分佈，進一步細化流動性管理。</li>
</ul>
<h3 id="lending借貸協議"><a class="header" href="#lending借貸協議">Lending（借貸協議）</a></h3>
<p>借貸協議允許使用者存入資產賺取利息，或抵押資產借出其他資產。這是 DeFi 中 TVL（Total Value Locked）最大的類別。</p>
<p><strong>核心機制</strong>：</p>
<pre><code class="language-text">借貸協議運作流程：

存款方 (Lender)                    借款方 (Borrower)
┌──────────────┐                  ┌──────────────┐
│ 存入 1000    │                  │ 存入 2 ETH   │
│ USDC         │                  │ 作為抵押品    │
│              │                  │              │
│ 獲得 cUSDC   │                  │ 借出 1500    │
│ (計息代幣)   │                  │ USDC         │
└──────┬───────┘                  └──────┬───────┘
       │                                 │
       v                                 v
┌─────────────────────────────────────────────────┐
│              Lending Pool                         │
│                                                   │
│  USDC Pool: 10,000 USDC                          │
│  利用率: 75%                                      │
│  存款 APY: 3.5%  (隨利用率動態調整)                │
│  借款 APY: 5.2%  (利差 = 協議收入)                 │
│                                                   │
│  利率曲線：                                        │
│  APY                                              │
│  │                           ╱                    │
│  │                         ╱                      │
│  │                       ╱  ← 超過最優利用率       │
│  │                     ╱      利率急劇上升         │
│  │          ╱─────────╱                            │
│  │        ╱                                       │
│  │      ╱                                         │
│  │    ╱                                           │
│  └──╱──────────────────────── 利用率               │
│     0%    50%   80%  90%  100%                     │
│                  ↑                                 │
│            最優利用率(kink)                          │
└─────────────────────────────────────────────────┘
</code></pre>
<p><strong>健康因子（Health Factor）</strong></p>
<p>健康因子是衡量借款人抵押品安全程度的核心指標。計算公式為：</p>
<pre><code>Health Factor = (抵押品價值 × 清算門檻) / 借款總額

範例：
  抵押品: 2 ETH × $2,000 = $4,000
  清算門檻: 82.5% (ETH 在 Aave 上的設定)
  借款: $2,500 USDC

  Health Factor = ($4,000 × 0.825) / $2,500 = 1.32

  HF &gt; 1.0: 安全（目前狀態）
  HF = 1.0: 觸發清算
  HF &lt; 1.0: 理論上不應出現（清算機器人會搶先）
</code></pre>
<p><strong>清算機制（Liquidation）</strong></p>
<p>當借款人的健康因子降至 1.0 以下時，任何人都可以代為償還部分借款並獲得折價的抵押品作為獎勵。清算獎勵通常為 5-10%。清算機制確保協議始終保持超額抵押，是借貸協議安全性的基石。</p>
<pre><code class="language-text">清算流程：

ETH 價格從 $2,000 跌至 $1,500
┌────────────────────────────────────────┐
│  借款人原始狀態:                        │
│  抵押: 2 ETH × $2,000 = $4,000         │
│  借款: $2,500 USDC                      │
│  HF = ($4,000 × 0.825) / $2,500 = 1.32 │
│                                          │
│  價格下跌後:                             │
│  抵押: 2 ETH × $1,500 = $3,000         │
│  借款: $2,500 USDC                      │
│  HF = ($3,000 × 0.825) / $2,500 = 0.99 │
│  → 觸發清算！                            │
│                                          │
│  清算人操作:                             │
│  償還: $1,250 USDC (50% close factor)   │
│  獲得: $1,250 × 1.05 = $1,312.5 等值   │
│         的 ETH (含 5% 清算獎勵)          │
│  利潤: $62.5                             │
└────────────────────────────────────────┘
</code></pre>
<p><strong>代表項目</strong>：Aave、Compound、Morpho（點對點匹配 + 池模式混合）。</p>
<h3 id="derivatives衍生品協議"><a class="header" href="#derivatives衍生品協議">Derivatives（衍生品協議）</a></h3>
<p>鏈上衍生品協議將傳統金融中的期貨、期權等工具帶到 DeFi 中。其中永續合約（Perpetual Contract）是最受歡迎的產品。</p>
<p><strong>永續合約</strong></p>
<p>永續合約是一種沒有到期日的衍生品。交易者可以做多（看漲）或做空（看跌），並使用槓桿放大收益和風險。永續合約的價格透過「資金費率」（Funding Rate）機制錨定在現貨價格附近。</p>
<p><strong>資金費率（Funding Rate）</strong></p>
<p>資金費率是永續合約獨有的機制，每隔一段時間（通常 8 小時）在多空雙方之間結算一次。當市場看多情緒過強（永續價格 &gt; 現貨價格）時，多頭向空頭支付資金費率，反之亦然。這個機制激勵交易者對抗主流方向，將永續價格拉回現貨價格。</p>
<pre><code class="language-text">資金費率機制：

永續價格 &gt; 現貨價格 (正基差)：
  多頭 ──── 支付費率 ────&gt; 空頭
  效果：鼓勵做空，抑制做多，拉回價格

永續價格 &lt; 現貨價格 (負基差)：
  空頭 ──── 支付費率 ────&gt; 多頭
  效果：鼓勵做多，抑制做空，推升價格

結算頻率：通常每 8 小時
費率計算：Funding Rate = clamp(TWAP(永續 - 現貨) / 現貨, -0.05%, +0.05%)
</code></pre>
<p><strong>鏈上衍生品的挑戰</strong>：</p>
<ul>
<li><strong>Oracle 延遲</strong>：價格更新的延遲讓攻擊者可以「搶先交易」（front-running）。解法包括使用 Pyth Network 的 pull oracle 模式，或在交易提交和執行之間加入延遲（GMX V2 的做法）。</li>
<li><strong>流動性碎片化</strong>：不同交易對的流動性分散在各自的市場中。共享流動性模型（如 GMX 的 GLP/GM 池）試圖解決這個問題。</li>
<li><strong>Gas 成本</strong>：複雜的保證金計算和倉位管理需要大量 gas，這也是為什麼大多數鏈上衍生品協議部署在 L2 上。</li>
</ul>
<p><strong>代表項目</strong>：GMX（Arbitrum/Avalanche）、dYdX（自建 L2 → Cosmos 鏈）、Synthetix Perps（Optimism）、Hyperliquid（自建 L1）。</p>
<h3 id="stablecoin穩定幣"><a class="header" href="#stablecoin穩定幣">Stablecoin（穩定幣）</a></h3>
<p>穩定幣是 DeFi 的基礎貨幣，旨在將價格穩定在 1 美元（或其他法幣）附近。根據其穩定機制可分為三大類：</p>
<p><strong>抵押型穩定幣（Collateralized）</strong></p>
<p>使用加密資產作為超額抵押來鑄造穩定幣。代表項目是 MakerDAO 的 DAI。使用者需要存入至少 150% 價值的 ETH（或其他抵押品）來鑄造 DAI。</p>
<pre><code class="language-text">超額抵押鑄造 DAI：

用戶存入 $3,000 等值的 ETH
         │
         v
┌─────────────────────────────┐
│      MakerDAO CDP / Vault    │
│                               │
│  抵押品: $3,000 ETH           │
│  鑄造: 2,000 DAI              │
│  抵押率: 150%                 │
│  最低抵押率: 150%             │
│                               │
│  穩定費(年利率): 3.5%         │
│  → 用戶需支付 DAI 借款利息     │
│                               │
│  若 ETH 跌至抵押率 &lt; 150%     │
│  → 觸發清算                   │
└─────────────────────────────┘
         │
         v
用戶獲得 2,000 DAI（可在 DeFi 中使用）
</code></pre>
<p><strong>演算法穩定幣（Algorithmic）</strong></p>
<p>不依賴外部抵押品，而是透過演算法和套利機制來維持價格穩定。這類穩定幣的歷史充滿了失敗案例。</p>
<p><strong>案例分析——UST/LUNA 崩盤（2022 年 5 月）</strong>：Terra 的 UST 使用雙代幣機制：1 UST 可以兌換 $1 等值的 LUNA。當 UST 價格低於 $1 時，套利者燒毀 UST 換取 LUNA 並在市場上賣出，減少 UST 供應推升價格。但在極端拋壓下，大量 UST 被兌換成 LUNA，LUNA 供應暴增導致價格崩盤，進而加劇 UST 的脫鉤——形成「死亡螺旋」。最終 UST 和 LUNA 雙雙歸零，市場損失超過 400 億美元。</p>
<p><strong>法幣儲備型穩定幣（Fiat-Backed）</strong></p>
<p>由法幣或等價物（短期國債、銀行存款等）1:1 背書。代表項目包括 USDC（Circle）和 USDT（Tether）。這類穩定幣的信任模型依賴於發行方的信譽和定期審計。</p>
<div class="table-wrapper"><table><thead><tr><th>穩定幣類型</th><th>代表</th><th>優點</th><th>缺點</th></tr></thead><tbody>
<tr><td>抵押型</td><td>DAI、LUSD</td><td>去中心化、透明</td><td>資本效率低（超額抵押）</td></tr>
<tr><td>演算法型</td><td>FRAX（混合）、歷史上的 UST</td><td>資本效率高</td><td>極端行情下可能脫鉤崩盤</td></tr>
<tr><td>法幣儲備型</td><td>USDC、USDT</td><td>穩定性最高、流動性最好</td><td>中心化、監管風險、凍結風險</td></tr>
</tbody></table>
</div>
<h2 id="92-系統風險"><a class="header" href="#92-系統風險">9.2 系統風險</a></h2>
<p>DeFi 系統的風險往往是系統性的——單一協議的問題可能透過組合性傳導到整個生態系統。理解這些系統風險是工程師設計穩健協議的前提。</p>
<h3 id="流動性枯竭"><a class="header" href="#流動性枯竭">流動性枯竭</a></h3>
<p>當市場恐慌時，流動性提供者會迅速撤出資金（即「bank run」效應），導致池子深度驟降、滑點暴增、甚至無法執行交易。借貸協議在這種情況下尤其脆弱——存款人爭相提款，但大部分資金已被借出，導致利用率飆升到接近 100%。</p>
<pre><code class="language-text">流動性危機的連鎖反應：

┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│ 市場恐慌      │     │ LP 大量撤出   │     │ 滑點暴增     │
│ (黑天鵝事件)  │────&gt;│ 流動性       │────&gt;│ 交易無法     │
│              │     │              │     │ 正常執行     │
└──────────────┘     └──────────────┘     └──────┬───────┘
                                                  │
                              ┌────────────────────┘
                              v
                     ┌──────────────┐     ┌──────────────┐
                     │ 清算無法完成  │     │ 壞帳產生     │
                     │ (滑點太大    │────&gt;│ 協議資不     │
                     │  清算無利可圖)│     │ 抵債         │
                     └──────────────┘     └──────────────┘
</code></pre>
<p><strong>真實案例</strong>：2023 年 3 月 USDC 脫鉤事件中（受矽谷銀行倒閉影響），Curve 的 3pool（DAI/USDC/USDT）出現嚴重的流動性失衡——USDC 佔比飆升至 70% 以上，DAI 和 USDT 幾乎被換光。</p>
<p><strong>防禦措施</strong>：設定協議層級的流動性底線（minimum liquidity threshold），當流動性低於閾值時自動限制新借款或大額交易。建立協議儲備金（protocol-owned liquidity）作為緩衝。</p>
<h3 id="oracle-延遲或操縱"><a class="header" href="#oracle-延遲或操縱">Oracle 延遲或操縱</a></h3>
<p>Oracle 是 DeFi 的「眼睛」，幾乎所有需要價格資訊的操作都依賴 Oracle。Oracle 的延遲或被操縱會直接導致錯誤的定價，進而被攻擊者利用。</p>
<p><strong>延遲問題</strong>：鏈下價格已經大幅變動，但 Oracle 更新有延遲（Chainlink 通常有 heartbeat interval 和 deviation threshold），攻擊者利用過時價格進行套利。</p>
<p><strong>操縱問題</strong>：攻擊者透過閃電貸在 DEX 上大幅推動價格，如果 DeFi 協議使用該 DEX 的即時價格作為 Oracle，就會被操縱。</p>
<pre><code class="language-text">Oracle 操縱攻擊流程：

Step 1: 攻擊者借入 $10M 閃電貸
Step 2: 在 DEX 上大量買入 Token X，推高價格 50%
Step 3: 在使用該 DEX 價格的借貸協議中，
        用 Token X 作為抵押品（被高估）借出大量穩定幣
Step 4: 歸還閃電貸
Step 5: DEX 價格恢復正常，但攻擊者已帶走超額借款
結果: 借貸協議產生壞帳
</code></pre>
<p><strong>防禦措施</strong>：使用 Chainlink 等去中心化 Oracle（聚合多個資料源）。設定合理的價格偏差閾值。對於低流動性 token，不應作為借貸抵押品。實作 TWAP（Time-Weighted Average Price）緩衝突發價格波動。</p>
<h3 id="清算擁塞"><a class="header" href="#清算擁塞">清算擁塞</a></h3>
<p>在市場大幅下跌時，大量倉位同時觸發清算，導致清算機器人之間的 gas 競爭（gas war），推高 gas 費用，讓部分清算交易無法及時執行。同時，大量清算拋售進一步壓低價格，形成負面循環。</p>
<p><strong>2020 年 3 月 12 日「黑色星期四」</strong>：ETH 價格在 24 小時內暴跌 50%，MakerDAO 系統中的大量 CDP 需要清算。由於 gas 費用暴漲和以太坊網路擁塞，許多清算交易失敗或延遲，部分清算人甚至以 0 DAI 的出價贏得了拍賣（因為沒有競爭者），導致 MakerDAO 產生約 530 萬美元的壞帳。</p>
<p><strong>防禦措施</strong>：</p>
<ul>
<li>引入漸進式清算（partial liquidation），而非一次性全額清算</li>
<li>為清算機器人提供優先通道（如 Flashbots 的 MEV 拍賣）</li>
<li>設定緊急價格底線（circuit breaker），當價格在短時間內下跌超過閾值時暫停清算</li>
<li>使用荷蘭拍賣（Dutch auction）機制，讓清算價格從高到低遞減，確保有競爭者參與</li>
</ul>
<h3 id="參數治理失誤"><a class="header" href="#參數治理失誤">參數治理失誤</a></h3>
<p>DeFi 協議的許多關鍵參數（利率模型、抵押率、清算獎勵等）由社群治理決定。如果參數設定不當，可能導致嚴重的經濟後果。</p>
<p><strong>常見的參數治理風險</strong>：</p>
<ul>
<li><strong>抵押率設太低</strong>：市場快速下跌時來不及清算，產生壞帳</li>
<li><strong>清算獎勵設太低</strong>：無人願意執行清算，壞帳累積</li>
<li><strong>利率曲線斜率不當</strong>：利用率 100% 時利率不夠高，無法激勵還款</li>
<li><strong>新增高風險抵押品</strong>：為追求 TVL 增長而上架低流動性、高波動的 token 作為抵押品</li>
</ul>
<p><strong>案例分析——Aave 凍結 CRV 市場（2022 年）</strong>：攻擊者透過在 Aave 上大量借入 CRV 做空，利用 CRV 的低流動性嘗試製造清算瀑布。雖然攻擊最終未成功（CRV 價格未崩盤），但 Aave 還是產生了約 170 萬美元的壞帳，並因此凍結了 CRV 的借貸功能。</p>
<h2 id="93-交易路由層"><a class="header" href="#93-交易路由層">9.3 交易路由層</a></h2>
<p>在 DeFi 中執行交易不像在中心化交易所那麼簡單。流動性分散在數十個 DEX、數百個流動性池中，找到最優的交易路徑是一個複雜的路由問題。</p>
<h3 id="aggregator-比價"><a class="header" href="#aggregator-比價">Aggregator 比價</a></h3>
<p>DEX Aggregator（如 1inch、ParaSwap、CowSwap）會同時查詢多個 DEX 的價格，找到給定交易量下的最優路徑。對於大額交易，Aggregator 可能會將交易拆分到多個 DEX 以減少滑點。</p>
<pre><code class="language-text">Aggregator 路由邏輯：

用戶: 賣出 100 ETH 買入 USDC

直接在 Uniswap V3 交易:
  100 ETH → Uniswap V3 → 199,500 USDC (滑點 0.25%)

Aggregator 優化路由:
  ┌── 40 ETH → Uniswap V3 ──→  80,200 USDC
  │
  ├── 35 ETH → Curve ETH/USDC → 70,140 USDC
  │
  └── 25 ETH → SushiSwap ─────→ 50,050 USDC
                                 ──────────────
                        Total:   200,390 USDC (多得 890 USDC)
</code></pre>
<h3 id="multi-hop-路徑"><a class="header" href="#multi-hop-路徑">Multi-hop 路徑</a></h3>
<p>有時最優路徑不是直接交易，而是透過中間 token 進行多跳交易。例如將 Token A 換成 Token C，直接 A→C 的池子流動性不佳，但 A→ETH→C 的路徑可能更優。</p>
<pre><code class="language-text">Multi-hop 路由範例：

直接路徑（低流動性）：
  LINK ──────────────────────&gt; MKR
  滑點: 3.5%

Multi-hop 路徑（高流動性中間池）：
  LINK ──&gt; ETH ──&gt; USDC ──&gt; MKR
  滑點:  0.1%   0.05%    0.2%  = 0.35% 總滑點

  節省滑點: 3.15%
</code></pre>
<p><strong>路由演算法</strong>：大部分 Aggregator 使用圖搜尋演算法（類似 Dijkstra 或 Bellman-Ford），將每個流動性池視為圖中的邊，權重為交易成本（滑點 + 手續費 + gas）。目標是找到從輸入 token 到輸出 token 的最低成本路徑。</p>
<h3 id="mev-保護與最小輸出"><a class="header" href="#mev-保護與最小輸出">MEV 保護與最小輸出</a></h3>
<p>MEV（Maximal Extractable Value）是指區塊生產者或 Searcher 透過重新排序、插入或刪除交易來獲取的利潤。對普通用戶而言，MEV 通常意味著被「夾擊」（sandwich attack）。</p>
<pre><code class="language-text">Sandwich Attack（三明治攻擊）：

正常交易:
  User: 賣出 10 ETH → 買入 USDC

被夾擊後:
  1. 攻擊者先買: 買入大量 ETH → 推高 ETH 價格
  2. User 的交易執行: 以更高的價格買到更少的 USDC
  3. 攻擊者後賣: 賣出 ETH → 獲利

時間線:
  ┌──────────┐  ┌──────────┐  ┌──────────┐
  │攻擊者    │  │ User 的   │  │攻擊者    │
  │前置交易   │──│ 交易     │──│後置交易   │
  │(買 ETH)  │  │(賣 ETH)  │  │(賣 ETH)  │
  └──────────┘  └──────────┘  └──────────┘
  在同一個區塊內，攻擊者控制交易順序
</code></pre>
<p><strong>防禦措施</strong>：</p>
<ul>
<li><strong>設定最小輸出量（minAmountOut）</strong>：確保即使被夾擊，損失也在可接受範圍內。例如設定 0.5% 的滑點容忍度。</li>
<li><strong>使用 MEV 保護服務</strong>：如 Flashbots Protect 或 CowSwap（批次拍賣模式，天然抗 MEV）。</li>
<li><strong>Private mempool</strong>：將交易發送到私有記憶池，避免被公開 mempool 中的 Searcher 看到。</li>
<li><strong>Transaction deadline</strong>：設定交易的有效期限，避免交易在 mempool 中停留過久被攻擊。</li>
</ul>
<pre><code class="language-solidity">// 防 MEV 的交易參數設定
function swapExactTokensForTokens(
    uint256 amountIn,
    uint256 amountOutMin,    // 最小輸出量（防滑點 + 防 MEV）
    address[] calldata path,
    address to,
    uint256 deadline          // 交易截止時間
) external returns (uint256[] memory amounts);

// 建議的 amountOutMin 計算
// amountOutMin = expectedOutput * (1 - slippageTolerance)
// 例如: expectedOutput = 2000 USDC, slippage = 0.5%
// amountOutMin = 2000 * 0.995 = 1990 USDC
</code></pre>
<h2 id="94-組合性收益與風險"><a class="header" href="#94-組合性收益與風險">9.4 組合性收益與風險</a></h2>
<p>DeFi 的「可組合性」（Composability）是其最大的特色和最大的風險來源。不同協議之間可以自由互操作，創造出比單一協議更複雜的金融策略。</p>
<h3 id="收益來自費率與槓桿"><a class="header" href="#收益來自費率與槓桿">收益來自費率與槓桿</a></h3>
<p>DeFi Yield 的來源可以歸納為以下幾類：</p>
<ol>
<li><strong>交易手續費</strong>：LP 從每筆交易中收取手續費（通常 0.01%-1%）</li>
<li><strong>借貸利差</strong>：存款利率和借款利率之間的差額</li>
<li><strong>流動性挖礦獎勵</strong>：協議發放治理代幣作為激勵（但這本質上是代幣通膨稀釋）</li>
<li><strong>套利收益</strong>：不同協議或不同鏈之間的價格差異</li>
<li><strong>槓桿收益</strong>：透過循環借貸放大收益（但也放大風險）</li>
</ol>
<pre><code class="language-text">循環借貸槓桿策略（Looping）：

Step 1: 存入 1,000 USDC 到 Aave           → 獲得存款利息
Step 2: 借出 750 USDC (75% LTV)            → 支付借款利息
Step 3: 再存入 750 USDC 到 Aave            → 獲得更多存款利息
Step 4: 再借出 562 USDC                    → 支付更多借款利息
Step 5: 再存入 562 USDC ...
...

最終：
  總存款 ≈ 4,000 USDC（原始 1,000 的 4 倍槓桿）
  總借款 ≈ 3,000 USDC
  淨收益 = (存款利息 × 4,000) - (借款利息 × 3,000) + 獎勵代幣

風險：如果存款利率下降或借款利率上升，策略可能虧損
風險：如果 USDC 脫鉤，可能觸發清算
</code></pre>
<h3 id="風險來自協議依賴鏈"><a class="header" href="#風險來自協議依賴鏈">風險來自協議依賴鏈</a></h3>
<p>當策略依賴多個協議時，任何一個協議的問題都可能導致整個策略失敗。這種依賴鏈的長度決定了策略的風險倍數。</p>
<pre><code class="language-text">Yield Aggregator 的依賴鏈示例：

User -&gt; Vault -&gt; Strategy A (Lending on Aave)
              │   依賴: Aave 合約 + Chainlink Oracle + USDC 穩定性
              │
              ├─&gt; Strategy B (LP Farming on Uniswap V3)
              │   依賴: Uniswap V3 合約 + LP 池流動性 + Token 價格穩定
              │
              └─&gt; Strategy C (Basis Trade on GMX)
                  依賴: GMX 合約 + GLP 池 + 多個 Oracle + Arbitrum L2 正常運作

總依賴數: ~15 個獨立組件
任一組件故障都可能影響 Vault 的整體收益甚至本金

依賴風險矩陣：
┌──────────────────┬────────────────┬──────────────┐
│ 依賴類型          │ 故障影響        │ 歷史故障頻率  │
├──────────────────┼────────────────┼──────────────┤
│ 智能合約漏洞      │ 本金損失        │ 低但致命     │
│ Oracle 異常       │ 錯誤定價/清算   │ 中           │
│ L2 停機          │ 無法操作        │ 低           │
│ 穩定幣脫鉤       │ 策略失效        │ 低但影響大   │
│ 治理攻擊         │ 參數被惡意修改  │ 低           │
│ 流動性枯竭       │ 無法退出        │ 中           │
└──────────────────┴────────────────┴──────────────┘
</code></pre>
<p><strong>真實案例——Yearn Finance Vault 損失（2021 年 2 月）</strong>：Yearn 的 DAI Vault 使用了一個策略，該策略在 Curve 和 Aave 之間套利。攻擊者利用閃電貸操縱 Curve 池的價格，導致策略在錯誤的價格下執行，造成約 1,100 萬美元損失。這個事件展示了多協議組合策略的風險放大效應。</p>
<h2 id="95-工程建議"><a class="header" href="#95-工程建議">9.5 工程建議</a></h2>
<p>作為 DeFi 協議的工程師或 Yield Strategy 的開發者，以下是設計穩健系統的實踐建議：</p>
<h3 id="對外協議設定風險分數"><a class="header" href="#對外協議設定風險分數">對外協議設定風險分數</a></h3>
<p>為每個依賴的外部協議建立風險評估框架。風險分數應考慮以下維度：</p>
<pre><code class="language-text">風險評分模型（1-10 分，10 分最安全）：

┌──────────────────────────────────────────────┐
│           外部協議風險評分卡                     │
│                                                │
│  維度              權重    Aave    新協議 X     │
│  ─────────────     ────    ────    ─────────   │
│  審計次數與品質     20%     9        4          │
│  運行時間(月)       15%     10       2          │
│  TVL 規模          10%     9        3          │
│  開源程度           10%     10       7          │
│  治理去中心化       15%     8        3          │
│  歷史安全紀錄       20%     8        5(未知)    │
│  Oracle 可靠性      10%     9        5          │
│  ─────────────     ────    ────    ─────────   │
│  加權總分           100%    8.85     3.8        │
│                                                │
│  風險等級:                                      │
│  8-10: 低風險 (可配置高比例資金)                  │
│  5-7:  中風險 (限制配置比例)                      │
│  1-4:  高風險 (極少配置或不配置)                   │
└──────────────────────────────────────────────┘
</code></pre>
<h3 id="依分數配置資金上限"><a class="header" href="#依分數配置資金上限">依分數配置資金上限</a></h3>
<p>根據風險分數設定每個外部協議的最大資金配置比例。這樣即使某個協議被攻破，損失也被限制在可承受範圍內。</p>
<pre><code class="language-text">資金配置規則：

總 Vault 資金: $10M

┌─────────────┬─────────┬───────────┬──────────────┐
│ 策略        │ 風險分數 │ 最大配置%  │ 最大配置金額  │
├─────────────┼─────────┼───────────┼──────────────┤
│ Aave 借貸   │ 8.85    │ 40%       │ $4M          │
│ Uniswap LP  │ 8.2     │ 30%       │ $3M          │
│ GMX 永續    │ 7.0     │ 20%       │ $2M          │
│ 新協議 X    │ 3.8     │ 5%        │ $500K        │
│ 現金儲備    │ -       │ 5%        │ $500K        │
└─────────────┴─────────┴───────────┴──────────────┘

公式: max_allocation = base_allocation × (risk_score / 10)^2
</code></pre>
<h3 id="任一依賴異常時觸發策略降檔"><a class="header" href="#任一依賴異常時觸發策略降檔">任一依賴異常時觸發策略降檔</a></h3>
<p>建立即時監控系統，當偵測到任何依賴協議出現異常時，自動觸發防禦機制：</p>
<pre><code class="language-text">策略降檔流程：

正常狀態 (Level 0)
     │
     │ 偵測到異常信號（Oracle 延遲 &gt; 30 分鐘、TVL 驟降 &gt; 20%、合約暫停等）
     v
警戒狀態 (Level 1)
  - 停止新增配置到異常協議
  - 提高監控頻率
  - 通知團隊
     │
     │ 異常持續 &gt; 1 小時 或 損失 &gt; 閾值
     v
撤退狀態 (Level 2)
  - 開始從異常協議撤出資金
  - 轉移到低風險策略（如純穩定幣存款）
  - 暫停 Vault 的新存款
     │
     │ 確認安全事件
     v
緊急狀態 (Level 3)
  - 全部資金撤回 Vault
  - 暫停所有策略
  - 啟動 War Room
  - 用戶可提款但不可存款
</code></pre>
<pre><code class="language-solidity">// 策略降檔虛擬碼
contract VaultGuardian {
    enum AlertLevel { NORMAL, CAUTION, RETREAT, EMERGENCY }
    AlertLevel public currentLevel;

    function checkHealth() external {
        for (uint i = 0; i &lt; strategies.length; i++) {
            IStrategy strategy = strategies[i];

            // 檢查 Oracle 健康
            if (strategy.oracleDelay() &gt; MAX_ORACLE_DELAY) {
                _escalate(i, AlertLevel.CAUTION);
            }

            // 檢查 TVL 變化
            uint256 currentTVL = strategy.tvl();
            uint256 previousTVL = lastKnownTVL[i];
            if (currentTVL &lt; previousTVL * 80 / 100) {  // TVL 下降 &gt; 20%
                _escalate(i, AlertLevel.RETREAT);
            }

            // 檢查合約是否被暫停
            if (strategy.isPaused()) {
                _escalate(i, AlertLevel.EMERGENCY);
            }
        }
    }

    function _escalate(uint256 strategyIndex, AlertLevel level) internal {
        if (level == AlertLevel.RETREAT) {
            strategies[strategyIndex].withdrawAll();
        }
        emit AlertEscalated(strategyIndex, level);
    }
}
</code></pre>
<h3 id="其他工程建議"><a class="header" href="#其他工程建議">其他工程建議</a></h3>
<ul>
<li><strong>策略回測</strong>：在部署新策略前，使用歷史資料（包括黑天鵝事件期間的資料）進行回測。重點關注最大回撤（max drawdown）和極端市場條件下的行為。</li>
<li><strong>漸進式部署</strong>：新策略先用小額資金（例如 TVL 的 1%）試運行至少 2 週，確認無異常後再逐步增加配置。</li>
<li><strong>退出路徑驗證</strong>：定期測試所有策略的緊急退出路徑，確保在極端情況下能在合理時間內（例如 2 個區塊內）撤回全部資金。</li>
<li><strong>Gas 成本監控</strong>：在 gas 費用暴漲時（例如超過 200 gwei），某些低收益策略的 gas 成本可能超過收益。建立 gas 成本監控，在不划算時自動暫停策略的 harvest/rebalance 操作。</li>
<li><strong>事件日誌完整性</strong>：所有資金流動都必須發出事件（event），確保鏈下監控系統能完整追蹤 Vault 的狀態。</li>
</ul>
<h2 id="白話總結"><a class="header" href="#白話總結">白話總結</a></h2>
<p>DeFi 可以想像成一個開放的金融工具箱。AMM 是自動收銀台——你不需要找人對手交易，丟錢進去機器就會按公式算好價格給你兌換。借貸協議是數位當鋪——你把值錢的東西抵押進去，就能借到錢，但如果抵押品跌價太多，當鋪會直接拍賣你的東西。永續合約是一種讓你用少量本金下大注的工具，贏了賺更多，輸了虧更快。穩定幣則是這個世界的「美元」，不同種類的穩定幣就像不同銀行發的支票，有些銀行大到不會倒（USDC/USDT），有些銀行用數學公式來保證支票能兌現（演算法穩定幣，但歷史上多次失敗）。</p>
<p>這些金融積木可以自由組合，產生更複雜的策略。例如你可以把 ETH 存到 Aave 借出 USDC，再把 USDC 投入 Uniswap 做流動性提供者，然後把 LP token 質押到 Yearn 的 Vault 自動管理。這種組合可以放大收益，但也放大了風險——如果其中任何一個環節出問題（Aave 被攻擊、USDC 脫鉤、Uniswap 池被操縱），你的整個策略可能一起崩盤。</p>
<p>交易路由在 DeFi 中非常重要。因為流動性分散在幾十個不同的 DEX 中，直接在一個 DEX 交易可能面臨很大的滑點。Aggregator 就像是比價網站，幫你在所有 DEX 中找到最好的價格，甚至把一筆大單拆成多筆小單分別在不同 DEX 執行。但要小心 MEV 攻擊——有人可能在你的交易前後插入交易來夾擊你，就像有人看到你要買某個商品，搶先買下來再加價賣給你。</p>
<p>作為工程師，最重要的原則是「永遠假設依賴的外部協議可能會出問題」。為每個外部依賴設定風險分數和資金上限，建立自動監控和降檔機制，確保即使最壞的情況發生，損失也在可控範圍內。DeFi 的歷史一再證明：收益越高的策略，背後的風險通常也越大，沒有「免費的午餐」。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="08-l1-l2-bridges.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="10-multisig-and-governance.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="08-l1-l2-bridges.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="10-multisig-and-governance.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
