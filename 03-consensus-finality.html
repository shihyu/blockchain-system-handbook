<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>3. 共識、最終性與重組 - 工程師等級 Web3 系統全圖（完整版）</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">工程師等級 Web3 系統全圖（完整版）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="3-共識最終性與重組"><a class="header" href="#3-共識最終性與重組">3. 共識、最終性與重組</a></h1>
<h2 id="31-共識模型"><a class="header" href="#31-共識模型">3.1 共識模型</a></h2>
<p>共識機制是區塊鏈的心臟——它決定了一群互不信任的節點如何對「哪些交易是有效的、以什麼順序執行」達成一致意見。不同的共識機制在安全性、去中心化程度、最終性速度和能源效率之間做出不同的取捨。作為區塊鏈系統工程師，你不需要發明新的共識機制，但必須深刻理解你所使用的鏈的共識特性，因為這直接影響你的系統在「何時可以信任一筆交易已經完成」這個問題上的設計。</p>
<h3 id="nakamoto-pow-機率最終性"><a class="header" href="#nakamoto-pow-機率最終性">Nakamoto PoW: 機率最終性</a></h3>
<p>Nakamoto Consensus（中本聰共識）是 Bitcoin 採用的共識機制，也是歷史上第一個成功解決拜占庭將軍問題的去中心化方案。其核心思想是「最長鏈規則」——所有節點都選擇累積工作量（Proof of Work）最多的鏈作為正確的鏈。礦工通過消耗計算資源來「挖礦」，找到符合難度要求的 hash 值後就可以產生新區塊。</p>
<p>重組風險隨確認數下降，但永遠不會降到零——這就是「機率最終性」（Probabilistic Finality）的含義。一筆交易被打包進區塊後，後面每多一個區塊確認，被重組的機率就指數級下降。Bitcoin 社群傳統上認為 6 個確認（約 60 分鐘）足夠安全，因為此時攻擊者需要控制超過全網 50% 的算力才有非微不足道的機率成功重組。</p>
<pre><code class="language-text">確認數與安全性 (假設攻擊者控制 10% 算力):

  確認數    被重組機率
  ────────────────────────
  1 確認    ~0.2%
  2 確認    ~0.04%
  3 確認    ~0.008%
  6 確認    ~0.00003%   &lt;── Bitcoin 傳統門檻
  12 確認   ~0.000000001%

  注意: 如果攻擊者控制更多算力，所需確認數要相應增加
</code></pre>
<p><strong>工程實務影響：</strong> 在構建接受 Bitcoin 支付的系統時，你必須決定每種場景需要多少個確認數。一杯咖啡的支付也許 0-confirmation 就可以接受（輔以其他風控手段），但一筆 100 BTC 的 OTC 交易可能需要 6 個甚至更多確認。不同確認數對應不同的等待時間（每個確認約 10 分鐘），這直接影響用戶體驗。</p>
<pre><code class="language-python"># 偽碼: 根據金額決定確認數
def required_confirmations(amount_btc: float) -&gt; int:
    if amount_btc &lt; 0.01:
        return 1     # 小額，快速確認
    elif amount_btc &lt; 1.0:
        return 3     # 中等金額
    elif amount_btc &lt; 10.0:
        return 6     # 大額，標準門檻
    else:
        return 12    # 超大額，最高安全
</code></pre>
<h3 id="pos--bft-經濟懲罰--檢查點"><a class="header" href="#pos--bft-經濟懲罰--檢查點">PoS + BFT: 經濟懲罰 + 檢查點</a></h3>
<p>Proof of Stake（權益證明）搭配 BFT（Byzantine Fault Tolerance）變種是目前大多數新一代區塊鏈採用的共識機制。Ethereum 在 2022 年 9 月完成 The Merge，從 PoW 轉換到 PoS。在 PoS 中，驗證者質押（stake）原生代幣作為保證金，如果他們試圖作弊（例如同時為兩個衝突的區塊簽名），他們的質押會被削減（slashing）。</p>
<p>Ethereum 的 PoS 共識（Casper FFG + LMD GHOST）將時間劃分為 slot（12 秒）和 epoch（32 個 slot = 6.4 分鐘）。每個 epoch 結束時，如果有超過 2/3 的驗證者對該 epoch 的檢查點投票，該檢查點就被「justified」；如果連續兩個 epoch 的檢查點都被 justified，較早的那個就被「finalized」。Finalized 的區塊在協議層面是不可逆的——要回滾它需要至少 1/3 的驗證者被 slashed（在 Ethereum 上意味著數十億美元的經濟損失）。</p>
<pre><code class="language-text">Ethereum PoS Finality 流程:

  Epoch N-1          Epoch N            Epoch N+1
  [32 slots]         [32 slots]         [32 slots]
  ─────────── ──────────────── ────────────────
       │                │                │
  Checkpoint A     Checkpoint B    Checkpoint C
       │                │                │
       └── justified ──&gt;│                │
                        └── justified ──&gt;│
                        │                │
                   A finalized!    B finalized!
                   (不可逆)

  從交易被打包到 finalized ≈ 12-15 分鐘
</code></pre>
<p><strong>其他 PoS + BFT 的實作：</strong></p>
<ul>
<li>
<p><strong>Tendermint（Cosmos 生態）：</strong> 採用即時最終性——一旦區塊被 2/3 的驗證者簽名確認，就立即 finalized，不存在分叉的可能。延遲通常在 6-7 秒。代價是如果超過 1/3 的驗證者離線，整條鏈會停止出塊（liveness 犧牲換取 safety）。</p>
</li>
<li>
<p><strong>Tower BFT（Solana）：</strong> 利用 Proof of History 作為時間戳機制，結合類 PBFT 共識。Solana 的 vote 交易佔了全網交易量的很大比例（有時超過 50%），這些 vote 就是驗證者在進行共識。Finality 通常在 12-15 秒。</p>
</li>
<li>
<p><strong>Narwhal + Bullshark（Sui）：</strong> 基於 DAG（有向無環圖）的共識，先做資料傳播（Narwhal），再做排序（Bullshark）。對不涉及共享物件的「簡單交易」可以跳過共識直接確認，延遲低於 500ms。</p>
</li>
</ul>
<h3 id="rollup-l2-本地排序--l1-結算最終性"><a class="header" href="#rollup-l2-本地排序--l1-結算最終性">Rollup: L2 本地排序 + L1 結算最終性</a></h3>
<p>Rollup 的共識模型與 L1 根本不同。Rollup 不需要自己的去中心化共識——它依賴 L1 的共識作為最終的安全保障。L2 的 Sequencer（排序器）只是決定交易的執行順序，然後把結果（以及證明）提交到 L1。</p>
<p>這產生了多層級的最終性，工程上需要非常小心地區分：</p>
<pre><code class="language-text">Rollup 最終性層級:

  ┌───────────────────────────────────────────────────────────────┐
  │ Level 0: Sequencer Confirmation (即時)                        │
  │   Sequencer 回傳「交易已收到並排序」                            │
  │   信任假設: 信任 Sequencer 不會惡意重排或丟棄                   │
  │   風險: Sequencer 可能當機、審查交易、MEV 重排                  │
  ├───────────────────────────────────────────────────────────────┤
  │ Level 1: L1 Batch Submission (數分鐘到數小時)                  │
  │   交易批次被提交到 L1 的合約中                                  │
  │   信任假設: 資料已在 L1 上可用，任何人可驗證                    │
  │   風險: 仍未被最終驗證（Optimistic Rollup 的挑戰期尚未開始）    │
  ├───────────────────────────────────────────────────────────────┤
  │ Level 2: L1 Finality (Optimistic: 7天 / ZK: 數小時)           │
  │   Optimistic: 7 天挑戰期過後無人提出欺詐證明                   │
  │   ZK: 零知識證明被 L1 合約驗證通過                              │
  │   信任假設: L1 的共識安全                                      │
  │   風險: 與 L1 相同（幾乎可忽略）                               │
  └───────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>工程決策：</strong> 大多數 Rollup 上的應用在 Level 0（Sequencer Confirmation）就視為交易完成。這對於 DEX 交易、遊戲互動等場景是合理的——Sequencer 惡意行為的機率很低，且即使發生，用戶可以通過 L1 的 escape hatch 機制取回資金。但對於大額跨鏈轉帳、交易所入金等高風險場景，應該等到 Level 1 甚至 Level 2。</p>
<h2 id="32-最終性層級"><a class="header" href="#32-最終性層級">3.2 最終性層級</a></h2>
<p>最終性（Finality）是區塊鏈工程中最容易被誤解的概念之一。很多開發者簡單地認為「交易被打包進區塊 = 交易完成」，但事實遠非如此。不同鏈、不同場景下的「完成」有著截然不同的含義和安全保障。</p>
<h3 id="soft-finality軟最終性"><a class="header" href="#soft-finality軟最終性">Soft Finality（軟最終性）</a></h3>
<p><strong>通常幾秒到幾分鐘，可能被重組。</strong> Soft Finality 是指交易已經被打包進區塊，但該區塊尚未積累足夠的確認或通過最終性檢查點。在這個階段，區塊有可能因為分叉競爭而被重組——你的交易可能從主鏈上消失。</p>
<p>Soft Finality 適用於低風險場景：查看 NFT 元資料、顯示交易歷史、更新 UI 狀態等。在這些場景中，即使交易最終被重組，也不會造成資金損失。</p>
<pre><code class="language-text">各鏈 Soft Finality 時間:

  Bitcoin:       ~10 分鐘 (1 個確認)
  Ethereum:      ~12 秒 (1 個 slot)
  Solana:        ~400ms (1 個 slot)
  Polygon PoS:   ~2 秒 (1 個區塊)
  Arbitrum:      即時 (Sequencer 回傳)
  Avalanche:     ~1-2 秒 (Snowball 協議)
</code></pre>
<h3 id="economic-finality經濟最終性"><a class="header" href="#economic-finality經濟最終性">Economic Finality（經濟最終性）</a></h3>
<p><strong>回滾成本高，實務可視為完成。</strong> Economic Finality 是指雖然協議層面理論上仍可能被回滾，但這樣做的經濟成本已經高到不理性的程度。例如，要回滾 Ethereum 的一個 finalized epoch，需要至少 1/3 的驗證者願意被 slashed——在當前質押量下，這意味著超過 100 億美元的經濟損失。理性的攻擊者不會這樣做，因為攻擊成本遠高於可能的收益。</p>
<p>Economic Finality 是大多數業務場景的實際依據。交易所的入金確認、支付閘道的訂單結算、DeFi 協議的清算觸發，通常都在 Economic Finality 階段就執行。</p>
<p><strong>如何評估 Economic Finality 的安全性？</strong> 核心公式是：</p>
<pre><code class="language-text">安全條件: 攻擊成本 &gt; 攻擊收益

Bitcoin PoW:
  攻擊成本 = 控制 51% 算力的硬體 + 電力 + 機會成本
           ≈ 數十億美元 (持續攻擊)
  攻擊收益 = 雙重花費的金額

Ethereum PoS:
  攻擊成本 = 1/3 質押量被 slashed
           ≈ 100+ 億美元
  攻擊收益 = 雙重花費的金額

小型 PoS 鏈:
  攻擊成本 = 1/3 質押量被 slashed
           ≈ 可能只有數百萬美元
  ⚠️ 如果你的業務涉及超過這個金額的交易，安全性不足！
</code></pre>
<h3 id="cryptographic-finality密碼學最終性"><a class="header" href="#cryptographic-finality密碼學最終性">Cryptographic Finality（密碼學最終性）</a></h3>
<p><strong>協議層不可逆（或需懲罰超過閾值）。</strong> 這是最強的最終性保證——交易一旦被標記為 finalized，在協議規則內就絕對不可能被回滾。Tendermint 共識的即時最終性、Ethereum 的 finalized checkpoint、ZK Rollup 的 proof 被 L1 驗證通過，都屬於 Cryptographic Finality。</p>
<pre><code class="language-text">最終性強度比較:

  弱 ──────────────────────────────────────────── 強

  Soft         Economic         Cryptographic
  (可能被       (回滾成本         (協議層
   重組)        極高)             不可逆)

  │             │                │
  1 確認        6+ 確認          Finalized
  Sequencer     L1 Batch         ZK Proof
  回傳          Submitted        Verified
</code></pre>
<h3 id="各鏈最終性時間對照"><a class="header" href="#各鏈最終性時間對照">各鏈最終性時間對照</a></h3>
<div class="table-wrapper"><table><thead><tr><th>鏈</th><th>Soft Finality</th><th>Economic Finality</th><th>Cryptographic Finality</th></tr></thead><tbody>
<tr><td>Bitcoin</td><td>~10 分鐘</td><td>~60 分鐘 (6 確認)</td><td>無（機率最終性）</td></tr>
<tr><td>Ethereum</td><td>~12 秒</td><td>~6 分鐘 (1 epoch)</td><td>~12 分鐘 (2 epochs)</td></tr>
<tr><td>Solana</td><td>~400ms</td><td>~12 秒 (32 slots)</td><td>~12 秒</td></tr>
<tr><td>Cosmos (Tendermint)</td><td>~6 秒</td><td>~6 秒</td><td>~6 秒（即時最終性）</td></tr>
<tr><td>Arbitrum (Optimistic)</td><td>即時</td><td>數分鐘 (L1 batch)</td><td>~7 天 (挑戰期)</td></tr>
<tr><td>zkSync (ZK Rollup)</td><td>即時</td><td>數分鐘 (L1 batch)</td><td>數小時 (proof 驗證)</td></tr>
</tbody></table>
</div>
<p><strong>工程上的關鍵決策：</strong> 你的系統在哪個最終性層級採取行動？這個決策直接影響用戶體驗和安全性的平衡。以下是常見的業務場景對應：</p>
<pre><code class="language-text">業務場景 vs 最終性需求:

  場景                        建議最終性層級       原因
  ──────────────────────────────────────────────────────────
  前端 UI 更新               Soft Finality       用戶體驗優先
  DEX swap 確認              Soft Finality       金額通常較小
  交易所入金 (小額)          Economic Finality   平衡速度和安全
  交易所入金 (大額)          Cryptographic        資金安全第一
  跨鏈橋資產釋放             Cryptographic        歷史事故慘痛
  財務結算/對帳               Cryptographic        會計準確性
</code></pre>
<h2 id="33-重組reorg工程處理"><a class="header" href="#33-重組reorg工程處理">3.3 重組（Reorg）工程處理</a></h2>
<p>區塊重組（Reorg）是區塊鏈系統中最危險、也最容易被忽視的場景。Reorg 發生時，原本被認為有效的區塊和交易被替換為另一條分叉鏈上的區塊和交易。你的系統之前基於「已確認」交易做出的所有決策——入金、出金、清算、狀態更新——可能全部需要回滾。</p>
<h3 id="為什麼會發生-reorg"><a class="header" href="#為什麼會發生-reorg">為什麼會發生 Reorg</a></h3>
<p>Reorg 的原因有多種：</p>
<ol>
<li>
<p><strong>自然分叉：</strong> 兩個礦工/驗證者幾乎同時產生了合法的區塊，網路短暫分裂。隨著下一個區塊產生，較短的分叉被拋棄。這種 reorg 通常只有 1-2 個區塊深度，在 PoW 鏈上最常見。</p>
</li>
<li>
<p><strong>網路延遲：</strong> 區塊傳播到全網需要時間。如果某些節點因為網路延遲而暫時落後，它們可能會在收到較長鏈後切換（reorg）。</p>
</li>
<li>
<p><strong>惡意攻擊：</strong> 攻擊者秘密挖掘一條更長的鏈，然後突然公布，迫使網路重組。目的通常是雙重花費（double spend）——在公開鏈上花費代幣購買商品，然後用秘密鏈替換，使花費交易消失。</p>
</li>
<li>
<p><strong>客戶端 Bug：</strong> 不同客戶端對同一區塊的有效性判斷不一致，導致部分節點接受而部分節點拒絕某個區塊，最終在分歧解決後發生 reorg。</p>
</li>
</ol>
<pre><code class="language-text">Block N      Block N+1      Block N+2
   |             |             |
   +------A------+------B------+------C-----&gt; 主鏈
            \
             +------B'-----C'-----------&gt; 分叉鏈(短暫)
</code></pre>
<pre><code class="language-text">深度 Reorg 攻擊示例:

  公開鏈:   ...──[100]──[101]──[102]──[103]──[104]
                                                    ^
                                            交易所確認入金
  攻擊者    ...──[100]──[101']──[102']──[103']──[104']──[105']
  秘密鏈:                                                 ^
                                                   攻擊者公布
                                                   網路切換到此鏈
                                                   交易所入金被回滾!
</code></pre>
<h3 id="事件處理採可回滾模型"><a class="header" href="#事件處理採可回滾模型">事件處理採「可回滾模型」</a></h3>
<p>在工程設計上，任何基於鏈上事件觸發的業務邏輯，都必須設計為可回滾的。這意味著你不能在收到一個事件後就立刻執行不可逆的操作（如匯出法幣、發送實體商品、刪除用戶記錄）。</p>
<pre><code class="language-text">可回滾事件處理架構:

  鏈上事件 ──&gt; 事件監聽器 ──&gt; 事件資料庫 ──&gt; 業務處理器
                   │              │              │
                   │         記錄區塊高度      根據狀態
                   │         和交易 hash       決定行動
                   │              │
                   │         Reorg 偵測器 ──&gt; 標記受影響事件
                   │              │              │
                   │              └──────────&gt; 回滾業務操作
                   │
                   └── 訂閱 newHeads
                       比對 parentHash
                       偵測 reorg
</code></pre>
<p><strong>Reorg 偵測的實作方式：</strong> 最可靠的方法是追蹤每個區塊的 parentHash。當你收到一個新區塊時，檢查它的 parentHash 是否等於你記錄的前一個區塊的 hash。如果不匹配，就發生了 reorg。你需要向前回溯，找到公共祖先區塊，然後重新處理從公共祖先之後的所有區塊。</p>
<pre><code class="language-python"># 偽碼: Reorg 偵測
class ReorgDetector:
    def __init__(self):
        self.block_cache = {}  # block_number -&gt; block_hash

    def process_block(self, block):
        expected_parent = self.block_cache.get(block.number - 1)

        if expected_parent and expected_parent != block.parent_hash:
            # 偵測到 Reorg!
            reorg_depth = self.find_common_ancestor(block)
            self.handle_reorg(reorg_depth)

        self.block_cache[block.number] = block.hash

    def find_common_ancestor(self, block):
        depth = 0
        current = block
        while current.parent_hash != self.block_cache.get(current.number - 1):
            depth += 1
            current = self.rpc.get_block(current.parent_hash)
        return depth

    def handle_reorg(self, depth):
        # 1. 找出受影響的事件
        # 2. 標記這些事件為 "reorged"
        # 3. 觸發業務回滾
        # 4. 重新處理新鏈上的區塊
        alert(f"Reorg detected! Depth: {depth}")
</code></pre>
<h3 id="入帳分級"><a class="header" href="#入帳分級">入帳分級</a></h3>
<p>入帳分級是處理最終性風險的核心機制。每筆交易經歷三個狀態：</p>
<ul>
<li>
<p><strong><code>pending</code></strong>: 交易已被偵測到（在 mempool 中或被打包進 1 個區塊），但尚未達到安全確認數。系統可以顯示「處理中」，但不能基於此執行任何業務操作。</p>
</li>
<li>
<p><strong><code>confirmed(k)</code></strong>: 交易已被 k 個區塊確認。k 的值取決於鏈和金額。在此狀態下，系統可以執行低風險的業務操作（如更新顯示餘額），但高風險操作（如允許提現）仍應等待。</p>
</li>
<li>
<p><strong><code>finalized</code></strong>: 交易已達到鏈的最終性保證。在此狀態下，系統可以執行所有業務操作，包括不可逆的操作。</p>
</li>
</ul>
<pre><code class="language-text">入帳狀態機:

  ┌─────────┐    k 個區塊確認    ┌──────────────┐    Finalized    ┌───────────┐
  │ pending  │ ────────────────&gt; │ confirmed(k) │ ─────────────&gt; │ finalized │
  └─────────┘                   └──────────────┘                └───────────┘
       │                              │
       │ Reorg                        │ Reorg (罕見但可能)
       ▼                              ▼
  ┌─────────┐                   ┌──────────────┐
  │ dropped │                   │  rolled_back │
  └─────────┘                   └──────────────┘
</code></pre>
<h3 id="針對大額交易提高確認數"><a class="header" href="#針對大額交易提高確認數">針對大額交易提高確認數</a></h3>
<p>這不只是「等久一點」那麼簡單。提高確認數的策略需要考慮以下因素：</p>
<ol>
<li>
<p><strong>確認數的階梯式設計：</strong> 根據交易金額設定不同的確認數門檻。小額交易 1-2 個確認即可，中額交易需要 6 個確認，大額交易需要 12 個以上確認或等待 finalized。</p>
</li>
<li>
<p><strong>動態調整：</strong> 根據當前的鏈上環境動態調整確認數。如果鏈上正在發生 reorg（即使只是淺層的 1-block reorg），自動提高所有交易的確認數門檻。</p>
</li>
<li>
<p><strong>同一地址的關聯分析：</strong> 如果同一個地址在短時間內送入多筆中等金額的交易，總金額可能超過大額門檻。風控系統需要將這些交易作為整體評估。</p>
</li>
</ol>
<pre><code class="language-text">確認數策略示例 (Ethereum):

  金額 (ETH)     所需確認數     等待時間
  ──────────────────────────────────────
  &lt; 0.1          1 slot         ~12 秒
  0.1 - 1.0      3 slots        ~36 秒
  1.0 - 10.0     1 epoch        ~6 分鐘
  10.0 - 100.0   2 epochs       ~12 分鐘 (finalized)
  &gt; 100.0        finalized +    ~12 分鐘 + 額外等待
                 人工審核
</code></pre>
<h2 id="34-檢查點策略"><a class="header" href="#34-檢查點策略">3.4 檢查點策略</a></h2>
<p>檢查點策略是將最終性理論轉化為工程實踐的關鍵環節。不同的業務系統有不同的風險承受能力，因此需要針對性的策略設計。</p>
<h3 id="交易策略-依資產風險配置確認數"><a class="header" href="#交易策略-依資產風險配置確認數">交易策略: 依資產風險配置確認數</a></h3>
<p>不同資產的風險等級不同。主流資產（BTC、ETH）的流動性好、市場深度大，被用於雙重花費攻擊的成本較高。但低市值代幣或流動性差的 NFT 可能被攻擊者利用：在一條鏈上出售，在另一條分叉上取消出售。</p>
<pre><code class="language-text">資產風險分級:

  Tier 1 (低風險): BTC, ETH, USDC, USDT
    確認數: 標準值
    原因: 市值大、流動性好、攻擊成本高

  Tier 2 (中風險): 主流 DeFi 代幣 (UNI, AAVE, LINK)
    確認數: 標準值 × 1.5
    原因: 市值中等、可能被閃電貸操縱

  Tier 3 (高風險): 小市值代幣、新上線代幣
    確認數: 標準值 × 3 或等待 finalized
    原因: 容易被操縱、可能是詐騙代幣

  特殊: NFT
    確認數: finalized
    原因: 不可替代、價值難以評估、Wash Trading 風險
</code></pre>
<h3 id="服務策略-api-對外預設-confirmed財務結算用-finalized"><a class="header" href="#服務策略-api-對外預設-confirmed財務結算用-finalized">服務策略: API 對外預設 confirmed，財務結算用 finalized</a></h3>
<p>設計對外 API 時，需要明確定義不同端點使用的最終性層級。一個常見的設計是讓查詢類 API 使用 <code>confirmed</code> 狀態（回應更快、用戶體驗更好），而財務結算相關的 API 使用 <code>finalized</code> 狀態（安全性優先）。</p>
<pre><code class="language-text">API 最終性設計:

  GET /api/v1/balance?address=0x...
    回傳: confirmed 餘額 (最新，但可能被 reorg)
    用途: 前端顯示

  GET /api/v1/balance?address=0x...&amp;finality=finalized
    回傳: finalized 餘額 (稍舊，但確定不會變)
    用途: 交易前的餘額驗證

  POST /api/v1/settlement
    要求: 所有輸入交易必須是 finalized 狀態
    原因: 結算是不可逆操作
</code></pre>
<pre><code class="language-javascript">// 偽碼: API 最終性中間件
function finalityMiddleware(req, res, next) {
  const finality = req.query.finality || 'confirmed';

  switch (finality) {
    case 'latest':
      // 最新區塊，可能被 reorg (最快)
      req.blockTag = 'latest';
      break;
    case 'confirmed':
      // 已確認但未 finalized (預設)
      req.blockTag = 'safe';  // Ethereum 的 safe tag
      break;
    case 'finalized':
      // 已 finalized (最安全)
      req.blockTag = 'finalized';
      break;
    default:
      return res.status(400).json({ error: 'Invalid finality level' });
  }

  next();
}
</code></pre>
<h3 id="風控策略-同一地址高頻提現套用延遲機制"><a class="header" href="#風控策略-同一地址高頻提現套用延遲機制">風控策略: 同一地址高頻提現套用延遲機制</a></h3>
<p>風控策略是最終性管理的最後一道防線。即使交易已經 finalized，如果風控系統偵測到異常模式，仍然應該延遲或阻止業務操作。</p>
<p><strong>常見的異常模式：</strong></p>
<ul>
<li><strong>高頻提現：</strong> 同一地址在短時間內發起多筆提現，可能是私鑰被盜後的快速轉移。</li>
<li><strong>新地址大額入金後立即提現：</strong> 可能是雙重花費攻擊的前奏——攻擊者先入金、快速提現、然後 reorg 取消入金。</li>
<li><strong>跨鏈閃電操作：</strong> 在多條鏈上同時進行入金/提現/swap 的複雜操作，可能是套利攻擊或跨鏈 MEV。</li>
</ul>
<pre><code class="language-text">風控規則示例:

  Rule 1: 單地址高頻提現
    條件: 同一地址在 1 小時內提現次數 &gt; 5
    動作: 後續提現自動延遲 30 分鐘 + 人工審核

  Rule 2: 新地址快速提現
    條件: 地址首次入金後 &lt; 24 小時即提現
    動作: 提現需等待 finalized + 額外 6 小時冷卻期

  Rule 3: 大額入金後全額提現
    條件: 入金 &gt; $10,000 且提現金額 &gt; 入金的 90%
    動作: 強制人工審核

  Rule 4: Reorg 期間凍結
    條件: 偵測到任何深度 &gt; 1 的 reorg
    動作: 暫停所有提現，等待鏈穩定後恢復
</code></pre>
<h2 id="35-跨鏈場景的最終性挑戰"><a class="header" href="#35-跨鏈場景的最終性挑戰">3.5 跨鏈場景的最終性挑戰</a></h2>
<p>跨鏈操作將最終性問題的複雜度提升了一個數量級。你不只需要確認源鏈上的交易已經 finalized，還需要確認目標鏈上的操作也已完成。兩條鏈有不同的最終性時間、不同的 reorg 機率、不同的安全假設——這些差異的組合使得跨鏈系統的設計極為棘手。</p>
<pre><code class="language-text">跨鏈最終性時間線:

  源鏈 (Ethereum)                     目標鏈 (Arbitrum)
  ─────────────────────────────────   ──────────────────────────
  [交易送出]
  │ ~12 秒
  [Soft Finality]
  │ ~12 分鐘
  [Finalized]
  │                                   [橋合約偵測到 finalized 事件]
  │                                   │ ~數分鐘
  │                                   [目標鏈釋放資產]
  │                                   │ ~即時 (Sequencer)
  │                                   [Soft Finality]
  │                                   │ ~7 天 (如需等待 L2 finality)
  │                                   [Cryptographic Finality]

  總時間: 12 分鐘 (最低) 到 7 天 (最高安全)
</code></pre>
<p><strong>最佳實踐：</strong></p>
<ol>
<li>
<p><strong>源鏈等待 finalized 再釋放目標鏈資產。</strong> 不要為了速度而在 Soft Finality 階段就釋放——Wormhole、Ronin Bridge 的事故都與不充分的源鏈驗證有關。</p>
</li>
<li>
<p><strong>目標鏈設置速率限制。</strong> 即使源鏈驗證通過，也應該對單位時間內跨鏈轉移的金額設置上限。這樣即使橋被攻破，損失也在可控範圍內。</p>
</li>
<li>
<p><strong>實施時間延遲提款。</strong> 大額跨鏈轉移應該有冷卻期，給監控系統時間來偵測和反應。</p>
</li>
</ol>
<h2 id="36-mev-與最終性的交互影響"><a class="header" href="#36-mev-與最終性的交互影響">3.6 MEV 與最終性的交互影響</a></h2>
<p>MEV（Maximal Extractable Value，最大可提取價值）是指礦工/驗證者/排序器通過控制交易排序而獲得的額外利潤。MEV 與最終性有著密切的關係：在交易從 pending 到 finalized 的過程中，MEV 搜索者有動機嘗試重新排序、插入或移除交易。</p>
<pre><code class="language-text">MEV 影響最終性的方式:

  1. Front-running (搶跑)
     看到 mempool 中的大額 swap 交易
     在它前面插入自己的 swap
     在 Soft Finality 階段就能獲利

  2. Sandwich Attack (三明治攻擊)
     在目標交易前後各插入一筆交易
     利用目標交易造成的價格滑點獲利

  3. Time-bandit Attack (時間強盜攻擊)
     如果重組的獲利 &gt; 重組的成本
     礦工有經濟動機去嘗試 reorg
     這直接威脅了 Economic Finality 的假設!

  防禦:
  - 使用 Flashbots 等私有交易池 (不進公開 mempool)
  - 設置合理的 slippage tolerance
  - 監控 mempool 中的可疑交易模式
</code></pre>
<p><strong>Time-bandit Attack</strong> 是 MEV 與 reorg 交集中最令人擔憂的場景。如果某個區塊包含一個極其有利可圖的 MEV 機會（例如大額清算），礦工可能會試圖重組該區塊，將 MEV 收入據為己有。這意味著 Economic Finality 的安全性不只取決於算力/質押量，還取決於區塊中的 MEV 價值。如果一個區塊的 MEV 價值超過了重組的成本，理性的攻擊者就有動機去嘗試 reorg。</p>
<h2 id="白話總結"><a class="header" href="#白話總結">白話總結</a></h2>
<p>「打包進區塊」不代表 100% 定案。工程上要把「可回滾」當預設，而不是例外。這是區塊鏈系統開發中最反直覺、也最重要的心智模型轉變。在傳統後端開發中，一旦資料寫入資料庫並 commit，你可以認為它就是確定的。但在區塊鏈上，交易被打包進區塊只是「暫時有效」——它隨時可能因為區塊重組而消失。</p>
<p>不同的鏈有不同的最終性模型。Bitcoin 永遠是機率最終性，6 個確認只是讓被重組的機率低到「可接受」的程度；Ethereum 有明確的 finalized 狀態，大約 12 分鐘後交易就真正不可逆了；Solana 和 Cosmos 等鏈有接近即時的最終性，但前者的安全保障較弱。作為工程師，你需要知道每條鏈的最終性時間表，並據此設計你的入帳策略。</p>
<p>入帳分級（pending / confirmed / finalized）是處理最終性問題的標準工程範式。不要把所有交易都當成「已確認」或「未確認」的二元狀態，而是要設計一個多階段的狀態機，讓不同風險等級的業務操作在不同的最終性階段被觸發。小額入金可以在 confirmed 就讓用戶看到餘額更新，但大額提現必須等到 finalized 才能放行。風控系統則是最後一道防線，即使交易已經 finalized，異常的行為模式仍然應該觸發延遲或人工審核。記住：在區塊鏈上，過度謹慎的代價只是「慢一點」，但不夠謹慎的代價可能是「錢沒了」。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="02-chain-models.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="04-data-network-structure.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="02-chain-models.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="04-data-network-structure.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
