<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>第5章 Go語言區塊鏈高級應用開發 - 工程師等級 Web3 系統全圖（完整版）</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">工程師等級 Web3 系統全圖（完整版）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="第5章-go-語言區塊鏈高級應用開發"><a class="header" href="#第5章-go-語言區塊鏈高級應用開發">第5章 Go 語言區塊鏈高級應用開發</a></h1>
<p>本章以「做出一條可跑的簡化區塊鏈」為目標，重點在資料結構與交易流程是否自洽。</p>
<h2 id="51-go-語言與區塊鏈開發準備"><a class="header" href="#51-go-語言與區塊鏈開發準備">5.1 Go 語言與區塊鏈開發準備</a></h2>
<h3 id="511-go-語言與-hash-函數-p0"><a class="header" href="#511-go-語言與-hash-函數-p0">5.1.1 Go 語言與 hash 函數 <code>P0</code></a></h3>
<p>常用組件：</p>
<ul>
<li><code>crypto/sha256</code></li>
<li><code>encoding/hex</code></li>
<li><code>bytes</code></li>
</ul>
<p>設計原則：</p>
<ul>
<li>區塊、交易都要有穩定序列化</li>
<li>hash 結果用 <code>[]byte</code> 儲存，顯示時才轉 hex</li>
</ul>
<p>在建造自己的區塊鏈之前，必須把 hash 函數的使用方式釘死。不同於第三章的概念介紹，這裡要解決的是工程實作中「如何確保 hash 在所有節點上計算結果一致」的問題。這個問題看似簡單，但在實務中是 bug 最多的地方之一。</p>
<p>hash 一致性的關鍵在於序列化。同一個 <code>Block</code> struct，如果序列化方式不一致，hash 結果就不同。Go 的 <code>encoding/json</code> 在不同版本中可能改變 key 排列順序（雖然實際上它按字母序排列），更危險的是浮點數的序列化——<code>1.0</code> 和 <code>1</code> 在 JSON 中可能被不同實作處理成不同字串。因此，區塊鏈中永遠不要用 JSON 做 hash 前的序列化，而要用 binary encoding。</p>
<pre><code class="language-go">package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/binary"
	"encoding/hex"
	"fmt"
)

// 穩定序列化：用 binary encoding 確保跨平台一致
func IntToBytes(n int64) []byte {
	buf := new(bytes.Buffer)
	_ = binary.Write(buf, binary.BigEndian, n)
	return buf.Bytes()
}

// 計算區塊 header hash
func CalcBlockHash(prevHash, merkleRoot []byte, timestamp, nonce int64) []byte {
	data := bytes.Join([][]byte{
		prevHash,
		merkleRoot,
		IntToBytes(timestamp),
		IntToBytes(nonce),
	}, []byte{})

	hash := sha256.Sum256(data)
	return hash[:]
}

// 雙重 hash（Bitcoin 風格）
func DoubleHash(data []byte) []byte {
	first := sha256.Sum256(data)
	second := sha256.Sum256(first[:])
	return second[:]
}

func main() {
	hash := CalcBlockHash(
		[]byte{0x00}, // prevHash (genesis)
		[]byte("merkle-root"),
		1700000000,
		42,
	)
	fmt.Println(hex.EncodeToString(hash))
}
</code></pre>
<p>最佳實踐：</p>
<ul>
<li>所有整數使用 <code>binary.BigEndian</code> 序列化</li>
<li>hash 結果在記憶體中用 <code>[]byte</code> 傳遞，只在顯示給人看時轉 <code>hex.EncodeToString</code></li>
<li>為每個需要 hash 的結構體寫一個 <code>Serialize()</code> 方法，並用 regression test 鎖定</li>
</ul>
<p>常見坑：</p>
<ul>
<li>用 <code>fmt.Sprintf("%v", block)</code> 做序列化——Go struct 的 print 格式不穩定</li>
<li>忘記 <code>sha256.Sum256</code> 回傳的是 <code>[32]byte</code> 而不是 <code>[]byte</code>，需要用 <code>hash[:]</code> 轉換</li>
<li>不同節點的系統時鐘不同步，如果把 <code>time.Now()</code> 直接放進 hash，可能導致不同節點算出不同的 hash</li>
</ul>
<h3 id="512-go-語言與-base58-編碼-p0"><a class="header" href="#512-go-語言與-base58-編碼-p0">5.1.2 Go 語言與 Base58 編碼 <code>P0</code></a></h3>
<p>Base58 用於人類可讀地址，避免 <code>0/O/I/l</code> 混淆。</p>
<p>典型地址流程：</p>
<ol>
<li>公鑰 hash（<code>SHA256 + RIPEMD160</code>）</li>
<li>加版本前綴</li>
<li>加 checksum</li>
<li>Base58 編碼</li>
</ol>
<p>Base58 是 Bitcoin 專門設計的編碼格式。相比 Base64，Base58 去掉了 <code>0</code>、<code>O</code>、<code>I</code>、<code>l</code>、<code>+</code>、<code>/</code> 這六個容易混淆或在 URL 中有特殊意義的字元。結果是：地址可以被安全地複製貼上、口頭朗讀、列印在紙上，降低了人為出錯的機率。</p>
<p>Checksum 是地址安全的最後一道防線。Bitcoin 地址的 checksum 是對 <code>version + payload</code> 做兩次 SHA256，取前 4 bytes 附加在末尾。當用戶輸入一個地址時，程式可以重新計算 checksum 並比對，如果不匹配就說明地址被輸入錯了。這個機制的錯誤檢測率超過 99.99%。</p>
<pre><code class="language-text">地址生成完整流程：

Public Key (65 bytes, uncompressed)
    │
    v
SHA256 ──&gt; RIPEMD160 ──&gt; PubKeyHash (20 bytes)
    │
    v
Version Byte (0x00 for mainnet) + PubKeyHash
    │
    v
Double SHA256 ──&gt; 取前 4 bytes ──&gt; Checksum
    │
    v
Version + PubKeyHash + Checksum
    │
    v
Base58Encode ──&gt; Bitcoin Address (如: 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa)
</code></pre>
<pre><code class="language-go">// Base58 編碼實作
var b58Alphabet = []byte("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")

func Base58Encode(input []byte) []byte {
	var result []byte
	x := new(big.Int).SetBytes(input)
	base := big.NewInt(58)
	zero := big.NewInt(0)
	mod := new(big.Int)

	for x.Cmp(zero) != 0 {
		x.DivMod(x, base, mod)
		result = append(result, b58Alphabet[mod.Int64()])
	}

	// 反轉
	for i, j := 0, len(result)-1; i &lt; j; i, j = i+1, j-1 {
		result[i], result[j] = result[j], result[i]
	}

	// 處理前導零（對應 Base58 的 '1'）
	for _, b := range input {
		if b != 0x00 {
			break
		}
		result = append([]byte{b58Alphabet[0]}, result...)
	}

	return result
}

// 生成帶 checksum 的地址
func GenerateAddress(pubKeyHash []byte, version byte) []byte {
	versionedPayload := append([]byte{version}, pubKeyHash...)
	checksum := Checksum(versionedPayload)
	fullPayload := append(versionedPayload, checksum...)
	return Base58Encode(fullPayload)
}

func Checksum(payload []byte) []byte {
	first := sha256.Sum256(payload)
	second := sha256.Sum256(first[:])
	return second[:4] // 只取前 4 bytes
}
</code></pre>
<p>常見坑：</p>
<ul>
<li>前導零的處理很容易出錯——在 Base58 中，0x00 對應 '1'，必須特別處理</li>
<li>混淆 Base58 和 Base58Check——後者包含 version byte 和 checksum</li>
<li>使用第三方 Base58 庫時沒有驗證其處理前導零的行為</li>
</ul>
<h3 id="513-go-語言與默克爾樹-p0"><a class="header" href="#513-go-語言與默克爾樹-p0">5.1.3 Go 語言與默克爾樹 <code>P0</code></a></h3>
<p>Merkle Tree 用於交易集合摘要：</p>
<ul>
<li>葉節點：交易 hash</li>
<li>父節點：<code>hash(left || right)</code></li>
<li>根節點：區塊 header 的 <code>MerkleRoot</code></li>
</ul>
<p>Merkle Tree 是區塊鏈中驗證資料完整性的核心資料結構。它的精妙之處在於：你不需要下載所有交易就能驗證某筆交易是否包含在區塊中。只需要提供一條從葉節點到根節點的「證明路徑」（Merkle Proof），大小是 O(log n)，就能完成驗證。Bitcoin 的 SPV（Simplified Payment Verification）輕節點正是基於這個原理運作的。</p>
<pre><code class="language-text">Merkle Tree 結構：

              Root Hash
            /          \
        Hash01          Hash23
       /      \        /      \
    Hash0    Hash1   Hash2    Hash3
      |        |       |        |
    Tx0      Tx1     Tx2      Tx3

驗證 Tx1 是否在樹中，只需要：
  - Tx1 本身
  - Hash0（兄弟節點）
  - Hash23（叔父節點）

路徑：hash(Tx1) -&gt; hash(Hash0 || Hash1) -&gt; hash(Hash01 || Hash23) == Root?
大小：O(log n) 而非 O(n)
</code></pre>
<p>對於輕錢包（如手機端），Merkle Proof 的價值巨大。一個包含 4000 筆交易的區塊，完整下載需要幾百 KB，但 Merkle Proof 只需要 12 個 hash（每個 32 bytes），總共 384 bytes 就能驗證任意一筆交易的存在性。</p>
<pre><code class="language-go">// Merkle Tree 實作
type MerkleTree struct {
	RootNode *MerkleNode
}

type MerkleNode struct {
	Left  *MerkleNode
	Right *MerkleNode
	Data  []byte
}

func NewMerkleNode(left, right *MerkleNode, data []byte) *MerkleNode {
	node := &amp;MerkleNode{}

	if left == nil &amp;&amp; right == nil {
		// 葉節點：直接 hash 交易資料
		hash := sha256.Sum256(data)
		node.Data = hash[:]
	} else {
		// 內部節點：hash(left || right)
		prevHashes := append(left.Data, right.Data...)
		hash := sha256.Sum256(prevHashes)
		node.Data = hash[:]
	}

	node.Left = left
	node.Right = right
	return node
}

func NewMerkleTree(data [][]byte) *MerkleTree {
	if len(data) == 0 {
		return &amp;MerkleTree{}
	}

	var nodes []*MerkleNode

	// 奇數個葉節點時，複製最後一個
	if len(data)%2 != 0 {
		data = append(data, data[len(data)-1])
	}

	// 建立葉節點
	for _, datum := range data {
		nodes = append(nodes, NewMerkleNode(nil, nil, datum))
	}

	// 逐層構建
	for len(nodes) &gt; 1 {
		if len(nodes)%2 != 0 {
			nodes = append(nodes, nodes[len(nodes)-1])
		}
		var level []*MerkleNode
		for i := 0; i &lt; len(nodes); i += 2 {
			node := NewMerkleNode(nodes[i], nodes[i+1], nil)
			level = append(level, node)
		}
		nodes = level
	}

	return &amp;MerkleTree{RootNode: nodes[0]}
}
</code></pre>
<p>常見坑：</p>
<ul>
<li>奇數葉節點時複製最後一個葉節點（Bitcoin 的做法，但這引入了一個已知的「duplicate transaction」漏洞，CVE-2012-2459）</li>
<li>序列化不一致導致根 hash 不一致</li>
<li>沒有處理空交易列表的邊界情況</li>
</ul>
<h3 id="514-go-語言實現-p2p-網絡-p0"><a class="header" href="#514-go-語言實現-p2p-網絡-p0">5.1.4 Go 語言實現 P2P 網絡 <code>P0</code></a></h3>
<p>最小消息定義建議：</p>
<ul>
<li><code>version</code></li>
<li><code>getblocks</code></li>
<li><code>inv</code></li>
<li><code>getdata</code></li>
<li><code>block</code></li>
<li><code>tx</code></li>
</ul>
<p>實現一個最小但可用的 P2P 網路層，需要解決三個核心問題：消息定義、消息路由、狀態同步。Bitcoin 的 P2P 協議定義了超過 30 種消息類型，但對於教學鏈，6 種就足夠讓兩個節點互相同步區塊和交易。</p>
<pre><code class="language-text">節點同步流程（Initial Block Download）：

Node A (新節點)              Node B (已有區塊)

1. version ─────────────&gt;
                          &lt;───────────── version
2. getblocks ───────────&gt;  (告訴 B 自己的最高區塊)
                          &lt;───────────── inv (回覆 B 有但 A 沒有的區塊 hash 列表)
3. getdata ─────────────&gt;  (請求具體的區塊)
                          &lt;───────────── block (回覆完整區塊)
   (驗證並儲存區塊)
   (重複 3 直到同步完成)
</code></pre>
<pre><code class="language-go">// 消息類型定義
const (
	CmdVersion   = "version"
	CmdGetBlocks = "getblocks"
	CmdInv       = "inv"
	CmdGetData   = "getdata"
	CmdBlock     = "block"
	CmdTx        = "tx"
)

// Version 消息
type MsgVersion struct {
	Version     int32
	BestHeight  int64
	AddrFrom    string
}

// Inv 消息（庫存通知）
type MsgInv struct {
	Type  string   // "block" or "tx"
	Items [][]byte // hash 列表
}

// P2P 伺服器骨架
type Server struct {
	nodeAddr   string
	knownPeers map[string]bool
	blockchain *Blockchain
	mempool    map[string]*Transaction
	mu         sync.RWMutex
}

func (s *Server) Start() error {
	ln, err := net.Listen("tcp", s.nodeAddr)
	if err != nil {
		return err
	}
	defer ln.Close()

	// 啟動時向 seed nodes 發送 version
	for peer := range s.knownPeers {
		go s.sendVersion(peer)
	}

	for {
		conn, err := ln.Accept()
		if err != nil {
			log.Printf("accept error: %v", err)
			continue
		}
		go s.handleConnection(conn)
	}
}

func (s *Server) handleConnection(conn net.Conn) {
	defer conn.Close()
	// 設定讀取超時
	conn.SetReadDeadline(time.Now().Add(30 * time.Second))

	msg, err := readMessage(conn)
	if err != nil {
		return
	}

	switch msg.Command {
	case CmdVersion:
		s.handleVersion(msg, conn)
	case CmdGetBlocks:
		s.handleGetBlocks(msg, conn)
	case CmdInv:
		s.handleInv(msg, conn)
	case CmdGetData:
		s.handleGetData(msg, conn)
	case CmdBlock:
		s.handleBlock(msg, conn)
	case CmdTx:
		s.handleTx(msg, conn)
	}
}
</code></pre>
<p>工程建議：</p>
<ul>
<li>每種消息用獨立 handler</li>
<li>建立 peer set 與去重 cache</li>
<li>記錄最後已知區塊高度</li>
<li>為每個 peer 維護一個 send queue，避免在 handler 中直接寫 socket 造成阻塞</li>
<li>用 <code>context.Context</code> 控制 goroutine 生命週期，避免洩漏</li>
</ul>
<h2 id="52-go-語言實現-pow-共識算法"><a class="header" href="#52-go-語言實現-pow-共識算法">5.2 Go 語言實現 PoW 共識算法</a></h2>
<h3 id="521-區塊定義與數據串行化-p0"><a class="header" href="#521-區塊定義與數據串行化-p0">5.2.1 區塊定義與數據串行化 <code>P0</code></a></h3>
<p>核心結構：</p>
<pre><code class="language-go">type Block struct {
    Version    int64
    PrevHash   []byte
    MerkleRoot []byte
    Timestamp  int64
    Bits       int64
    Nonce      int64
    Hash       []byte
    Txs        []*Transaction
}
</code></pre>
<p>區塊結構的設計是整條鏈的基礎。Bitcoin 的區塊 header 固定 80 bytes，包含 6 個欄位：Version、PrevHash、MerkleRoot、Timestamp、Bits、Nonce。這個設計的精妙之處在於：header 與交易資料分離——PoW 挖礦只需要計算 80 bytes 的 header hash，而不需要把所有交易都放進計算。交易資料通過 MerkleRoot 間接綁定到 header 上。</p>
<pre><code class="language-text">區塊結構解剖：

┌─────────────────────────────────────────┐
│              Block Header (80 bytes)     │
│  ┌─────────────┬──────────────────────┐ │
│  │ Version     │ 協議版本號 (4 bytes)  │ │
│  ├─────────────┼──────────────────────┤ │
│  │ PrevHash    │ 前一區塊 hash (32B)  │ │
│  ├─────────────┼──────────────────────┤ │
│  │ MerkleRoot  │ 交易 Merkle 根 (32B) │ │
│  ├─────────────┼──────────────────────┤ │
│  │ Timestamp   │ 出塊時間戳 (4 bytes) │ │
│  ├─────────────┼──────────────────────┤ │
│  │ Bits        │ 難度目標 (4 bytes)    │ │
│  ├─────────────┼──────────────────────┤ │
│  │ Nonce       │ 隨機數 (4 bytes)      │ │
│  └─────────────┴──────────────────────┘ │
├─────────────────────────────────────────┤
│              Transactions                │
│  ┌──────────────────────────────────┐   │
│  │ Coinbase Tx (區塊獎勵)           │   │
│  ├──────────────────────────────────┤   │
│  │ Tx 1                            │   │
│  ├──────────────────────────────────┤   │
│  │ Tx 2                            │   │
│  ├──────────────────────────────────┤   │
│  │ ...                             │   │
│  └──────────────────────────────────┘   │
└─────────────────────────────────────────┘
</code></pre>
<p>序列化建議：</p>
<ul>
<li><code>encoding/gob</code>（教學簡單）或 <code>protobuf</code>（可演進）</li>
<li>解碼錯誤要立即失敗，不可靜默忽略</li>
</ul>
<p><code>encoding/gob</code> 是 Go 原生的序列化格式，使用簡單，但有一個重要限制：它不是跨語言的。如果你的鏈未來需要支持非 Go 客戶端，建議從一開始就使用 protobuf 或 CBOR。</p>
<pre><code class="language-go">// 區塊序列化與反序列化
func (b *Block) Serialize() ([]byte, error) {
	var result bytes.Buffer
	encoder := gob.NewEncoder(&amp;result)
	if err := encoder.Encode(b); err != nil {
		return nil, fmt.Errorf("serialize block: %w", err)
	}
	return result.Bytes(), nil
}

func DeserializeBlock(data []byte) (*Block, error) {
	var block Block
	decoder := gob.NewDecoder(bytes.NewReader(data))
	if err := decoder.Decode(&amp;block); err != nil {
		return nil, fmt.Errorf("deserialize block: %w", err)
	}
	return &amp;block, nil
}

// 建立新區塊的工廠函數
func NewBlock(txs []*Transaction, prevHash []byte, height int64) *Block {
	block := &amp;Block{
		Version:   1,
		PrevHash:  prevHash,
		Timestamp: time.Now().Unix(),
		Txs:       txs,
	}

	// 計算 Merkle Root
	var txHashes [][]byte
	for _, tx := range txs {
		txHashes = append(txHashes, tx.ID)
	}
	tree := NewMerkleTree(txHashes)
	block.MerkleRoot = tree.RootNode.Data

	// 執行 PoW
	pow := NewProofOfWork(block)
	nonce, hash := pow.Mine()
	block.Nonce = nonce
	block.Hash = hash

	return block
}
</code></pre>
<h3 id="522-pow-算法實現-p0"><a class="header" href="#522-pow-算法實現-p0">5.2.2 PoW 算法實現 <code>P0</code></a></h3>
<p>流程：</p>
<ol>
<li>準備區塊 header bytes</li>
<li>從 nonce=0 迭代</li>
<li>計算 hash，與 target 比較</li>
<li>命中後寫入區塊 <code>Nonce</code> 與 <code>Hash</code></li>
</ol>
<pre><code class="language-text">PrepareHeader -&gt; Hash -&gt; CompareTarget -&gt; Success? -&gt; next nonce
</code></pre>
<p>PoW 的實作看似簡單（就是個 for 迴圈），但有幾個工程細節決定了正確性和效能。首先，<code>prepareData</code> 必須確保欄位順序和序列化方式在所有節點上完全一致。其次，target 的計算必須從 <code>Bits</code> 欄位正確轉換——Bitcoin 使用一種壓縮格式來表示 256 bit 的 target。</p>
<pre><code class="language-go">// PoW 完整實作
const targetBits = 16 // 教學用低難度

type ProofOfWork struct {
	block  *Block
	target *big.Int
}

func NewProofOfWork(b *Block) *ProofOfWork {
	target := big.NewInt(1)
	target.Lsh(target, uint(256-targetBits))
	return &amp;ProofOfWork{b, target}
}

// 準備用於 hash 的資料
func (pow *ProofOfWork) prepareData(nonce int64) []byte {
	return bytes.Join([][]byte{
		pow.block.PrevHash,
		pow.block.MerkleRoot,
		IntToBytes(pow.block.Timestamp),
		IntToBytes(int64(targetBits)),
		IntToBytes(nonce),
	}, []byte{})
}

// 挖礦
func (pow *ProofOfWork) Mine() (int64, []byte) {
	var hashInt big.Int
	var hash [32]byte
	nonce := int64(0)
	maxNonce := int64(math.MaxInt64)

	fmt.Printf("Mining block with %d transactions...\n", len(pow.block.Txs))

	for nonce &lt; maxNonce {
		data := pow.prepareData(nonce)
		hash = sha256.Sum256(data)
		hashInt.SetBytes(hash[:])

		if hashInt.Cmp(pow.target) == -1 {
			fmt.Printf("Found! nonce=%d hash=%x\n", nonce, hash)
			break
		}
		nonce++
	}
	return nonce, hash[:]
}

// 驗證——收到區塊後必須執行
func (pow *ProofOfWork) Validate() bool {
	var hashInt big.Int
	data := pow.prepareData(pow.block.Nonce)
	hash := sha256.Sum256(data)
	hashInt.SetBytes(hash[:])
	isValid := hashInt.Cmp(pow.target) == -1

	// 額外驗證：重算的 hash 必須與區塊聲稱的 hash 一致
	if isValid &amp;&amp; !bytes.Equal(hash[:], pow.block.Hash) {
		return false
	}
	return isValid
}
</code></pre>
<p>驗證函數：</p>
<ul>
<li>每個節點收到區塊都必須重算驗證</li>
<li>不能信任對方提供的 <code>Hash</code> 欄位</li>
<li>驗證成本是 O(1)（一次 hash 計算），但挖礦成本是 O(2^targetBits) 期望值</li>
</ul>
<p>最佳實踐：</p>
<ul>
<li>在挖礦過程中定期檢查是否有新區塊到達（如果有，應該中止當前挖礦，基於新區塊重新開始）</li>
<li>將挖礦邏輯放在獨立的 goroutine 中，用 <code>context.WithCancel</code> 控制中止</li>
</ul>
<h2 id="53-區塊數據如何持久化"><a class="header" href="#53-區塊數據如何持久化">5.3 區塊數據如何持久化</a></h2>
<h3 id="531-go-語言與-boltdb-實戰-p0"><a class="header" href="#531-go-語言與-boltdb-實戰-p0">5.3.1 Go 語言與 boltDB 實戰 <code>P0</code></a></h3>
<p>BoltDB（bbolt）特性：</p>
<ul>
<li>單機嵌入式 KV</li>
<li>ACID 交易</li>
<li>讀多寫少場景適合教學鏈</li>
</ul>
<p>BoltDB（現在的維護版本是 bbolt，由 etcd 團隊維護）是 Go 生態中最受歡迎的嵌入式 KV 儲存之一。它的 API 非常簡潔：所有操作都在 <code>Tx</code>（事務）中完成，<code>View</code> 是唯讀事務，<code>Update</code> 是讀寫事務。bbolt 使用 B+ tree 作為底層資料結構，所有資料按 key 排序存儲，支持高效的範圍查詢。</p>
<p>對於教學鏈，bbolt 是理想的選擇：不需要安裝外部資料庫、不需要管理連線池、不需要網路通訊。但它有一個重要限制：同一時間只允許一個寫事務（因為使用了檔案鎖）。對於生產級區塊鏈，通常會選擇 LevelDB（Bitcoin Core 使用）或 RocksDB（Ethereum geth 使用）。</p>
<p>建議 bucket：</p>
<ul>
<li><code>blocks</code>：<code>hash -&gt; block bytes</code></li>
<li><code>meta</code>：<code>lastHash -&gt; ...</code></li>
<li><code>utxo</code>：<code>txid:vout -&gt; output</code></li>
</ul>
<pre><code class="language-go">// 資料庫初始化
func InitDB(dbPath string) (*bolt.DB, error) {
	db, err := bolt.Open(dbPath, 0600, &amp;bolt.Options{Timeout: 1 * time.Second})
	if err != nil {
		return nil, fmt.Errorf("open db: %w", err)
	}

	err = db.Update(func(tx *bolt.Tx) error {
		// 建立必要的 bucket
		for _, bucket := range []string{"blocks", "meta", "utxo"} {
			_, err := tx.CreateBucketIfNotExists([]byte(bucket))
			if err != nil {
				return fmt.Errorf("create bucket %s: %w", bucket, err)
			}
		}
		return nil
	})
	return db, err
}

// 儲存區塊
func SaveBlock(db *bolt.DB, block *Block) error {
	return db.Update(func(tx *bolt.Tx) error {
		blocksBucket := tx.Bucket([]byte("blocks"))
		metaBucket := tx.Bucket([]byte("meta"))

		// 序列化並寫入
		data, err := block.Serialize()
		if err != nil {
			return err
		}
		if err := blocksBucket.Put(block.Hash, data); err != nil {
			return err
		}

		// 更新 lastHash
		return metaBucket.Put([]byte("lastHash"), block.Hash)
	})
}
</code></pre>
<h3 id="532-區塊數據如何持久化-p0"><a class="header" href="#532-區塊數據如何持久化-p0">5.3.2 區塊數據如何持久化 <code>P0</code></a></h3>
<p>寫入流程：</p>
<ol>
<li>驗證區塊</li>
<li>寫入 <code>blocks</code></li>
<li>更新 <code>lastHash</code></li>
<li>更新 UTXO 索引</li>
</ol>
<p>持久化流程的正確性至關重要——如果寫入過程中崩潰，資料庫可能處於不一致狀態。bbolt 的 ACID 事務保證了原子性：要麼所有操作都成功，要麼都不生效。但我們仍然需要確保寫入順序的邏輯正確性。</p>
<pre><code class="language-go">// 完整的區塊持久化流程
func (bc *Blockchain) AddBlock(block *Block) error {
	// 1. 驗證區塊
	if err := bc.validateBlock(block); err != nil {
		return fmt.Errorf("invalid block: %w", err)
	}

	// 2. 在一個事務中完成所有寫入
	return bc.db.Update(func(tx *bolt.Tx) error {
		blocksBucket := tx.Bucket([]byte("blocks"))
		metaBucket := tx.Bucket([]byte("meta"))
		utxoBucket := tx.Bucket([]byte("utxo"))

		// 2a. 寫入區塊
		data, _ := block.Serialize()
		if err := blocksBucket.Put(block.Hash, data); err != nil {
			return err
		}

		// 2b. 更新 UTXO 索引
		for _, txn := range block.Txs {
			// 刪除已花費的 UTXO
			for _, vin := range txn.Vin {
				key := fmt.Sprintf("%x:%d", vin.Txid, vin.Vout)
				if err := utxoBucket.Delete([]byte(key)); err != nil {
					return err
				}
			}
			// 添加新的 UTXO
			for idx, vout := range txn.Vout {
				key := fmt.Sprintf("%x:%d", txn.ID, idx)
				data, _ := SerializeOutput(vout)
				if err := utxoBucket.Put([]byte(key), data); err != nil {
					return err
				}
			}
		}

		// 2c. 更新 lastHash
		return metaBucket.Put([]byte("lastHash"), block.Hash)
	})
}
</code></pre>
<h3 id="533-區塊數據如何遍歷-p0"><a class="header" href="#533-區塊數據如何遍歷-p0">5.3.3 區塊數據如何遍歷 <code>P0</code></a></h3>
<p>從 <code>lastHash</code> 反向走 <code>PrevHash</code> 到 genesis：</p>
<pre><code class="language-text">last -&gt; prev -&gt; prev -&gt; ... -&gt; genesis
</code></pre>
<p>區塊鏈的遍歷與普通鏈表相反——我們從最新的區塊開始，沿著 <code>PrevHash</code> 指標一路走到創世區塊。這個設計的原因是：新區塊總是引用前一個區塊，而不是前一個區塊引用後一個區塊（因為出塊時還不知道下一個區塊是什麼）。</p>
<pre><code class="language-go">// 區塊鏈迭代器
type BlockchainIterator struct {
	currentHash []byte
	db          *bolt.DB
}

func (bc *Blockchain) Iterator() *BlockchainIterator {
	var lastHash []byte
	bc.db.View(func(tx *bolt.Tx) error {
		meta := tx.Bucket([]byte("meta"))
		lastHash = meta.Get([]byte("lastHash"))
		return nil
	})
	return &amp;BlockchainIterator{currentHash: lastHash, db: bc.db}
}

func (it *BlockchainIterator) Next() (*Block, error) {
	if len(it.currentHash) == 0 {
		return nil, nil // 已到達 genesis 之前
	}

	var block *Block
	err := it.db.View(func(tx *bolt.Tx) error {
		blocksBucket := tx.Bucket([]byte("blocks"))
		data := blocksBucket.Get(it.currentHash)
		if data == nil {
			return fmt.Errorf("block not found: %x", it.currentHash)
		}
		var err error
		block, err = DeserializeBlock(data)
		return err
	})

	if err != nil {
		return nil, err
	}

	it.currentHash = block.PrevHash
	return block, nil
}

// 使用範例：列印所有區塊
func PrintChain(bc *Blockchain) {
	it := bc.Iterator()
	for {
		block, err := it.Next()
		if err != nil || block == nil {
			break
		}
		fmt.Printf("Block %x\n", block.Hash)
		fmt.Printf("  PrevHash: %x\n", block.PrevHash)
		fmt.Printf("  Timestamp: %d\n", block.Timestamp)
		fmt.Printf("  Nonce: %d\n", block.Nonce)
		fmt.Printf("  Transactions: %d\n", len(block.Txs))
		fmt.Println()
	}
}
</code></pre>
<p>常見坑：</p>
<ul>
<li>遍歷未處理空 hash 終止條件（genesis block 的 PrevHash 是全零）</li>
<li>DB 交易未關閉造成資源泄漏（bbolt 的 <code>View</code> 和 <code>Update</code> 會自動管理，但如果手動使用 <code>tx.Begin()</code>，必須確保 <code>Commit</code> 或 <code>Rollback</code>）</li>
<li>遍歷過程中修改資料庫，導致迭代器失效</li>
</ul>
<h2 id="54-go-語言實現-utxo-模型"><a class="header" href="#54-go-語言實現-utxo-模型">5.4 Go 語言實現 UTXO 模型</a></h2>
<h3 id="541-如何定義交易-p0"><a class="header" href="#541-如何定義交易-p0">5.4.1 如何定義交易 <code>P0</code></a></h3>
<pre><code class="language-go">type TXInput struct {
    Txid      []byte
    Vout      int
    Signature []byte
    PubKey    []byte
}

type TXOutput struct {
    Value      int
    PubKeyHash []byte
}

type Transaction struct {
    ID   []byte
    Vin  []TXInput
    Vout []TXOutput
}
</code></pre>
<p>交易結構是 UTXO 模型的核心。<code>TXInput</code> 引用一個之前的 <code>TXOutput</code>（通過 <code>Txid</code> 和 <code>Vout</code> 索引），<code>TXOutput</code> 定義了新的資產歸屬。一筆交易可以有多個輸入和多個輸出，這讓「合併」和「分割」UTXO 成為可能。</p>
<p>交易 ID 的計算方式很重要：它是整筆交易（去除簽名後）的 hash。為什麼要去除簽名？因為簽名本身依賴於交易 ID（你要先知道交易的內容才能簽名），如果交易 ID 包含簽名，就會形成循環依賴。Bitcoin 的做法是：先計算不含簽名的交易 hash 作為 ID，然後用私鑰對這個 ID 簽名。</p>
<pre><code class="language-go">// 計算交易 ID
func (tx *Transaction) CalcHash() {
	// 暫時清除簽名，避免循環依賴
	txCopy := *tx
	for i := range txCopy.Vin {
		txCopy.Vin[i].Signature = nil
		txCopy.Vin[i].PubKey = nil
	}

	var buf bytes.Buffer
	enc := gob.NewEncoder(&amp;buf)
	_ = enc.Encode(txCopy)

	hash := sha256.Sum256(buf.Bytes())
	tx.ID = hash[:]
}

// TXOutput 的鎖定與解鎖
func (out *TXOutput) Lock(address []byte) {
	pubKeyHash := Base58Decode(address)
	pubKeyHash = pubKeyHash[1 : len(pubKeyHash)-4] // 去除 version 和 checksum
	out.PubKeyHash = pubKeyHash
}

func (out *TXOutput) IsLockedWithKey(pubKeyHash []byte) bool {
	return bytes.Equal(out.PubKeyHash, pubKeyHash)
}
</code></pre>
<h3 id="542-如何判斷-coinbase-交易-p0"><a class="header" href="#542-如何判斷-coinbase-交易-p0">5.4.2 如何判斷 CoinBase 交易 <code>P0</code></a></h3>
<p>規則：</p>
<ul>
<li><code>len(Vin) == 1</code></li>
<li><code>Vin[0].Txid == nil</code></li>
<li><code>Vin[0].Vout == -1</code></li>
</ul>
<p>CoinBase 交易是區塊鏈中「創造新幣」的唯一途徑。每個區塊的第一筆交易必須是 CoinBase，它沒有任何輸入（因為幣是憑空產生的），只有輸出。礦工通過 CoinBase 交易獲得區塊獎勵和該區塊中所有交易的手續費。</p>
<p>Bitcoin 的 CoinBase 交易有一個額外功能：它的「輸入」欄位可以攜帶任意資料（最多 100 bytes）。Satoshi 在創世區塊的 CoinBase 中寫入了著名的 "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"。礦池通常在這裡寫入礦池標識和區塊高度。</p>
<pre><code class="language-go">// 建立 CoinBase 交易
func NewCoinbaseTX(to string, data string) *Transaction {
	if data == "" {
		data = fmt.Sprintf("Reward to %s", to)
	}

	txin := TXInput{
		Txid:      nil,
		Vout:      -1,
		Signature: nil,
		PubKey:    []byte(data), // CoinBase 可以攜帶任意資料
	}

	txout := NewTXOutput(BlockReward, to) // BlockReward 如 50 BTC

	tx := Transaction{
		Vin:  []TXInput{txin},
		Vout: []TXOutput{*txout},
	}
	tx.CalcHash()
	return &amp;tx
}

// 判斷是否為 CoinBase 交易
func (tx *Transaction) IsCoinbase() bool {
	return len(tx.Vin) == 1 &amp;&amp;
		tx.Vin[0].Txid == nil &amp;&amp;
		tx.Vin[0].Vout == -1
}
</code></pre>
<h3 id="543-如何使用-coinbase-交易-p0"><a class="header" href="#543-如何使用-coinbase-交易-p0">5.4.3 如何使用 CoinBase 交易 <code>P0</code></a></h3>
<p>CoinBase 用於區塊獎勵，通常每個區塊第一筆交易。</p>
<p>實作要點：</p>
<ul>
<li>獎勵值可參數化</li>
<li>高度可寫入 <code>scriptSig</code> 或附加欄位</li>
</ul>
<p>Bitcoin 的區塊獎勵每 210,000 個區塊減半一次：最初是 50 BTC，2012 年減半到 25 BTC，2016 年 12.5 BTC，2020 年 6.25 BTC，2024 年 3.125 BTC。這個減半機制確保了 Bitcoin 的總量上限為 2100 萬枚。在教學鏈中，可以簡化為固定獎勵或以區塊高度計算減半。</p>
<pre><code class="language-go">const InitialReward = 50

// 根據區塊高度計算獎勵
func CalcBlockReward(height int64) int {
	halvings := height / 210000
	if halvings &gt;= 64 { // 超過 64 次減半後獎勵為 0
		return 0
	}
	return InitialReward &gt;&gt; uint(halvings)
}
</code></pre>
<h3 id="544-如何查找賬戶的-utxo-p0"><a class="header" href="#544-如何查找賬戶的-utxo-p0">5.4.4 如何查找賬戶的 UTXO <code>P0</code></a></h3>
<p>流程：</p>
<ol>
<li>從 UTXO 集索引查 <code>PubKeyHash</code> 匹配輸出</li>
<li>累加直到滿足轉帳金額</li>
<li>回傳可用輸入與總額</li>
</ol>
<p>UTXO 查找是錢包最高頻的操作之一。查餘額等於掃描所有屬於某個地址的未花費輸出並求和。為了效率，我們維護一個獨立的 UTXO 集合索引，而不是每次都遍歷整條鏈。</p>
<pre><code class="language-go">// UTXO 集合
type UTXOSet struct {
	db *bolt.DB
}

// 查詢地址餘額
func (u *UTXOSet) GetBalance(pubKeyHash []byte) int {
	balance := 0
	u.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte("utxo"))
		c := b.Cursor()
		for k, v := c.First(); k != nil; k, v = c.Next() {
			out := DeserializeOutput(v)
			if out.IsLockedWithKey(pubKeyHash) {
				balance += out.Value
			}
		}
		return nil
	})
	return balance
}

// 查找足夠的 UTXO 用於交易（coin selection）
func (u *UTXOSet) FindSpendableOutputs(pubKeyHash []byte, amount int) (int, map[string][]int) {
	unspentOutputs := make(map[string][]int)
	accumulated := 0

	u.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte("utxo"))
		c := b.Cursor()
		for k, v := c.First(); k != nil; k, v = c.Next() {
			// key 格式: "txid:vout"
			parts := strings.SplitN(string(k), ":", 2)
			txID := parts[0]
			outIdx, _ := strconv.Atoi(parts[1])

			out := DeserializeOutput(v)
			if out.IsLockedWithKey(pubKeyHash) {
				accumulated += out.Value
				unspentOutputs[txID] = append(unspentOutputs[txID], outIdx)

				if accumulated &gt;= amount {
					return nil // 夠了，提前終止
				}
			}
		}
		return nil
	})
	return accumulated, unspentOutputs
}
</code></pre>
<p>常見坑：</p>
<ul>
<li>沒標記已花費輸出，導致雙花</li>
<li>未處理變更輸出導致餘額錯誤</li>
<li>coin selection 沒有考慮手續費——找到剛好夠轉帳金額的 UTXO 後，扣除手續費就不夠了</li>
<li>在高並發場景下，同一個 UTXO 被兩筆交易同時選中</li>
</ul>
<h3 id="545-如何發送交易-p0"><a class="header" href="#545-如何發送交易-p0">5.4.5 如何發送交易 <code>P0</code></a></h3>
<p>完整流程：</p>
<ol>
<li>選 UTXO（coin selection）</li>
<li>建輸入輸出（含找零）</li>
<li>對每個輸入簽名</li>
<li>計算 txid</li>
<li>廣播到交易池</li>
</ol>
<pre><code class="language-text">SelectUTXO -&gt; BuildTx -&gt; SignInputs -&gt; Verify -&gt; Broadcast
</code></pre>
<p>發送交易是 UTXO 模型中最複雜的操作。每一步都有嚴格的正確性要求：coin selection 要確保輸入金額足夠、找零必須產生、簽名必須覆蓋所有輸入、驗證必須重算 hash。</p>
<pre><code class="language-go">// 發送交易的完整實作
func NewTransaction(from, to string, amount int, utxoSet *UTXOSet, wallets *Wallets) (*Transaction, error) {
	wallet := wallets.GetWallet(from)
	pubKeyHash := HashPubKey(wallet.PublicKey)

	// 1. Coin Selection
	accumulated, validOutputs := utxoSet.FindSpendableOutputs(pubKeyHash, amount)
	if accumulated &lt; amount {
		return nil, fmt.Errorf("insufficient funds: have %d, need %d", accumulated, amount)
	}

	// 2. 建立輸入
	var inputs []TXInput
	for txid, outs := range validOutputs {
		txIDBytes, _ := hex.DecodeString(txid)
		for _, out := range outs {
			inputs = append(inputs, TXInput{
				Txid:   txIDBytes,
				Vout:   out,
				PubKey: wallet.PublicKey,
			})
		}
	}

	// 3. 建立輸出（收款人 + 找零）
	outputs := []TXOutput{*NewTXOutput(amount, to)}
	if accumulated &gt; amount {
		// 找零回到發送者——這一步絕對不能忘！
		outputs = append(outputs, *NewTXOutput(accumulated-amount, from))
	}

	tx := Transaction{Vin: inputs, Vout: outputs}
	tx.CalcHash()

	// 4. 簽名
	utxoSet.Blockchain.SignTransaction(&amp;tx, wallet.PrivateKey)

	return &amp;tx, nil
}
</code></pre>
<p>最佳實踐：</p>
<ul>
<li>永遠在 <code>NewTransaction</code> 結束前驗證 <code>sum(inputs) == sum(outputs) + fee</code></li>
<li>找零地址最好用新地址（提升隱私性）</li>
<li>coin selection 策略：優先選擇「剛好夠用」的 UTXO，其次選擇「最大的一個」，避免碎片化</li>
</ul>
<h2 id="55-區塊鏈賬戶地址如何生成"><a class="header" href="#55-區塊鏈賬戶地址如何生成">5.5 區塊鏈賬戶地址如何生成</a></h2>
<h3 id="551-公鑰加密與數字簽名-p0"><a class="header" href="#551-公鑰加密與數字簽名-p0">5.5.1 公鑰加密與數字簽名 <code>P0</code></a></h3>
<p>常用曲線：<code>secp256k1</code></p>
<p>簽名驗證核心：</p>
<ul>
<li>私鑰簽</li>
<li>公鑰驗</li>
<li>交易內容變動則簽名失效</li>
</ul>
<p><code>secp256k1</code> 是 Bitcoin 和 Ethereum 共同使用的橢圓曲線。它的安全性基於橢圓曲線離散對數問題（ECDLP）：已知公鑰（一個曲線上的點），要反推私鑰（一個標量）在計算上不可行。</p>
<p>數位簽名的數學原理可以簡化理解為：私鑰 <code>k</code> 和待簽資料 <code>m</code> 通過 ECDSA 演算法產生簽名 <code>(r, s)</code>。任何人只要有公鑰 <code>K</code> 和原始資料 <code>m</code>，就能驗證 <code>(r, s)</code> 是否由持有 <code>k</code> 的人產生。整個過程中，私鑰從未被暴露。</p>
<pre><code class="language-go">// 使用 Go 標準庫進行 ECDSA 簽名和驗證
import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"math/big"
)

// 生成金鑰對
func NewKeyPair() (ecdsa.PrivateKey, []byte) {
	curve := elliptic.P256() // 教學用 P256，Bitcoin 用 secp256k1
	privateKey, _ := ecdsa.GenerateKey(curve, rand.Reader)

	// 公鑰 = 曲線上的點 (X, Y)，拼接成 bytes
	pubKey := append(privateKey.PublicKey.X.Bytes(), privateKey.PublicKey.Y.Bytes()...)
	return *privateKey, pubKey
}

// 簽名交易
func (tx *Transaction) Sign(privKey ecdsa.PrivateKey, prevTXs map[string]Transaction) {
	if tx.IsCoinbase() {
		return // CoinBase 不需要簽名
	}

	txCopy := tx.TrimmedCopy() // 去除簽名的副本

	for inIdx, vin := range txCopy.Vin {
		prevTX := prevTXs[hex.EncodeToString(vin.Txid)]
		txCopy.Vin[inIdx].PubKey = prevTX.Vout[vin.Vout].PubKeyHash

		txCopy.CalcHash()
		dataToSign := txCopy.ID

		r, s, _ := ecdsa.Sign(rand.Reader, &amp;privKey, dataToSign)
		signature := append(r.Bytes(), s.Bytes()...)
		tx.Vin[inIdx].Signature = signature

		txCopy.Vin[inIdx].PubKey = nil // 重置，處理下一個輸入
	}
}

// 驗證交易簽名
func (tx *Transaction) Verify(prevTXs map[string]Transaction) bool {
	txCopy := tx.TrimmedCopy()
	curve := elliptic.P256()

	for inIdx, vin := range tx.Vin {
		prevTX := prevTXs[hex.EncodeToString(vin.Txid)]
		txCopy.Vin[inIdx].PubKey = prevTX.Vout[vin.Vout].PubKeyHash

		txCopy.CalcHash()
		dataToVerify := txCopy.ID

		// 解析簽名
		r := big.Int{}
		s := big.Int{}
		sigLen := len(vin.Signature)
		r.SetBytes(vin.Signature[:sigLen/2])
		s.SetBytes(vin.Signature[sigLen/2:])

		// 解析公鑰
		x := big.Int{}
		y := big.Int{}
		keyLen := len(vin.PubKey)
		x.SetBytes(vin.PubKey[:keyLen/2])
		y.SetBytes(vin.PubKey[keyLen/2:])

		rawPubKey := ecdsa.PublicKey{Curve: curve, X: &amp;x, Y: &amp;y}
		if !ecdsa.Verify(&amp;rawPubKey, dataToVerify, &amp;r, &amp;s) {
			return false
		}

		txCopy.Vin[inIdx].PubKey = nil
	}
	return true
}
</code></pre>
<h3 id="552-生成區塊鏈賬戶地址-p0"><a class="header" href="#552-生成區塊鏈賬戶地址-p0">5.5.2 生成區塊鏈賬戶地址 <code>P0</code></a></h3>
<p>流程：</p>
<ol>
<li>生成私鑰</li>
<li>推導公鑰</li>
<li>公鑰 hash</li>
<li>加版本與 checksum</li>
<li>Base58 編碼</li>
</ol>
<p>安全要求：</p>
<ul>
<li>私鑰不落盤明文</li>
<li>助記詞/私鑰分離備份</li>
</ul>
<p>這個流程串聯了前面學到的所有密碼學元件：橢圓曲線產生金鑰對、hash 函數壓縮公鑰、Base58 編碼產生人類可讀地址。每一步都不可逆——從地址無法推導公鑰，從公鑰無法推導私鑰。</p>
<pre><code class="language-go">// 錢包結構
type Wallet struct {
	PrivateKey ecdsa.PrivateKey
	PublicKey  []byte
}

// 建立新錢包
func NewWallet() *Wallet {
	private, public := NewKeyPair()
	return &amp;Wallet{PrivateKey: private, PublicKey: public}
}

// 從公鑰推導地址
func (w *Wallet) GetAddress() []byte {
	// Step 1: SHA256 + RIPEMD160
	pubKeyHash := HashPubKey(w.PublicKey)

	// Step 2: 加版本前綴（0x00 = mainnet）
	versionedPayload := append([]byte{0x00}, pubKeyHash...)

	// Step 3: 計算 checksum
	checksum := Checksum(versionedPayload)

	// Step 4: 拼接並 Base58 編碼
	fullPayload := append(versionedPayload, checksum...)
	address := Base58Encode(fullPayload)

	return address
}

func HashPubKey(pubKey []byte) []byte {
	publicSHA256 := sha256.Sum256(pubKey)

	RIPEMD160Hasher := ripemd160.New()
	_, _ = RIPEMD160Hasher.Write(publicSHA256[:])
	publicRIPEMD160 := RIPEMD160Hasher.Sum(nil)

	return publicRIPEMD160
}
</code></pre>
<pre><code class="language-text">地址生成完整流程圖：

  Private Key (32 bytes, 隨機生成)
       │
       │  橢圓曲線乘法 (不可逆)
       v
  Public Key (65 bytes, uncompressed)
       │
       │  SHA256
       v
  SHA256(PubKey) (32 bytes)
       │
       │  RIPEMD160
       v
  PubKeyHash (20 bytes)
       │
       │  加版本前綴 (0x00)
       v
  Version + PubKeyHash (21 bytes)
       │
       │  雙重 SHA256，取前 4 bytes
       v
  Checksum (4 bytes)
       │
       │  拼接
       v
  Version + PubKeyHash + Checksum (25 bytes)
       │
       │  Base58 編碼
       v
  Bitcoin Address (如: 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa)
</code></pre>
<h2 id="實訓結合區塊鏈賬戶地址發送區塊鏈交易-p0"><a class="header" href="#實訓結合區塊鏈賬戶地址發送區塊鏈交易-p0">實訓：結合區塊鏈賬戶地址，發送區塊鏈交易 <code>P0</code></a></h2>
<p>目標：</p>
<ul>
<li>建立兩個地址 A/B</li>
<li>A 先獲得 coinbase</li>
<li>A 向 B 轉帳並找零</li>
<li>打包出塊後驗證餘額</li>
</ul>
<p>驗收：</p>
<ul>
<li>A/B 餘額符合預期</li>
<li>交易可驗簽</li>
<li>UTXO 集狀態正確更新</li>
</ul>
<p>以下是完整的端到端測試場景：</p>
<pre><code class="language-go">func TestFullFlow(t *testing.T) {
	// 1. 建立錢包
	walletA := NewWallet()
	walletB := NewWallet()
	addrA := string(walletA.GetAddress())
	addrB := string(walletB.GetAddress())

	// 2. 建立區塊鏈（genesis block 獎勵給 A）
	bc := NewBlockchain(addrA)
	defer bc.db.Close()
	utxoSet := UTXOSet{bc}
	utxoSet.Reindex()

	// 3. 驗證 A 的初始餘額
	balA := utxoSet.GetBalance(HashPubKey(walletA.PublicKey))
	assert.Equal(t, 50, balA) // 假設獎勵 50

	// 4. A 向 B 轉帳 30
	tx, err := NewTransaction(addrA, addrB, 30, &amp;utxoSet, wallets)
	assert.NoError(t, err)

	// 5. 打包出塊
	newBlock := bc.MineBlock([]*Transaction{tx})

	// 6. 更新 UTXO 集
	utxoSet.Update(newBlock)

	// 7. 驗證餘額
	balA = utxoSet.GetBalance(HashPubKey(walletA.PublicKey))
	balB := utxoSet.GetBalance(HashPubKey(walletB.PublicKey))

	// A: 50 (coinbase) - 30 (轉帳) = 20 (找零)
	// 加上新區塊的 coinbase 獎勵（如果 A 是礦工）
	assert.Equal(t, 20, balA) // 不含新 coinbase
	assert.Equal(t, 30, balB)

	// 8. 驗證交易簽名
	assert.True(t, tx.Verify(prevTXs))
}
</code></pre>
<pre><code class="language-text">完整流程時序圖：

Time ──────────────────────────────────────────────&gt;

Block 0 (Genesis):              Block 1:
┌──────────────────────┐        ┌──────────────────────┐
│ Coinbase -&gt; A: 50    │        │ Coinbase -&gt; A: 50    │
│                      │        │ A -&gt; B: 30           │
│                      │        │ A -&gt; A: 20 (找零)    │
└──────────────────────┘        └──────────────────────┘

UTXO 集變化：
Block 0 後: {A: [50]}
Block 1 後: {A: [50(新coinbase), 20(找零)], B: [30]}
</code></pre>
<h2 id="章節回顧與工程要點"><a class="header" href="#章節回顧與工程要點">章節回顧與工程要點</a></h2>
<p>本章完成了一條簡化但完整的區塊鏈實作。以下是每個模組的核心工程知識和需要銘記的設計決策：</p>
<p><strong>核心資料結構</strong>：區塊、交易、UTXO 三者的結構定義決定了整條鏈的能力邊界。序列化的穩定性是 hash 一致性的基礎，永遠使用 binary encoding 而非 JSON。區塊 header 與交易資料分離，通過 Merkle Root 連接，這個設計支撐了 SPV 輕節點的可行性。</p>
<p><strong>PoW 出塊與驗證流程</strong>：挖礦的計算成本和驗證的低成本形成了非對稱性，這是 PoW 安全的根本。驗證必須重算 header hash，絕不信任對方聲稱的 hash 值。挖礦過程需要能被中斷（當新區塊到達時），否則會浪費算力。</p>
<p><strong>UTXO 交易與地址生成</strong>：UTXO 模型的核心是「消費舊輸出、產生新輸出」。找零是最容易出錯的環節——忘記產生找零等於把剩餘金額當手續費送給了礦工。地址生成串聯了橢圓曲線、hash 函數、Base58 三個密碼學元件，每一步都不可逆。</p>
<p><strong>DB 持久化與遍歷</strong>：bbolt 的 ACID 事務保證了寫入的原子性。UTXO 集合索引是效能的關鍵——沒有它，每次查餘額都需要遍歷整條鏈。區塊鏈遍歷從最新區塊沿 PrevHash 反向走到 genesis。</p>
<h2 id="白話總結"><a class="header" href="#白話總結">白話總結</a></h2>
<p>這一章就是帶你從零開始造一條能跑的區塊鏈。首先你得把 hash、Base58、Merkle Tree 這些密碼學工具都用 Go 實作出來，這些是區塊鏈的「零件」。然後你把這些零件組裝成區塊和交易的資料結構，用 PoW 讓區塊不能被隨便偽造。UTXO 模型是最燒腦的部分，你得理解「餘額」其實不存在，存在的只是一堆散落的「未花費輸出」。發交易就是選幾個舊的輸出消耗掉，然後產生新的輸出——一定要記得找零，不然剩下的錢就白送給礦工了。最後用 bbolt 把所有資料存到硬碟上。做完這些，你手上就有一條能生成地址、發送交易、挖礦出塊、驗證簽名的完整簡化鏈了。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="go-ch04-basic-dev.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="go-ch06-offline-wallet.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="go-ch04-basic-dev.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="go-ch06-offline-wallet.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
