<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>8. L1/L2/跨鏈與橋接 - 工程師等級 Web3 系統全圖（完整版）</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">工程師等級 Web3 系統全圖（完整版）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="8-l1l2跨鏈與橋接"><a class="header" href="#8-l1l2跨鏈與橋接">8. L1/L2/跨鏈與橋接</a></h1>
<h2 id="81-為什麼需要-l2"><a class="header" href="#81-為什麼需要-l2">8.1 為什麼需要 L2</a></h2>
<p>區塊鏈的「不可能三角」（Blockchain Trilemma）指出，去中心化、安全性和擴展性三者難以同時兼顧。以太坊選擇了去中心化和安全性，犧牲了擴展性——Ethereum Mainnet 目前每秒只能處理約 15-30 筆交易，遠不足以支撐大規模應用。Layer 2（L2）的出現正是為了解決這個瓶頸。</p>
<h3 id="降低交易成本"><a class="header" href="#降低交易成本">降低交易成本</a></h3>
<p>在 Ethereum Mainnet 上執行一筆簡單的 ERC-20 轉帳需要約 65,000 gas，在 gas price 為 30 gwei 時約需 0.002 ETH。而一筆 Uniswap swap 可能需要 150,000-300,000 gas，成本可達數美元甚至數十美元。L2 透過將大量交易打包後壓縮提交到 L1，讓每筆交易分攤的 L1 成本大幅降低。以 Arbitrum 為例，同樣的 swap 操作成本通常只需 L1 的 1/10 到 1/50。</p>
<p>EIP-4844（Proto-Danksharding）的引入進一步降低了 L2 的資料可用性成本。它引入了一種新的交易類型 blob transaction，讓 L2 可以用更便宜的方式將資料發佈到 L1。Blob 資料在 L1 上只會被保存約 18 天（而非永久），對於 L2 來說這已經足夠，因為挑戰期通常只有 7 天。</p>
<h3 id="提高吞吐量"><a class="header" href="#提高吞吐量">提高吞吐量</a></h3>
<p>L2 透過在鏈外執行交易來提高吞吐量。L1 只需要驗證「一批交易的結果是正確的」，而不需要逐筆重新執行。這意味著 L2 的 TPS（Transactions Per Second）主要受限於 sequencer 的處理能力和 L1 的資料可用性頻寬，而非 L1 本身的執行能力。</p>
<p>目前主要的 L2 理論 TPS 上限如下：</p>
<div class="table-wrapper"><table><thead><tr><th>L2</th><th>理論 TPS</th><th>實際觀察 TPS</th><th>限制因素</th></tr></thead><tbody>
<tr><td>Arbitrum One</td><td>~40,000</td><td>數百-數千</td><td>Sequencer 處理能力</td></tr>
<tr><td>Optimism</td><td>~2,000</td><td>數百</td><td>類似</td></tr>
<tr><td>zkSync Era</td><td>~100,000+</td><td>數百-數千</td><td>ZK proof 生成速度</td></tr>
<tr><td>Base</td><td>~2,000</td><td>數百-數千</td><td>共享 OP Stack</td></tr>
</tbody></table>
</div>
<h3 id="把計算外包到-l2把安全錨定在-l1"><a class="header" href="#把計算外包到-l2把安全錨定在-l1">把計算外包到 L2，把安全錨定在 L1</a></h3>
<p>L2 的核心設計哲學是：<strong>L2 負責執行，L1 負責驗證和最終性</strong>。使用者在 L2 上享受高速低費的交易體驗，但所有交易最終都會被提交到 L1 並獲得 L1 等級的安全保障。這就像是在地方法院（L2）處理日常案件，但重大案件可以上訴到最高法院（L1）。</p>
<pre><code class="language-text">L1/L2 安全模型：

┌──────────────────────────────────────────────────────┐
│                    L1 (Ethereum)                       │
│                                                        │
│  ┌───────────────┐  ┌───────────────┐  ┌────────────┐ │
│  │ State Root    │  │ Data Avail.   │  │ Fraud/     │ │
│  │ Commitment    │  │ (calldata /   │  │ Validity   │ │
│  │               │  │  blob)        │  │ Proof      │ │
│  └───────┬───────┘  └───────┬───────┘  └──────┬─────┘ │
│          │                  │                  │       │
│          │     安全性錨定在 L1 的共識機制上       │       │
└──────────┼──────────────────┼──────────────────┼───────┘
           │                  │                  │
           v                  v                  v
┌──────────────────────────────────────────────────────┐
│                    L2 (Rollup)                         │
│                                                        │
│  ┌───────────────┐  ┌───────────────┐                  │
│  │  Sequencer    │  │  Full Node    │                  │
│  │ (排序 &amp; 執行)  │  │ (驗證 &amp; 同步)  │                  │
│  └───────────────┘  └───────────────┘                  │
│                                                        │
│  高吞吐 + 低費用 + L1 級安全保障                          │
└──────────────────────────────────────────────────────┘
</code></pre>
<p><strong>需要注意的風險</strong>：目前大部分 L2 的 sequencer 仍然是中心化的。雖然 sequencer 無法竊取使用者資金（因為 L1 上有強制退出機制），但它可以審查交易、對交易排序以獲取 MEV、或者暫時停止出塊。L2 的去中心化 sequencer 方案仍在積極開發中。</p>
<h2 id="82-rollup-差異"><a class="header" href="#82-rollup-差異">8.2 Rollup 差異</a></h2>
<p>Rollup 是目前最主流的 L2 擴展方案，分為兩大陣營：Optimistic Rollup 和 ZK Rollup。兩者的核心差異在於「如何讓 L1 相信 L2 提交的狀態是正確的」。</p>
<h3 id="optimistic-rollup挑戰期--fraud-proof"><a class="header" href="#optimistic-rollup挑戰期--fraud-proof">Optimistic Rollup：挑戰期 + Fraud Proof</a></h3>
<p>Optimistic Rollup 採用「先信任，後驗證」的策略。Sequencer 將一批交易和執行後的狀態根提交到 L1，預設這些狀態都是正確的（optimistic）。在一段挑戰期（通常 7 天）內，任何人都可以提出 fraud proof 來質疑某個狀態轉換的正確性。</p>
<pre><code class="language-text">Optimistic Rollup 工作流程：

時間線 ──────────────────────────────────────────&gt;

         提交狀態          挑戰期 (7 天)              最終確認
         ┌──┐   ┌─────────────────────────────┐   ┌──────┐
Batch N  │TX│──&gt;│  任何人可提交 fraud proof     │──&gt;│ Final│
         └──┘   │                              │   └──────┘
                │  若無挑戰 → 狀態確認           │
                │  若有挑戰 → 進入仲裁流程        │
                └─────────────────────────────┘

仲裁流程（以 Arbitrum 的 Interactive Fraud Proof 為例）：

挑戰者: "Batch N 的狀態不對！"
         │
         v
    ┌──────────────────────────────────────────┐
    │  二分搜尋 (Bisection Protocol)             │
    │                                            │
    │  Step 1: 將 N 條指令分成兩半               │
    │  Step 2: 雙方同意前半部分是正確的           │
    │  Step 3: 繼續二分後半部分                   │
    │  ...重複直到找到單條有爭議的指令...          │
    │                                            │
    │  Step Final: L1 合約執行該單條指令           │
    │              判定誰是對的                    │
    └──────────────────────────────────────────┘
</code></pre>
<p><strong>Optimistic Rollup 的關鍵特性</strong>：</p>
<ul>
<li><strong>提款延遲</strong>：從 L2 提款到 L1 需要等待整個挑戰期（7 天），這是最大的用戶體驗痛點。第三方流動性橋（如 Hop Protocol、Across）透過預先墊付來解決這個問題，但會收取費用。</li>
<li><strong>EVM 等效性</strong>：Optimistic Rollup 通常能做到 EVM 等效（EVM Equivalence），意味著 L1 上的 Solidity 合約可以幾乎不做修改地部署到 L2。Arbitrum 和 Optimism 都宣稱具有高度的 EVM 相容性。</li>
<li><strong>資料可用性需求</strong>：所有交易資料必須發佈到 L1，確保任何人都能重建 L2 狀態並提出挑戰。</li>
</ul>
<p><strong>代表項目</strong>：Arbitrum One、Optimism（OP Mainnet）、Base（使用 OP Stack）。</p>
<h3 id="zk-rollupvalidity-proof-快速最終性"><a class="header" href="#zk-rollupvalidity-proof-快速最終性">ZK Rollup：Validity Proof 快速最終性</a></h3>
<p>ZK Rollup 採用相反的策略：「先驗證，再信任」。Sequencer 在提交狀態時同時附上一個密碼學證明（validity proof），這個證明可以數學上保證狀態轉換是正確的。L1 合約只需要驗證這個證明（成本很低），而不需要任何挑戰期。</p>
<pre><code class="language-text">ZK Rollup 工作流程：

┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   Sequencer  │────&gt;│  Prover      │────&gt;│  L1 Verifier │
│   收集交易    │     │  生成 ZK     │     │  驗證 proof   │
│   執行狀態    │     │  Proof       │     │  更新狀態     │
└──────────────┘     └──────────────┘     └──────────────┘
     │                     │                     │
     │  毫秒級              │  分鐘~小時級         │  秒級
     │  (交易執行)          │  (proof 生成)        │  (on-chain 驗證)
     v                     v                     v
  使用者感受            後台處理              最終確認
  即時確認             計算密集               無需挑戰期
</code></pre>
<p><strong>ZK Rollup 的關鍵特性</strong>：</p>
<ul>
<li><strong>快速最終性</strong>：一旦 validity proof 在 L1 上被驗證，狀態就是最終確認的。提款不需要等待 7 天，理論上只需等待 proof 生成和驗證的時間（目前約數分鐘到數小時）。</li>
<li><strong>Proof 生成成本</strong>：生成 ZK proof 需要大量計算資源，這是 ZK Rollup 的主要成本瓶頸。專用硬體（FPGA、ASIC）正在開發中以降低成本。</li>
<li><strong>EVM 相容性挑戰</strong>：EVM 的設計並非為 ZK 友善。某些 EVM opcode（如 KECCAK256）在 ZK 電路中成本極高。zkEVM 的實現分為不同等級的相容性，從 Type 1（完全等效）到 Type 4（高級語言相容）。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>zkEVM 類型</th><th>相容性</th><th>代表項目</th><th>說明</th></tr></thead><tbody>
<tr><td>Type 1</td><td>完全等效以太坊</td><td>Taiko</td><td>可直接驗證 Ethereum 區塊</td></tr>
<tr><td>Type 2</td><td>EVM 等效</td><td>Scroll、Polygon zkEVM</td><td>少量差異（如 gas 計量）</td></tr>
<tr><td>Type 2.5</td><td>EVM 等效（部分 gas 不同）</td><td>-</td><td>某些 opcode gas 不同</td></tr>
<tr><td>Type 3</td><td>幾乎 EVM 等效</td><td>-</td><td>移除少數難以 ZK 化的功能</td></tr>
<tr><td>Type 4</td><td>高級語言相容</td><td>zkSync Era</td><td>從 Solidity 編譯為 ZK 友善的 bytecode</td></tr>
</tbody></table>
</div>
<p><strong>代表項目</strong>：zkSync Era、StarkNet（使用 STARK 而非 SNARK）、Scroll、Polygon zkEVM、Linea。</p>
<h3 id="兩者比較總覽"><a class="header" href="#兩者比較總覽">兩者比較總覽</a></h3>
<pre><code class="language-text">                   Optimistic Rollup          ZK Rollup
                   ──────────────────         ──────────────
提款延遲            7 天（挑戰期）              分鐘~小時（等 proof）
鏈上成本            中（發佈 calldata）         高（驗證 proof + calldata）
鏈下成本            低                         高（proof 生成）
EVM 相容性          高（幾乎等效）              中~高（取決於 zkEVM 類型）
安全假設            至少需要 1 個誠實驗證者       數學保證（密碼學假設）
成熟度              高（已上線數年）             中（快速發展中）
</code></pre>
<h2 id="83-跨鏈橋模型"><a class="header" href="#83-跨鏈橋模型">8.3 跨鏈橋模型</a></h2>
<p>跨鏈橋是連接不同區塊鏈的基礎設施，讓資產和訊息能在鏈與鏈之間流動。由於不同的區塊鏈有各自獨立的共識機制和狀態空間，跨鏈橋本質上是在解決「如何讓一條鏈信任另一條鏈上發生的事情」這個問題。</p>
<h3 id="lock--mint"><a class="header" href="#lock--mint">Lock &amp; Mint</a></h3>
<p>最常見的跨鏈模型。使用者在來源鏈上將資產鎖定在橋合約中，橋在目標鏈上鑄造等量的 wrapped token。這些 wrapped token 的價值由鎖定的原始資產背書。</p>
<pre><code class="language-text">Lock &amp; Mint 流程：

Source Chain (Ethereum)              Target Chain (Arbitrum)
┌─────────────────────┐              ┌─────────────────────┐
│                     │              │                     │
│  User: 100 USDC     │              │  User: 0 USDC      │
│         │           │              │                     │
│         v           │              │                     │
│  ┌─────────────┐    │   Relayer    │  ┌─────────────┐    │
│  │ Bridge      │    │ ──────────&gt; │  │ Bridge      │    │
│  │ Contract    │    │   訊息傳遞   │  │ Contract    │    │
│  │             │    │              │  │             │    │
│  │ Lock 100    │    │              │  │ Mint 100    │    │
│  │ USDC        │    │              │  │ wUSDC       │    │
│  └─────────────┘    │              │  └─────────────┘    │
│                     │              │                     │
│  User: 0 USDC       │              │  User: 100 wUSDC   │
│  Bridge: 100 USDC   │              │                     │
└─────────────────────┘              └─────────────────────┘
</code></pre>
<p><strong>特性與風險</strong>：鎖定在來源鏈上的資產構成一個巨大的蜜罐（honeypot），歷史上多個橋的攻擊事件都是針對這個鎖定合約。如果橋被攻破，鑄造出來的 wrapped token 將失去背書價值，形成「空氣幣」。</p>
<h3 id="burn--release"><a class="header" href="#burn--release">Burn &amp; Release</a></h3>
<p>與 Lock &amp; Mint 相反的流程。使用者在目標鏈上銷毀（burn）wrapped token，橋在來源鏈上釋放（release）等量的原始資產。通常作為 Lock &amp; Mint 的回程操作。</p>
<pre><code class="language-text">Burn &amp; Release 流程（回程）：

Target Chain (Arbitrum)              Source Chain (Ethereum)
┌─────────────────────┐              ┌─────────────────────┐
│                     │              │                     │
│  User: 100 wUSDC    │   Relayer    │  Bridge: 100 USDC   │
│         │           │ ──────────&gt; │         │           │
│         v           │              │         v           │
│  ┌─────────────┐    │              │  ┌─────────────┐    │
│  │ Burn 100    │    │              │  │ Release 100 │    │
│  │ wUSDC       │    │              │  │ USDC        │    │
│  └─────────────┘    │              │  └─────────────┘    │
│                     │              │                     │
│  User: 0 wUSDC      │              │  User: 100 USDC    │
└─────────────────────┘              └─────────────────────┘
</code></pre>
<h3 id="light-client-bridge"><a class="header" href="#light-client-bridge">Light-Client Bridge</a></h3>
<p>最安全但也最昂貴的跨鏈方案。在目標鏈上部署來源鏈的 light client（輕節點），直接驗證來源鏈的區塊頭和 Merkle proof。這種方式不需要信任任何中間人，安全性等同於來源鏈本身。</p>
<p><strong>工作原理</strong>：目標鏈上的 light client 合約持續追蹤來源鏈的驗證者集合和區塊頭。當有跨鏈訊息要驗證時，只需提交 Merkle proof 即可在 light client 中驗證該事件是否真的在來源鏈上發生過。</p>
<pre><code class="language-text">Light-Client Bridge 驗證流程：

Source Chain                                Target Chain
┌────────────────────┐                     ┌────────────────────┐
│                    │                     │                    │
│  Block N           │   Block Header      │  Light Client      │
│  ├── Header ───────│─────────────────────&gt;│  Contract          │
│  ├── Tx Root       │                     │  ├── Headers[]     │
│  │   ├── Tx 1      │   Merkle Proof       │  ├── Validator Set│
│  │   ├── Tx 2 ─────│─────────────────────&gt;│  │                │
│  │   └── ...       │                     │  │  verify(        │
│  └── State Root    │                     │  │    blockHeader,  │
│                    │                     │  │    merkleProof,   │
│                    │                     │  │    txData         │
│                    │                     │  │  ) → true/false  │
└────────────────────┘                     └────────────────────┘
</code></pre>
<p><strong>優點</strong>：最高等級的安全性，無需信任第三方。IBC（Inter-Blockchain Communication，Cosmos 生態的跨鏈協議）就是基於 light client 的設計。</p>
<p><strong>缺點</strong>：在 EVM 上部署和維護 light client 的 gas 成本極高，特別是對於使用 PoS 的區塊鏈（需要驗證大量簽名）。ZK 技術正在被用來壓縮 light client 的驗證成本——例如 Succinct Labs 的方案可以用 ZK proof 來證明「一組驗證者確實簽署了某個區塊頭」，將鏈上驗證成本從數百萬 gas 降低到約 30 萬 gas。</p>
<h3 id="external-validator-bridge"><a class="header" href="#external-validator-bridge">External Validator Bridge</a></h3>
<p>使用一組外部驗證者（通常是 multisig 或 MPC 節點集合）來見證跨鏈訊息。當來源鏈上的事件被足夠數量的驗證者確認後，目標鏈上就執行相應操作。</p>
<pre><code class="language-text">External Validator Bridge：

Source Chain          Validator Set (M-of-N)         Target Chain
┌──────────┐        ┌─────────────────────┐        ┌──────────┐
│          │        │  Validator 1  ✓     │        │          │
│  Event   │───────&gt;│  Validator 2  ✓     │───────&gt;│  Execute │
│  Emit    │        │  Validator 3  ✗     │        │  Action  │
│          │        │  Validator 4  ✓     │        │          │
│          │        │  (3-of-4 threshold) │        │          │
└──────────┘        └─────────────────────┘        └──────────┘
</code></pre>
<p><strong>優點</strong>：實作簡單、成本低、速度快（不需要等待區塊確認）。</p>
<p><strong>缺點</strong>：安全性完全取決於驗證者集合。如果超過門檻數量的驗證者被攻破或串謀，橋就會被完全攻破。歷史上最大的幾起橋接攻擊（Ronin Bridge 6.24 億美元、Wormhole 3.2 億美元）都是因為外部驗證者被攻破。</p>
<p><strong>改進方向</strong>：使用 TEE（Trusted Execution Environment）來保護驗證者的私鑰、增加驗證者數量並引入 slashing 機制、結合 light client 驗證作為額外安全層。</p>
<h2 id="84-跨鏈風險"><a class="header" href="#84-跨鏈風險">8.4 跨鏈風險</a></h2>
<p>跨鏈橋是區塊鏈生態中被攻擊最頻繁、損失最慘重的領域。根據統計，2021-2023 年間跨鏈橋攻擊造成的總損失超過 25 億美元。理解這些風險對於選擇和使用跨鏈橋至關重要。</p>
<h3 id="驗證者集中"><a class="header" href="#驗證者集中">驗證者集中</a></h3>
<p>當跨鏈橋依賴一小組驗證者時，攻擊面集中在這些驗證者的私鑰安全性上。攻擊者只需攻破足夠數量的驗證者（通常是 M-of-N 門檻中的 M 個），就能完全控制橋。</p>
<p><strong>案例分析——Ronin Bridge（2022 年 3 月）</strong>：Axie Infinity 的 Ronin Bridge 使用 9 個驗證者的 5-of-9 multisig。攻擊者（後證實為北韓 Lazarus Group）透過社會工程攻擊取得了 5 個驗證者的私鑰，偽造了 17.36 萬 ETH 和 2,550 萬 USDC 的提款，總計約 6.24 億美元。更糟糕的是，攻擊發生後 6 天才被發現。</p>
<p><strong>防禦措施</strong>：增加驗證者數量（至少 20 個以上）、使用 MPC（Multi-Party Computation）取代 multisig（私鑰碎片化，沒有人持有完整私鑰）、定期輪換驗證者、監控異常簽名活動。</p>
<h3 id="訊息重放"><a class="header" href="#訊息重放">訊息重放</a></h3>
<p>跨鏈訊息如果缺乏唯一標識符（nonce 或 message ID），攻擊者可以將同一筆跨鏈訊息重複提交，造成重複鑄幣或重複提款。</p>
<pre><code class="language-text">訊息重放攻擊示意：

正常流程：
  Source: Lock(100 USDC, nonce=1) → Target: Mint(100 USDC, nonce=1) ✓

重放攻擊（無 nonce 保護）：
  攻擊者重複提交同一筆訊息：
  Target: Mint(100 USDC) ✓  ← 第一次
  Target: Mint(100 USDC) ✓  ← 第二次（重放！）
  Target: Mint(100 USDC) ✓  ← 第三次（重放！）

防禦：
  Target 合約維護 processedNonces mapping
  Mint(100 USDC, nonce=1) ✓  ← 第一次
  Mint(100 USDC, nonce=1) ✗  ← "nonce already processed"
</code></pre>
<p><strong>防禦措施</strong>：每筆跨鏈訊息必須包含唯一 nonce，目標鏈合約記錄已處理的 nonce 並拒絕重複處理。使用 message hash 作為唯一標識符是更通用的做法。</p>
<h3 id="錯誤最終性假設"><a class="header" href="#錯誤最終性假設">錯誤最終性假設</a></h3>
<p>不同區塊鏈有不同的最終性語義。如果橋對來源鏈的最終性做了過於激進的假設，可能在來源鏈發生 reorg（區塊重組）時導致資金問題。</p>
<p><strong>問題場景</strong>：假設橋在來源鏈上看到 1 個區塊確認就認為交易最終確認，並在目標鏈上鑄幣。如果來源鏈隨後發生 reorg，該交易被回滾，但目標鏈上的鑄幣已經完成且無法回滾——結果是 wrapped token 沒有對應的鎖定資產。</p>
<p><strong>不同鏈的最終性特徵</strong>：</p>
<div class="table-wrapper"><table><thead><tr><th>區塊鏈</th><th>最終性類型</th><th>建議等待確認數</th><th>大約時間</th></tr></thead><tbody>
<tr><td>Ethereum（PoS）</td><td>經濟最終性（2 epoch）</td><td>64 blocks</td><td>~13 分鐘</td></tr>
<tr><td>Bitcoin</td><td>概率性最終性</td><td>6 blocks</td><td>~60 分鐘</td></tr>
<tr><td>Solana</td><td>樂觀確認 / 最終確認</td><td>32 slots（最終）</td><td>~13 秒</td></tr>
<tr><td>Polygon PoS</td><td>依賴 checkpoint 到 ETH</td><td>256 blocks</td><td>~10 分鐘</td></tr>
</tbody></table>
</div>
<p><strong>防禦措施</strong>：根據轉帳金額動態調整等待確認數。小額交易可以接受較少確認，大額交易必須等待經濟最終性。設定金額閾值，超過閾值的交易需要額外人工審核。</p>
<h3 id="升級權限過大"><a class="header" href="#升級權限過大">升級權限過大</a></h3>
<p>許多橋合約使用可升級的 Proxy 模式，如果升級權限被單一 EOA 或少數人的 multisig 控制，攻擊者只需攻破升級權限就能替換整個合約邏輯。</p>
<p><strong>案例分析——Wormhole（2022 年 2 月）</strong>：攻擊者利用 Solana 上 Wormhole 合約的一個漏洞，繞過了簽名驗證，偽造了 guardian 的確認訊息，鑄造了 12 萬 wETH（約 3.2 億美元）。雖然這不是直接的升級權限問題，但它展示了合約邏輯漏洞的毀滅性影響。</p>
<p><strong>防禦措施</strong>：</p>
<ul>
<li>升級必須經過 Timelock（至少 48 小時延遲）</li>
<li>升級需要多簽核准（門檻至少 2/3 以上）</li>
<li>設定升級冷卻期，避免連續快速升級</li>
<li>升級前必須通過完整的審計流程</li>
</ul>
<h2 id="85-訊息流"><a class="header" href="#85-訊息流">8.5 訊息流</a></h2>
<p>跨鏈訊息傳遞是橋接的核心機制。一筆完整的跨鏈操作涉及多個步驟和多個參與者的協作。以下是一個典型的跨鏈訊息流的詳細分解：</p>
<pre><code class="language-text">完整跨鏈訊息流：

Chain A                    Relayer Layer                    Chain B
┌──────────────┐          ┌──────────────┐          ┌──────────────┐
│              │          │              │          │              │
│ 1. User 發起 │          │              │          │              │
│    跨鏈交易   │          │              │          │              │
│      │       │          │              │          │              │
│      v       │          │              │          │              │
│ 2. Bridge    │  ─────&gt;  │ 3. Relayer   │  ─────&gt;  │ 5. Verifier  │
│    Contract  │  Event   │    監聽事件   │  Submit  │    Contract  │
│    emit      │  Log     │    收集證明   │  Proof   │    驗證證明   │
│    CrossChain│          │              │          │      │       │
│    Event     │          │ 4. 等待足夠   │          │      v       │
│              │          │    區塊確認   │          │ 6. Execute   │
│              │          │              │          │    目標操作   │
│              │          │              │          │      │       │
│              │          │              │          │      v       │
│ 9. 更新狀態   │  &lt;─────  │ 8. Relayer   │  &lt;─────  │ 7. Emit     │
│    (optional)│  ACK     │    回傳確認   │  Event   │    完成事件   │
│              │          │              │          │              │
└──────────────┘          └──────────────┘          └──────────────┘

時間線：
|-- 交易確認 --|-- 等待最終性 --|-- 證明傳遞 --|-- 驗證 &amp; 執行 --|
     秒級          分鐘~小時         秒級           秒級
</code></pre>
<h3 id="訊息編碼格式"><a class="header" href="#訊息編碼格式">訊息編碼格式</a></h3>
<p>跨鏈訊息通常包含以下標準欄位：</p>
<pre><code class="language-solidity">struct CrossChainMessage {
    uint256 nonce;          // 唯一序號，防止重放
    uint256 srcChainId;     // 來源鏈 ID
    uint256 dstChainId;     // 目標鏈 ID
    address sender;         // 來源鏈發送者
    address receiver;       // 目標鏈接收者
    bytes payload;          // 執行資料（calldata）
    uint256 gasLimit;       // 目標鏈執行 gas 上限
    uint256 fee;            // 跨鏈費用
}
</code></pre>
<h3 id="失敗處理"><a class="header" href="#失敗處理">失敗處理</a></h3>
<p>跨鏈操作的失敗處理尤其重要，因為涉及兩條獨立的鏈。如果目標鏈上的操作失敗，來源鏈上鎖定的資產必須有退款機制。</p>
<pre><code class="language-text">失敗處理流程：

正常流程：
  Chain A: Lock → Chain B: Execute Success → 完成

失敗流程 1（目標鏈執行失敗）：
  Chain A: Lock → Chain B: Execute Fail → Relayer 回報 → Chain A: Refund

失敗流程 2（Relayer 離線）：
  Chain A: Lock → [timeout] → Chain A: User 手動退款（需等待超時期）

失敗流程 3（目標鏈 gas 不足）：
  Chain A: Lock → Chain B: Out of Gas → 訊息待重試 → User 補 gas → 重試
</code></pre>
<p><strong>工程建議</strong>：永遠為跨鏈操作設定超時機制。如果目標鏈在超時時間內沒有確認，來源鏈上的資金應可被退還。建議超時時間設為正常操作時間的 5-10 倍。</p>
<h2 id="86-防禦準則"><a class="header" href="#86-防禦準則">8.6 防禦準則</a></h2>
<p>設計和使用跨鏈橋時，以下防禦準則應被視為最低安全標準：</p>
<h3 id="大額跨鏈用分批與速率限制"><a class="header" href="#大額跨鏈用分批與速率限制">大額跨鏈用分批與速率限制</a></h3>
<p>單筆跨鏈操作不應超過橋的總鎖定量的某個百分比（建議不超過 5-10%）。對於大額轉帳，應自動拆分為多筆交易，並在每批之間設定冷卻期。</p>
<pre><code class="language-text">速率限制策略範例：

┌──────────────────────────────────────────────────┐
│                Rate Limiter                        │
│                                                    │
│  規則 1: 單筆上限 = min(TVL * 5%, $10M)            │
│  規則 2: 每小時累計上限 = TVL * 10%                 │
│  規則 3: 每日累計上限 = TVL * 30%                   │
│  規則 4: 超過單筆 $1M 需要額外確認延遲（2 小時）     │
│                                                    │
│  觸發任一規則 → 交易進入排隊 / 人工審核              │
└──────────────────────────────────────────────────┘
</code></pre>
<p><strong>真實案例</strong>：2024 年 Orbiter Finance 和多個橋接協議開始引入動態速率限制，根據近期的橋接活動量自動調整閾值。這種「熔斷器」機制類似傳統金融中的 circuit breaker。</p>
<h3 id="橋接白名單與路由選擇策略"><a class="header" href="#橋接白名單與路由選擇策略">橋接白名單與路由選擇策略</a></h3>
<p>不是所有橋都適合所有場景。工程團隊應建立橋接白名單和路由選擇策略：</p>
<p><strong>評估維度</strong>：</p>
<ul>
<li><strong>安全模型</strong>：Light client &gt; ZK proof &gt; Optimistic with fraud proof &gt; External validator</li>
<li><strong>流動性深度</strong>：橋上的可用流動性是否足以支持預期的轉帳量</li>
<li><strong>歷史紀錄</strong>：該橋是否有過安全事件？事件後的應對和改進措施如何？</li>
<li><strong>審計狀況</strong>：是否有多家獨立審計機構的報告？最近一次審計是什麼時候？</li>
<li><strong>去中心化程度</strong>：升級權限由誰控制？是否有 Timelock？</li>
</ul>
<pre><code class="language-text">路由選擇決策樹：

                    ┌─────────────────┐
                    │  跨鏈需求發生     │
                    └────────┬────────┘
                             │
                    ┌────────v────────┐
                    │ 金額 &gt; $100K ?   │
                    └───┬─────────┬───┘
                   Yes  │         │  No
                        v         v
              ┌──────────────┐  ┌──────────────┐
              │ 使用原生橋    │  │ 使用第三方    │
              │ (L1&lt;-&gt;L2)    │  │ 快速橋       │
              │ 或 Light     │  │ (Across,     │
              │ Client 橋    │  │  Stargate)    │
              └──────────────┘  └──────────────┘
</code></pre>
<h3 id="目的鏈最終性達標才入帳"><a class="header" href="#目的鏈最終性達標才入帳">目的鏈最終性達標才入帳</a></h3>
<p>在目標鏈執行跨鏈操作前，必須等待來源鏈上的交易達到經濟最終性。對於 Optimistic Rollup 的 L2→L1 提款，這意味著等待 7 天的挑戰期。對於 ZK Rollup，則等待 validity proof 在 L1 上被驗證。</p>
<p><strong>實作建議</strong>：建立一個 finality oracle 服務，根據不同鏈的特性自動計算所需的確認數。將最終性確認邏輯放在橋的 relayer 端，而非合約端——因為最終性規則可能需要根據網路狀況動態調整。</p>
<pre><code class="language-solidity">// 虛擬碼：動態最終性確認
function getRequiredConfirmations(
    uint256 chainId,
    uint256 amount
) public view returns (uint256) {
    uint256 baseConfirmations = chainConfirmations[chainId];

    // 大額交易需要更多確認
    if (amount &gt; HIGH_VALUE_THRESHOLD) {
        return baseConfirmations * 2;
    }

    return baseConfirmations;
}
</code></pre>
<h3 id="其他防禦建議"><a class="header" href="#其他防禦建議">其他防禦建議</a></h3>
<ul>
<li><strong>多橋驗證</strong>：對於高價值操作，可以同時透過兩個獨立的橋傳遞訊息，只有兩個橋都確認才執行。這增加了成本和延遲，但大幅提高了安全性。</li>
<li><strong>橋監控與告警</strong>：部署即時監控系統，追蹤橋的 TVL 變化、異常大額轉帳、驗證者行為異常等指標。設定告警閾值，在異常發生時第一時間通知團隊。</li>
<li><strong>緊急暫停機制</strong>：橋合約必須具備 <code>pause()</code> 功能，並且暫停操作的門檻應低於正常操作門檻。建議設定自動暫停觸發條件，例如「單一小時內跨鏈金額超過 TVL 的 25%」自動暫停。</li>
<li><strong>保險與風險對沖</strong>：對於管理大量用戶資金的協議，考慮透過 Nexus Mutual 等鏈上保險協議為跨鏈風險投保。</li>
</ul>
<h2 id="白話總結"><a class="header" href="#白話總結">白話總結</a></h2>
<p>跨鏈橋可以想像成國際銀行之間的匯款系統。你在台灣的銀行（Chain A）匯錢到美國的銀行（Chain B），台灣的銀行會凍結你的存款，然後通知美國的銀行給收款人等額的美金。問題在於：兩家銀行怎麼信任彼此的通知？</p>
<p>最安全的方式是兩家銀行各自派人到對方銀行駐點查帳（Light Client Bridge），但這成本很高。比較便宜的方式是找一群公證人來見證（External Validator Bridge），但如果公證人被收買就完了。還有一種方式是先匯款後讓對方有時間檢查是否有問題（Optimistic Rollup），或者附上一份數學證明讓對方一看就知道匯款是真的（ZK Rollup）。</p>
<p>L2 的存在是因為以太坊主鏈就像一條繁忙的高速公路，車太多就會塞車（gas 費飆高）。L2 就像是在旁邊蓋了快速道路，把大部分的車引導到那裡，只有收費站（結算）還在主幹道上。Optimistic Rollup 像是「先放行，出問題再罰款」，ZK Rollup 像是「每台車都要先出示通行證才能上路」。</p>
<p>跨鏈橋是目前區塊鏈生態中最危險的環節之一。歷史上的攻擊事件已經造成超過 25 億美元的損失。防禦的核心思想是：不信任任何單一組件，用多層防禦來降低風險。速率限制、分批處理、等待最終性確認、以及緊急暫停機制，都是工程團隊必須內建的安全措施。</p>
<p>選擇跨鏈橋時，安全性永遠比速度和成本重要。大額資金應使用原生橋或 light client 橋，只有小額快速轉帳才考慮使用信任假設較弱的第三方橋。記住：你的資產的安全性取決於橋的最弱環節。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="07-smart-contract-runtime.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="09-defi-primitives.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="07-smart-contract-runtime.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="09-defi-primitives.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
