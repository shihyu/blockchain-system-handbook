<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>工程師等級 Web3 系統全圖（完整版）</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">工程師等級 Web3 系統全圖（完整版）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="工程師等級-web3-系統全圖完整版"><a class="header" href="#工程師等級-web3-系統全圖完整版">工程師等級 Web3 系統全圖（完整版）</a></h1>
<p>這本書把 Web3 當成「可程式化金融 + 分散式系統 + 密碼學安全」的組合工程。</p>
<h2 id="你會得到什麼"><a class="header" href="#你會得到什麼">你會得到什麼</a></h2>
<ul>
<li>從節點到應用層的全鏈路模型</li>
<li>可落地的架構模板</li>
<li>多簽與治理的實作級細節</li>
<li>事故與攻擊面導向的防禦策略</li>
</ul>
<h2 id="建議閱讀順序"><a class="header" href="#建議閱讀順序">建議閱讀順序</a></h2>
<ol>
<li>先看 <code>1~4</code> 章建立系統心智模型</li>
<li>再看 <code>5~10</code> 章理解錢包、交易、合約、跨鏈、多簽</li>
<li>最後用 <code>11~14</code> 章做安全與上線檢查</li>
</ol>
<h2 id="全局架構圖"><a class="header" href="#全局架構圖">全局架構圖</a></h2>
<pre><code class="language-text">使用者/機構
   |
   v
前端/後端/API Gateway
   |
   +--&gt; 錢包與簽名系統 (EOA/AA/MPC/Multisig)
   |
   +--&gt; 風控與策略引擎 (額度/白名單/時鎖/監控)
   |
   v
RPC/節點層 (自建節點 + 第三方 RPC)
   |
   +--&gt; L1 (安全錨)
   +--&gt; L2 (擴容執行)
   +--&gt; 跨鏈橋/訊息層
   |
   v
合約層 (Vault / Router / Treasury / Gov)
   |
   v
索引層與資料層 (Indexer / Warehouse / SIEM)
</code></pre>
<h2 id="白話說明"><a class="header" href="#白話說明">白話說明</a></h2>
<p>你可以把整個 Web3 系統想成：</p>
<ul>
<li>錢包是你的「簽章器」。</li>
<li>鏈是「共享資料庫 + 可驗證計算機」。</li>
<li>合約是「公開可執行程式」。</li>
<li>多簽與治理是「公司內控流程上鏈」。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-系統全圖與分層"><a class="header" href="#1-系統全圖與分層">1. 系統全圖與分層</a></h1>
<h2 id="11-分層模型"><a class="header" href="#11-分層模型">1.1 分層模型</a></h2>
<p>區塊鏈系統的分層架構，與傳統網路的 OSI 七層模型有著異曲同工之妙。每一層都有明確的職責邊界，上層依賴下層提供的抽象，下層則不需要知道上層的業務邏輯。這種分層思維對於工程師而言至關重要——當系統出問題時，你可以快速定位問題發生在哪一層，而不是在整個技術堆疊中大海撈針。</p>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────────┐
│ L7 產品層: App / Portal / Mobile / Bot                         │
├─────────────────────────────────────────────────────────────────┤
│ L6 服務層: API, AuthN/AuthZ, Risk Engine, Policy Engine        │
├─────────────────────────────────────────────────────────────────┤
│ L5 交易層: Tx Builder, Simulation, Bundler, Relayer            │
├─────────────────────────────────────────────────────────────────┤
│ L4 簽名層: EOA, Smart Account(AA), MPC, Multisig               │
├─────────────────────────────────────────────────────────────────┤
│ L3 鏈互動層: RPC, Node Cluster, Sequencer, Mempool             │
├─────────────────────────────────────────────────────────────────┤
│ L2 協議層: L1/L2 VM, Consensus, DA, Bridge, Oracle             │
├─────────────────────────────────────────────────────────────────┤
│ L1 密碼學層: Hash, Merkle, Signatures, ZK/Commitment           │
└─────────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="l7-產品層"><a class="header" href="#l7-產品層">L7 產品層</a></h3>
<p>產品層是使用者直接接觸的介面。這裡包含了 Web 前端（React/Vue）、行動端 App（iOS/Android）、Telegram Bot、Discord Bot 等各種載體。從工程角度來看，產品層最重要的設計考量是「狀態同步」——鏈上狀態和前端顯示之間必然存在延遲，你必須設計良好的 loading/pending/confirmed 狀態機，避免使用者看到過期資料後做出錯誤操作。</p>
<p>常見的反模式是前端直接依賴單一 RPC 節點取得餘額，然後在交易送出後立刻刷新頁面期待看到最新狀態。實務上應該採用樂觀更新（Optimistic Update）搭配後端事件確認的雙軌策略。</p>
<h3 id="l6-服務層"><a class="header" href="#l6-服務層">L6 服務層</a></h3>
<p>服務層是後端 API 閘道、身份驗證（AuthN）、權限控制（AuthZ）、風控引擎和策略引擎的集合。在 CeFi/半去中心化的系統中，這一層往往是最厚的一層。風控引擎需要即時判斷交易是否異常（例如：同一地址在 10 分鐘內連續發起 50 筆大額提現），策略引擎則負責執行業務規則（例如：單日提現上限、白名單地址才可轉帳）。</p>
<pre><code class="language-text">                    ┌──────────────────────┐
 使用者請求 ──────&gt;│    API Gateway       │
                    │  (Rate Limit, Auth)  │
                    └──────┬───────────────┘
                           │
              ┌────────────┼────────────────┐
              ▼            ▼                ▼
        ┌──────────┐ ┌──────────┐    ┌──────────┐
        │ AuthN/   │ │  Risk    │    │ Policy   │
        │ AuthZ    │ │  Engine  │    │ Engine   │
        └──────────┘ └──────────┘    └──────────┘
              │            │                │
              └────────────┼────────────────┘
                           ▼
                    ┌──────────────┐
                    │  Tx Builder  │ (L5)
                    └──────────────┘
</code></pre>
<h3 id="l5-交易層"><a class="header" href="#l5-交易層">L5 交易層</a></h3>
<p>交易層負責組裝鏈上交易。Tx Builder 根據業務意圖構建交易內容（呼叫哪個合約、傳入什麼參數、gas 設多少），Simulation 模組在實際送出前先用 <code>eth_call</code> 或類似機制模擬執行結果，確認不會失敗。Bundler 是 ERC-4337 Account Abstraction 架構中的關鍵角色，負責打包 UserOperation。Relayer 則是代付 gas 的中繼服務，讓使用者不需要持有原生代幣就能發起交易。</p>
<p>在高頻場景下，Tx Builder 需要處理 nonce 管理的難題。如果同時有 100 筆交易要送出，你不能讓它們搶同一個 nonce，必須建立 nonce pool 或 nonce manager 來確保每筆交易拿到唯一的遞增 nonce。</p>
<pre><code class="language-text">交易組裝流程:

  業務意圖 ──&gt; Tx Builder ──&gt; Simulation ──&gt; 簽名(L4) ──&gt; 廣播(L3)
                  │               │
                  │          失敗? 中止並回報
                  │
                  ├── 估算 Gas Price / Priority Fee
                  ├── 查詢 Nonce (Nonce Manager)
                  └── 編碼 Calldata (ABI Encoding)
</code></pre>
<h3 id="l4-簽名層"><a class="header" href="#l4-簽名層">L4 簽名層</a></h3>
<p>簽名層是區塊鏈系統中最敏感的一層，因為「控制私鑰就等於控制資產」。EOA（Externally Owned Account）是最基本的形態，一把私鑰對應一個地址。Smart Account（智能帳戶，也稱 Account Abstraction）將帳戶邏輯上鏈，可以實現社交恢復、多簽審批、gas 代付等功能。MPC（Multi-Party Computation）將私鑰分片，分散到多個節點，簽名時各節點各自用自己的分片參與計算，永遠不會在任何單點重組完整私鑰。Multisig 則是在合約層面實現 M-of-N 簽名，典型的如 Gnosis Safe。</p>
<p>實務上，企業級系統通常採用 MPC + 硬體安全模組（HSM）的組合。MPC 負責分散風險，HSM 負責保護個別分片的安全。冷熱錢包分離也是標準做法：熱錢包處理日常小額交易，冷錢包僅在大額結算時啟用。</p>
<h3 id="l3-鏈互動層"><a class="header" href="#l3-鏈互動層">L3 鏈互動層</a></h3>
<p>這一層是鏈下系統和鏈上世界的接口。RPC（Remote Procedure Call）是最常見的互動方式，透過 JSON-RPC 呼叫節點 API 來查詢狀態或送出交易。Node Cluster 是指自建或託管的多個全節點集群，提供負載均衡和故障轉移能力。Sequencer 是 Rollup L2 的排序器，決定交易在 L2 上的執行順序。Mempool 是交易送出後、被打包前的等候區。</p>
<p>RPC 層的穩定性直接影響整個系統的可用性。生產環境中，不應該只依賴單一 RPC 供應商（如 Alchemy 或 Infura），而應該建立 RPC fallback 機制：主節點不回應時自動切換到備援節點，並對回傳結果做交叉比對。</p>
<h3 id="l2-協議層"><a class="header" href="#l2-協議層">L2 協議層</a></h3>
<p>協議層是區塊鏈本體的核心。L1/L2 VM（虛擬機）執行智能合約；Consensus（共識機制）確保所有節點對狀態達成一致；DA（Data Availability，資料可用性）確保交易資料可被任何人取得和驗證；Bridge（跨鏈橋）連接不同區塊鏈；Oracle（預言機）將鏈外資料引入鏈上。</p>
<p>這一層的設計決定了區塊鏈的基本性質——安全性、去中心化程度和吞吐量。作為應用開發者，你不需要修改這一層，但必須深刻理解它的限制（例如：Ethereum 的 12 秒出塊時間、Solana 的 400ms slot 時間）才能做出正確的架構決策。</p>
<h3 id="l1-密碼學層"><a class="header" href="#l1-密碼學層">L1 密碼學層</a></h3>
<p>密碼學層是整個系統的數學根基。Hash 函數（SHA-256、Keccak-256）提供抗碰撞的指紋功能；Merkle Tree 允許高效驗證大量資料中的某個元素是否存在；數位簽名（ECDSA、EdDSA、BLS）確保交易的不可偽造性；ZK Proof（零知識證明）和 Commitment Scheme 則是最前沿的密碼學工具，允許在不揭露資料的情況下證明某個命題為真。</p>
<pre><code class="language-text">密碼學原語與上層功能對應:

  Hash (SHA-256, Keccak)  ────&gt; 區塊鏈接、地址生成、資料完整性
  Merkle Tree             ────&gt; 狀態根、交易根、SPV 輕客戶端驗證
  Digital Signature       ────&gt; 交易授權、身份認證
  ZK Proof                ────&gt; Rollup 驗證、隱私交易、身份證明
  Commitment Scheme       ────&gt; 預防搶跑（front-running）、隱藏出價
</code></pre>
<h2 id="12-信任邊界"><a class="header" href="#12-信任邊界">1.2 信任邊界</a></h2>
<p>信任邊界（Trust Boundary）是安全分析中最核心的概念之一。每當資料或控制權從一個信任域穿越到另一個信任域，就是潛在的攻擊面。區塊鏈系統的特殊之處在於，它橫跨了多個完全不同的信任域——從使用者的手機到去中心化的全球節點網路。</p>
<pre><code class="language-text">信任邊界示意圖:

  ┌────────────────────────────────────────────────────────────────┐
  │  使用者裝置 (Browser / Mobile)                                 │
  │  ┌──────────────┐                                              │
  │  │  私鑰 / 助記詞 │  &lt;── 邊界 A: 最敏感，一旦洩漏無法挽回      │
  │  └──────────────┘                                              │
  └──────────────────────┬─────────────────────────────────────────┘
                         │ HTTPS / WebSocket
  ┌──────────────────────▼─────────────────────────────────────────┐
  │  應用後端 (API Server / Signing Service)                        │
  │  ┌──────────────┐  ┌──────────────┐                            │
  │  │  HSM / MPC   │  │  業務邏輯    │  &lt;── 邊界 B: 後端被攻破    │
  │  └──────────────┘  └──────────────┘      可能導致未授權簽名     │
  └──────────────────────┬─────────────────────────────────────────┘
                         │ JSON-RPC
  ┌──────────────────────▼─────────────────────────────────────────┐
  │  RPC Provider / 節點集群                                        │
  │  &lt;── 邊界 C: RPC 回傳的資料可能被篡改或延遲                     │
  └──────────────────────┬─────────────────────────────────────────┘
                         │
  ┌──────────────────────▼─────────────────────────────────────────┐
  │  鏈上世界 (L1 / L2 / Bridge)                                    │
  │  &lt;── 邊界 D: 跨鏈橋的驗證者集合可能被攻破                       │
  └────────────────────────────────────────────────────────────────┘
</code></pre>
<ul>
<li>
<p><strong>邊界 A: 客戶端裝置與錢包私鑰</strong> — 這是整個系統中最脆弱的環節。使用者的裝置可能被植入惡意軟體、助記詞可能被截圖、剪貼簿可能被監聽。工程上的對策包括：不在前端存儲明文私鑰、使用硬體錢包簽名、對敏感操作增加二次確認。2022 年 Slope 錢包事件中，助記詞被日誌系統明文記錄並上傳到伺服器，導致數千個錢包被盜，就是邊界 A 失守的典型案例。</p>
</li>
<li>
<p><strong>邊界 B: 應用後端與簽名服務</strong> — 當系統使用託管式錢包（Custodial Wallet）或半託管架構時，後端伺服器持有簽名能力。如果後端被入侵（SQL Injection、RCE、內部人員作弊），攻擊者可以直接簽署並送出惡意交易。防禦策略包括：將簽名服務隔離到獨立的安全區域（Enclave）、所有簽名請求必須經過策略引擎審批、對大額交易實施時間鎖（Timelock）。</p>
</li>
<li>
<p><strong>邊界 C: RPC 提供者與鏈上真實狀態</strong> — RPC 節點是你觀察鏈上世界的「眼睛」。如果 RPC 供應商被攻擊或返回不正確的資料，你的系統就會基於錯誤的鏈上狀態做出決策。例如，RPC 可能回傳一個尚未真正被確認的交易狀態，導致你提前放行提現。對策包括：多 RPC 交叉驗證、自建全節點、用 Block Hash 做 anchoring 確認資料一致性。</p>
</li>
<li>
<p><strong>邊界 D: 跨鏈橋外部驗證集合</strong> — 跨鏈橋是區塊鏈生態中最常被攻擊的元件。Wormhole（3.2 億美元）、Ronin Bridge（6.25 億美元）、Nomad（1.9 億美元）等事件反覆證明這一點。橋的安全取決於其驗證機制：多簽橋依賴驗證者的誠實、輕客戶端橋依賴密碼學證明、樂觀橋依賴挑戰期內的欺詐證明。每種設計都有不同的攻擊面和信任假設。</p>
</li>
</ul>
<h2 id="13-關鍵風險對應"><a class="header" href="#13-關鍵風險對應">1.3 關鍵風險對應</a></h2>
<p>風險管理是區塊鏈系統工程的核心能力。與傳統系統不同的是，區塊鏈上的錯誤通常是不可逆的——一旦資產被轉走，沒有「系統管理員」可以回退交易。因此，防禦性設計必須從第一天就內建到架構中。</p>
<h3 id="單點私鑰風險"><a class="header" href="#單點私鑰風險">單點私鑰風險</a></h3>
<p><strong>風險描述：</strong> 當一把私鑰直接控制大量資產時，該私鑰的洩漏或丟失等同於全部資產的損失。這是區塊鏈系統中最致命的單點故障。</p>
<p><strong>對策：使用 MPC 或 Multisig + 硬體隔離。</strong> MPC（多方計算）將私鑰分為 N 個分片，分散到不同的地理位置和管理者手中，簽名時只需要 T 個分片參與（T &lt; N），任何單一分片都無法獨立完成簽名。Multisig（多重簽名）在合約層面實現類似效果，典型的 3-of-5 多簽要求 5 個簽名者中至少 3 個同意才能執行交易。</p>
<pre><code class="language-text">MPC 簽名流程:

  分片 1 (美國 HSM)  ─┐
  分片 2 (歐洲 HSM)  ─┤── MPC Protocol ──&gt; 簽名結果
  分片 3 (亞洲 HSM)  ─┘    (2-of-3)

  注意: 完整私鑰永遠不會在任何單一節點上被重組
</code></pre>
<p><strong>案例：</strong> 2023 年 Atomic Wallet 被駭事件，估計損失超過 1 億美元。攻擊者利用私鑰管理的漏洞，直接提取用戶資產。如果該系統採用 MPC 架構，攻擊者需要同時攻破多個獨立的安全域，難度會大幅提升。</p>
<h3 id="rpc-欺騙風險"><a class="header" href="#rpc-欺騙風險">RPC 欺騙風險</a></h3>
<p><strong>風險描述：</strong> 應用程式依賴 RPC 節點取得鏈上狀態。如果 RPC 節點被入侵、被 MITM 攻擊、或單純回傳過時資料，應用程式可能基於錯誤的資訊做出決策。</p>
<p><strong>對策：多來源 RPC 交叉驗證 + Block Hash Anchoring。</strong> 同時向 2-3 個獨立的 RPC 供應商查詢同一筆資料，比對結果是否一致。如果結果不一致，觸發告警並暫停依賴該資料的業務邏輯。Block Hash Anchoring 是進一步的驗證手段——從多個來源取得同一個區塊的 hash，確認大家看到的是同一條鏈。</p>
<pre><code class="language-python"># 偽碼: 多 RPC 交叉驗證
async def get_verified_balance(address):
    results = await asyncio.gather(
        rpc_alchemy.get_balance(address),
        rpc_infura.get_balance(address),
        rpc_self_hosted.get_balance(address),
    )
    if len(set(results)) == 1:
        return results[0]  # 三者一致，可信
    else:
        alert("RPC 結果不一致", results)
        return None  # 暫停，等待人工介入
</code></pre>
<h3 id="跨鏈訊息偽造風險"><a class="header" href="#跨鏈訊息偽造風險">跨鏈訊息偽造風險</a></h3>
<p><strong>風險描述：</strong> 攻擊者偽造來自源鏈的跨鏈訊息，欺騙目標鏈上的合約釋放資產。這是跨鏈橋被攻擊最常見的向量。</p>
<p><strong>對策：輕客戶端驗證或經濟安全模型明確化。</strong> 最安全的方式是在目標鏈上運行源鏈的輕客戶端，直接驗證源鏈的區塊頭和交易證明（例如 IBC 協議的做法）。當輕客戶端不可行時（例如在 EVM 上驗證 Bitcoin 區塊頭的成本過高），需要明確定義經濟安全模型——驗證者需要質押多少資產、被 slash 的金額是否足以覆蓋潛在損失。</p>
<h3 id="治理劫持風險"><a class="header" href="#治理劫持風險">治理劫持風險</a></h3>
<p><strong>風險描述：</strong> 攻擊者通過閃電貸等手段短暫獲取大量治理代幣，在單一區塊內提案並投票，將協議金庫的資產轉移到自己控制的地址。</p>
<p><strong>對策：Timelock + Guardian + Emergency Pause。</strong> Timelock 要求提案通過後必須等待一段時間（通常 24-48 小時）才能執行，給社群時間發現和反應。Guardian 是受信任的多簽地址，有權在緊急情況下取消尚在 Timelock 中的惡意提案。Emergency Pause 允許在發現攻擊時立即凍結合約的關鍵功能。</p>
<pre><code class="language-text">治理防禦層級:

  提案送出 ──&gt; 投票期 (3-7 天)
                  │
              投票通過
                  │
              Timelock (24-48 小時) ──&gt; Guardian 可取消
                  │
              執行提案 ──&gt; Emergency Pause 可凍結
</code></pre>
<h2 id="14-系統設計原則"><a class="header" href="#14-系統設計原則">1.4 系統設計原則</a></h2>
<p>這些原則不是教條，而是從無數次真實事故中提煉出來的工程經驗。每一條原則的背後都有血淋淋的案例支撐。</p>
<h3 id="最小信任"><a class="header" href="#最小信任">最小信任</a></h3>
<p><strong>盡量把可信計算搬到鏈上。</strong> 這是區塊鏈系統設計的第一原則。任何可以在鏈上驗證的邏輯，就不應該信任鏈下的回報。例如，不要讓後端 API 告訴前端「這筆交易成功了」，而是讓前端直接從鏈上查詢交易收據（Transaction Receipt）來確認。</p>
<p>實務上的漸進做法是：先識別系統中所有需要信任的環節，然後逐一評估哪些可以移到鏈上或用密碼學證明替代。不是所有東西都需要搬到鏈上——gas 成本和效能限制是真實的約束。關鍵是讓信任假設明確可見，而不是隱藏在程式碼的角落裡。</p>
<h3 id="可驗證性"><a class="header" href="#可驗證性">可驗證性</a></h3>
<p><strong>每一筆關鍵狀態轉移都可追溯。</strong> 這包括鏈上的交易紀錄，也包括鏈下的操作日誌。在出事時，你需要能夠回答：「是誰、在什麼時間、做了什麼操作、導致了這個結果？」</p>
<p>工程實踐上，這意味著：所有鏈下的簽名請求都要有 audit log、所有的配置變更都要有版本控制、所有的風控規則觸發都要有詳細紀錄。鏈上的部分天然具有可追溯性（區塊鏈本身就是一個不可篡改的日誌），但鏈下的部分需要你自己建設。</p>
<h3 id="漸進去中心化"><a class="header" href="#漸進去中心化">漸進去中心化</a></h3>
<p><strong>先可用，再逐步移除管理權限。</strong> 一個新上線的 DeFi 協議不可能在第一天就完全去中心化——你需要保留升級合約的能力來修復 Bug、需要保留暫停功能來應對攻擊、需要保留參數調整權來優化協議。但這些管理權限應該有明確的退出計畫：從單一管理者 → 多簽 → 時間鎖 → DAO 治理 → 最終不可升級。</p>
<pre><code class="language-text">漸進去中心化路徑:

  Phase 1: 團隊 EOA 控制 (快速迭代)
      │
  Phase 2: 多簽控制 (3-of-5 核心團隊)
      │
  Phase 3: 多簽 + Timelock (48 小時延遲)
      │
  Phase 4: DAO 投票 + Timelock + Guardian
      │
  Phase 5: 不可升級 (immutable)
</code></pre>
<h3 id="失效安全"><a class="header" href="#失效安全">失效安全</a></h3>
<p><strong>任何模組失敗時預設保守停機。</strong> 這是來自核電站和航空工業的工程原則。在區塊鏈系統中，「失效安全」意味著：RPC 節點不回應時，暫停所有提現而不是放行；風控引擎當機時，拒絕所有交易而不是跳過風控；價格預言機回傳異常值時，暫停清算而不是用錯誤價格清算。</p>
<p>反面案例：2020 年 11 月，Compound 因為 Coinbase Pro 上 DAI 的價格異常（被推高到 1.3 美元），預言機回報了錯誤的價格，導致價值 8,900 萬美元的部位被不當清算。如果系統有「價格偏離閾值時自動暫停」的失效安全機制，這筆損失可以避免。</p>
<h2 id="15-各層典型技術選型"><a class="header" href="#15-各層典型技術選型">1.5 各層典型技術選型</a></h2>
<p>以下表格列出每一層常見的技術選項，供團隊在做架構決策時參考。</p>
<div class="table-wrapper"><table><thead><tr><th>層級</th><th>技術選項</th><th>說明</th></tr></thead><tbody>
<tr><td>L7 產品層</td><td>React + wagmi, Flutter, Telegram Bot API</td><td>前端框架選擇取決於目標平台</td></tr>
<tr><td>L6 服務層</td><td>Node.js/Go API, OPA (策略引擎), Datadog (監控)</td><td>風控引擎需要低延遲</td></tr>
<tr><td>L5 交易層</td><td>ethers.js/viem, Pimlico (Bundler), OpenZeppelin Defender (Relayer)</td><td>Nonce 管理是難點</td></tr>
<tr><td>L4 簽名層</td><td>Fireblocks (MPC), Safe (Multisig), Turnkey, Privy</td><td>依據安全需求和用戶體驗選擇</td></tr>
<tr><td>L3 鏈互動層</td><td>Alchemy, Infura, QuickNode, 自建 Geth/Reth 節點</td><td>生產環境至少兩個獨立來源</td></tr>
<tr><td>L2 協議層</td><td>EVM, SVM, MoveVM, CosmWasm</td><td>決定了開發語言和工具鏈</td></tr>
<tr><td>L1 密碼學層</td><td>OpenSSL, libsecp256k1, arkworks (ZK), circom</td><td>不要自己實作密碼學原語</td></tr>
</tbody></table>
</div>
<h2 id="16-監控與可觀測性"><a class="header" href="#16-監控與可觀測性">1.6 監控與可觀測性</a></h2>
<p>一個完整的區塊鏈系統，監控不只是看伺服器 CPU 和記憶體。你需要監控的維度遠比傳統系統更多：</p>
<pre><code class="language-text">監控維度:

  ┌─────────────────────────────────────────────────────────────┐
  │                    基礎設施層                                │
  │  • 伺服器健康狀態 (CPU / Memory / Disk)                     │
  │  • RPC 節點回應時間與錯誤率                                  │
  │  • 節點同步狀態 (落後幾個區塊?)                              │
  ├─────────────────────────────────────────────────────────────┤
  │                    業務邏輯層                                │
  │  • 交易送出到確認的延遲                                      │
  │  • 交易失敗率與失敗原因分類                                   │
  │  • Gas 消耗趨勢                                              │
  ├─────────────────────────────────────────────────────────────┤
  │                    安全監控層                                 │
  │  • 錢包餘額變動 (大額即時告警)                                │
  │  • 合約事件異常 (非預期的 admin 呼叫)                        │
  │  • 跨鏈橋餘額與對帳差異                                      │
  ├─────────────────────────────────────────────────────────────┤
  │                    鏈上環境層                                 │
  │  • Gas Price 飆升 (可能正在被 MEV 攻擊)                      │
  │  • 區塊重組深度 (reorg 監控)                                  │
  │  • 預言機價格偏差                                             │
  └─────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>常見陷阱：</strong> 很多團隊只在出事後才開始建監控。正確的做法是在系統設計階段就定義好 SLI（Service Level Indicator）和 SLO（Service Level Objective），例如：「交易從送出到 finalized 的時間 P99 不超過 5 分鐘」、「RPC 回應時間 P95 不超過 200ms」。</p>
<h2 id="白話總結"><a class="header" href="#白話總結">白話總結</a></h2>
<p>把 Web3 系統想成一個現代化的金融核心系統。鏈是不可篡改的總帳本，記錄了每一筆交易的歷史；智能合約是寫在總帳上的交易規則，一旦部署就無法被單方面更改（除非設計了升級機制）；錢包和多簽是簽核流程，決定了誰有權動用資金；監控系統是稽核與風控中心，24/7 不間斷地檢查是否有異常發生。</p>
<p>與傳統金融系統最大的不同在於：區塊鏈上的錯誤是不可逆的。傳統銀行轉錯帳可以聯繫銀行回退，但鏈上轉錯地址就是永久損失。這意味著區塊鏈系統的每一層都必須比傳統系統更保守、更注重防禦。分層模型的價值在於讓你可以在每一層獨立地思考安全問題——L4 簽名層解決「誰有權簽名」，L6 服務層解決「這筆交易是否合理」，L3 鏈互動層解決「我看到的鏈上狀態是否真實」。每一層的失敗模式不同，對應的防禦手段也不同。</p>
<p>信任邊界是最需要投入安全資源的地方。每當資料從一個信任域傳遞到另一個信任域，就是攻擊者可以動手腳的地方。優秀的區塊鏈工程師不只寫功能正確的程式碼，更會不斷追問：「如果這個環節被攻破了，最壞的情況是什麼？我們能承受嗎？有沒有辦法把損失控制在可接受的範圍內？」</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-鏈類型與設計取捨"><a class="header" href="#2-鏈類型與設計取捨">2. 鏈類型與設計取捨</a></h1>
<h2 id="21-公鏈類型"><a class="header" href="#21-公鏈類型">2.1 公鏈類型</a></h2>
<p>選擇在哪條鏈上構建系統，是區塊鏈工程師面對的第一個也是最重要的架構決策。不同鏈的設計哲學、狀態模型、執行環境和經濟模型截然不同，這些差異會從根本上影響你的系統架構、開發工具、測試策略和運維方式。以下是目前主流的公鏈類型分析。</p>
<h3 id="utxo-鏈-bitcoin-類"><a class="header" href="#utxo-鏈-bitcoin-類">UTXO 鏈: Bitcoin 類</a></h3>
<p>UTXO（Unspent Transaction Output）模型是 Bitcoin 的核心設計。在這個模型中，不存在「帳戶餘額」的概念——你的「餘額」是所有屬於你的、尚未被花費的交易輸出的總和。每一筆交易都是消耗（spend）一組 UTXO 作為輸入，產生一組新的 UTXO 作為輸出。</p>
<p>這種設計有著深刻的工程含義：每個 UTXO 都是獨立的、自包含的價值單位，可以被獨立驗證，不需要查詢全域狀態。這使得 UTXO 模型天然具備較高的並行處理能力——只要兩筆交易不消耗同一個 UTXO，它們就可以被並行驗證。</p>
<pre><code class="language-text">UTXO 交易模型:

  輸入 (消耗舊 UTXO)          輸出 (產生新 UTXO)
  ┌──────────────┐            ┌──────────────┐
  │ UTXO_A: 3 BTC│──┐    ┌──&gt;│ UTXO_C: 2 BTC│ (收款方)
  └──────────────┘  │    │   └──────────────┘
  ┌──────────────┐  ├────┤   ┌──────────────┐
  │ UTXO_B: 2 BTC│──┘    └──&gt;│ UTXO_D: 2.99 BTC│ (找零回自己)
  └──────────────┘           └──────────────┘
                              差額 0.01 BTC = 礦工手續費
</code></pre>
<p>Bitcoin 的腳本語言（Script）刻意設計為非圖靈完備，只支援有限的操作碼。這不是缺陷，而是有意的設計選擇——限制表達力換取可預測性和安全性。常見的腳本類型包括 P2PKH（Pay to Public Key Hash）、P2SH（Pay to Script Hash）、P2WPKH（SegWit）和 P2TR（Taproot）。</p>
<h3 id="eutxo-鏈-cardano-類"><a class="header" href="#eutxo-鏈-cardano-類">EUTXO 鏈: Cardano 類</a></h3>
<p>EUTXO（Extended UTXO）是 Cardano 對 UTXO 模型的擴展。核心創新是在每個 UTXO 上附加 Datum（資料）和 Redeemer（贖回條件），並用 Plutus 驗證器腳本（Validator Script）來定義花費條件。這使得 UTXO 模型可以表達複雜的智能合約邏輯，同時保留 UTXO 的並行性優勢。</p>
<p>然而，EUTXO 的開發心智模型與傳統的 Account 模型有本質差異。在 Account 模型中，合約有一個持久的全域狀態，任何人都可以呼叫合約方法來修改它。在 EUTXO 中，「合約狀態」是一個 UTXO 上的 Datum，要修改它就必須消耗這個 UTXO 並產生一個新的 UTXO。這導致了一個著名的「並發問題」：如果多人同時試圖與同一個合約互動，他們都在試圖消耗同一個 UTXO，但只有一筆交易能成功。Cardano 生態通過各種 off-chain 協調機制和 batching 策略來緩解這個問題。</p>
<pre><code class="language-text">EUTXO 合約互動:

  ┌─────────────────────────────────┐
  │ UTXO (合約狀態)                  │
  │ Datum: { pool_a: 1000, pool_b: 500 } │
  │ Value: 1500 ADA                  │
  │ Validator: swap_validator.plutus │
  └──────────────┬──────────────────┘
                 │
    消耗 (需提供 Redeemer: Swap { amount: 10 })
                 │
  ┌──────────────▼──────────────────┐
  │ 新 UTXO (更新後合約狀態)          │
  │ Datum: { pool_a: 1010, pool_b: 495 } │
  │ Value: 1505 ADA                  │
  │ Validator: swap_validator.plutus │
  └─────────────────────────────────┘
</code></pre>
<h3 id="account-鏈-ethereum-類"><a class="header" href="#account-鏈-ethereum-類">Account 鏈: Ethereum 類</a></h3>
<p>Account 模型是 Ethereum 的核心設計。系統維護一棵全域狀態樹（World State Trie），每個帳戶都有一個持久的狀態，包括餘額、nonce（交易計數器）、合約程式碼和儲存空間。交易的語義是「呼叫某個帳戶的某個方法，可能改變全域狀態」。</p>
<p>Account 模型的最大優勢是開發者體驗——智能合約就像一個持久化的物件，有自己的狀態和方法，非常直覺。但這也帶來了全域狀態共享的挑戰：所有交易都在讀寫同一棵狀態樹，並行化受到嚴重限制。Ethereum 的 EVM 是單執行緒的，交易只能循序執行。</p>
<pre><code class="language-text">Account 模型狀態:

  World State Trie
  ┌──────────────────────────────────────┐
  │ 0xA1B2...  (EOA)                     │
  │   balance: 10 ETH                    │
  │   nonce: 42                          │
  ├──────────────────────────────────────┤
  │ 0xC3D4...  (Contract: Uniswap Pool) │
  │   balance: 50000 ETH                │
  │   nonce: 1                           │
  │   code: 0x6080604052...              │
  │   storage:                           │
  │     slot[0]: reserve0                │
  │     slot[1]: reserve1                │
  │     slot[2]: totalSupply             │
  └──────────────────────────────────────┘
</code></pre>
<p>Account 模型中最臭名昭著的安全問題是 Reentrancy（重入攻擊）。當合約 A 呼叫合約 B，而 B 在回呼中再次呼叫 A 時，A 可能還沒來得及更新自己的狀態，就被迫在舊狀態下再次執行邏輯。2016 年的 The DAO 事件（損失 6,000 萬美元、最終導致 Ethereum 硬分叉）就是 Reentrancy 攻擊的經典案例。</p>
<h3 id="高吞吐並行鏈-solanasui-類"><a class="header" href="#高吞吐並行鏈-solanasui-類">高吞吐並行鏈: Solana/Sui 類</a></h3>
<p>Solana 和 Sui/Aptos 代表了另一種設計哲學：犧牲一定程度的去中心化，換取極致的執行效能。Solana 使用 Proof of History（PoH）作為時間戳機制，搭配 Tower BFT 共識，在 400ms 的 slot 時間內處理交易。Sui 使用 Move 語言和物件導向的資料模型，對不涉及共享物件的交易可以跳過共識直接確認。</p>
<p>這類鏈的工程挑戰與 Ethereum 完全不同：你不用太擔心 gas 優化（費用極低），但需要關注帳戶租金（Solana 的 rent）、交易大小限制、CU（Compute Unit）限制、以及高頻場景下的 RPC 壓力。Solana 的 RPC 節點在高峰期經常出現延遲或掉線，這對依賴實時鏈上資料的應用是嚴峻的挑戰。</p>
<pre><code class="language-text">Solana 並行執行模型:

  交易宣告存取的帳戶:
  Tx1: [Account_A, Account_B]     ─┐
  Tx2: [Account_C, Account_D]     ─┤── 無衝突，可並行
  Tx3: [Account_E, Account_F]     ─┘
  Tx4: [Account_A, Account_C]     ──── 與 Tx1, Tx2 衝突，須循序

  Sealevel Runtime 根據存取集合自動排程並行/循序執行
</code></pre>
<h3 id="模組化鏈-da--execution--settlement-拆分"><a class="header" href="#模組化鏈-da--execution--settlement-拆分">模組化鏈: DA / Execution / Settlement 拆分</a></h3>
<p>模組化區塊鏈是近年來最重要的架構趨勢。傳統的單體鏈（Monolithic Chain）在單一系統中同時處理執行（Execution）、共識（Consensus）、資料可用性（Data Availability）和結算（Settlement）。模組化設計將這四個功能拆分到不同的專門化層級，每一層可以獨立優化。</p>
<p>Ethereum + Rollup 是目前最成熟的模組化架構：Rollup 負責執行（在 L2 上跑交易），Ethereum L1 負責結算和共識，Celestia 或 EigenDA 等專門的 DA 層負責資料可用性。這種分工讓每一層都能專注於自己最擅長的事情，整體性能遠超單體鏈。</p>
<pre><code class="language-text">模組化區塊鏈架構:

  ┌─────────────────────┐
  │   執行層 (Execution) │  Rollup (Arbitrum, zkSync, ...)
  │   處理交易、執行合約  │
  └──────────┬──────────┘
             │ 交易批次 + 狀態根
  ┌──────────▼──────────┐
  │   結算層 (Settlement)│  Ethereum L1
  │   驗證 proof / 仲裁  │
  └──────────┬──────────┘
             │
  ┌──────────▼──────────┐
  │   共識層 (Consensus) │  Ethereum PoS 驗證者
  │   排序、出塊          │
  └──────────┬──────────┘
             │
  ┌──────────▼──────────┐
  │   DA 層 (Data Avail.)│  Ethereum blobs / Celestia / EigenDA
  │   確保資料可取得      │
  └─────────────────────┘
</code></pre>
<h2 id="22-常見生態定位"><a class="header" href="#22-常見生態定位">2.2 常見生態定位</a></h2>
<p>每條鏈在「安全-性能-成本-生態」的多維空間中佔據不同的位置。選擇哪條鏈，取決於你的業務需求在這些維度上的優先順序。</p>
<div class="table-wrapper"><table><thead><tr><th>類型</th><th>代表</th><th>優勢</th><th>代價</th></tr></thead><tbody>
<tr><td>安全優先 L1</td><td>Bitcoin, Ethereum</td><td>安全預算高、生態成熟</td><td>成本與吞吐受限</td></tr>
<tr><td>高性能 L1</td><td>Solana, Sui, Aptos</td><td>低延遲、低費用</td><td>節點門檻高、中心化壓力</td></tr>
<tr><td>Rollup L2</td><td>Arbitrum, Optimism, zkSync, Base</td><td>低費用、繼承 L1 安全</td><td>依賴橋與排序器</td></tr>
<tr><td>AppChain/Subnet</td><td>Cosmos, Avalanche 子網</td><td>客製治理與費率</td><td>生態與流動性切割</td></tr>
</tbody></table>
</div>
<h3 id="安全優先-l1"><a class="header" href="#安全優先-l1">安全優先 L1</a></h3>
<p>Bitcoin 和 Ethereum 是市值最大、歷史最久、安全預算最高的兩條公鏈。Bitcoin 的安全來自全球規模的 PoW 算力（每日安全支出超過 3,000 萬美元），Ethereum 的安全來自超過 3,000 萬顆 ETH 的質押（價值數百億美元）。這意味著要攻擊這兩條鏈的成本極其高昂，幾乎不可能成功。</p>
<p>代價是吞吐量和成本。Ethereum 主網的 gas 費在高峰期可以飆升到數十美元一筆交易，Bitcoin 的平均出塊時間是 10 分鐘。對於需要高頻互動的應用（如遊戲、社交），直接在 L1 上運行是不現實的。這就是為什麼 Rollup L2 生態快速崛起的原因。</p>
<h3 id="高性能-l1"><a class="header" href="#高性能-l1">高性能 L1</a></h3>
<p>Solana 每秒可處理數千筆交易，平均手續費低於 0.01 美元，出塊時間 400ms。Sui 和 Aptos 使用 Move 語言，在物件級別實現並行執行，對簡單交易可以達到次秒級確認。這些鏈適合需要高頻、低延遲互動的場景，如鏈上訂單簿交易所、即時遊戲等。</p>
<p>但高性能的代價是中心化壓力。Solana 的全節點需要高端硬體（128GB RAM、多核 CPU、高速 SSD），這使得驗證者數量相對較少。此外，Solana 歷史上曾多次因為高負載導致全網停機（outage），這對需要 24/7 可用性的業務是重大風險。在選擇高性能 L1 時，必須將這些停機風險納入系統設計——例如設計 fallback 到其他鏈的機制。</p>
<h3 id="rollup-l2"><a class="header" href="#rollup-l2">Rollup L2</a></h3>
<p>Rollup 是目前最受歡迎的擴容方案。核心思想是在 L2 上執行交易、在 L1 上驗證結果。Optimistic Rollup（如 Arbitrum、Optimism）假設所有交易都是正確的，除非有人在挑戰期內提出欺詐證明。ZK Rollup（如 zkSync、Starknet）用零知識證明數學地證明所有交易的正確性。</p>
<p>Rollup 的主要風險在於 Sequencer（排序器）的中心化。目前大多數 Rollup 的排序器由項目方獨自運營，如果排序器宕機或審查交易，使用者的資金不會丟失（因為可以通過 L1 強制退出），但使用體驗會受到嚴重影響。Sequencer 去中心化是所有 Rollup 團隊正在努力的方向。</p>
<h3 id="appchain--subnet"><a class="header" href="#appchain--subnet">AppChain / Subnet</a></h3>
<p>AppChain 的理念是「每個應用有自己的鏈」。Cosmos 生態中的每條鏈（如 Osmosis、dYdX Chain）都有獨立的驗證者集合和治理機制，通過 IBC（Inter-Blockchain Communication）協議實現跨鏈通訊。Avalanche 子網允許創建自定義的區塊鏈，共享 Avalanche 的驗證者基礎設施。</p>
<p>AppChain 的優勢是完全客製化——你可以定義自己的 gas 代幣、出塊時間、交易格式和治理規則。代價是流動性碎片化和生態割裂。當每個應用都有自己的鏈時，資產在不同鏈之間流動需要通過跨鏈橋，這增加了複雜性和安全風險。</p>
<h2 id="23-utxo--eutxo--account-對照"><a class="header" href="#23-utxo--eutxo--account-對照">2.3 UTXO / EUTXO / Account 對照</a></h2>
<div class="table-wrapper"><table><thead><tr><th>維度</th><th>UTXO</th><th>EUTXO</th><th>Account</th></tr></thead><tbody>
<tr><td>狀態單位</td><td>未花費輸出</td><td>帶資料與腳本條件的輸出</td><td>全域帳戶狀態</td></tr>
<tr><td>並行性</td><td>高（不同 UTXO 可並行）</td><td>高（取決於輸入衝突）</td><td>較受 nonce / shared state 影響</td></tr>
<tr><td>合約表達力</td><td>傳統較弱</td><td>中高（函數式條件）</td><td>高（通用 VM）</td></tr>
<tr><td>開發心智模型</td><td>Cashflow/輸入輸出</td><td>狀態轉移 + datum/redeemer</td><td>物件/狀態機</td></tr>
<tr><td>常見風險</td><td>UTXO 管理碎片化</td><td>腳本與 datum 設計複雜</td><td>reentrancy / global state 競態</td></tr>
</tbody></table>
</div>
<h3 id="深入理解三種模型的差異"><a class="header" href="#深入理解三種模型的差異">深入理解三種模型的差異</a></h3>
<p><strong>UTXO 的思維方式是「現金流」。</strong> 你手上有幾張紙鈔（UTXO），要付錢時選擇湊足金額的紙鈔作為輸入，產生新的紙鈔給收款方和自己（找零）。每張紙鈔只能用一次（spent），用完就永遠不能再用。這使得雙重花費（double spending）的檢查非常簡單——只需要確認每個輸入的 UTXO 沒有在其他交易中被使用過。</p>
<pre><code class="language-text">UTXO 選幣演算法示例:

  目標: 支付 0.7 BTC

  可用 UTXO:
    UTXO_1: 0.3 BTC
    UTXO_2: 0.5 BTC  ←── 選擇
    UTXO_3: 0.1 BTC
    UTXO_4: 0.4 BTC  ←── 選擇

  輸入: UTXO_2 (0.5) + UTXO_4 (0.4) = 0.9 BTC
  輸出:
    - 收款方: 0.7 BTC (新 UTXO)
    - 找零:   0.1999 BTC (新 UTXO，回到自己)
    - 手續費: 0.0001 BTC (隱含，不出現在輸出中)
</code></pre>
<p><strong>Account 的思維方式是「銀行帳戶」。</strong> 你有一個帳戶，裡面有個餘額數字。轉帳就是從你的帳戶扣錢、往對方帳戶加錢。這很直覺，但隱含了一個全域鎖的問題——同一個帳戶在同一時間只能有一筆交易被處理（由 nonce 保證交易順序）。合約的全域狀態也類似：Uniswap 的流動性池是一個共享狀態，所有 swap 交易必須循序修改它。</p>
<p><strong>EUTXO 是兩者的折衷嘗試。</strong> 它保留了 UTXO 的並行性優勢，同時透過 Datum 和 Validator Script 獲得了智能合約的表達力。但 EUTXO 的開發模式要求更多的函數式編程思維（Haskell/Plutus），學習曲線相對陡峭。</p>
<h3 id="各模型的工程影響"><a class="header" href="#各模型的工程影響">各模型的工程影響</a></h3>
<div class="table-wrapper"><table><thead><tr><th>工程面向</th><th>UTXO</th><th>EUTXO</th><th>Account</th></tr></thead><tbody>
<tr><td>錢包開發</td><td>需要 UTXO 選幣邏輯、找零管理</td><td>UTXO 管理 + Datum 處理</td><td>相對簡單，查餘額就好</td></tr>
<tr><td>交易建構</td><td>手動組裝輸入輸出</td><td>組裝 UTXO + Datum + Redeemer</td><td>指定目標地址和金額即可</td></tr>
<tr><td>餘額查詢</td><td>掃描所有屬於該地址的 UTXO</td><td>掃描 UTXO + 解析 Datum</td><td>直接查詢帳戶狀態</td></tr>
<tr><td>交易追蹤</td><td>天然可追蹤（UTXO 圖）</td><td>可追蹤但更複雜</td><td>需要事件日誌（Event Log）</td></tr>
<tr><td>隱私性</td><td>較好（每次可用新地址）</td><td>較好</td><td>較差（帳戶地址固定）</td></tr>
</tbody></table>
</div>
<h2 id="24-常見-utxo-鏈工程實務視角"><a class="header" href="#24-常見-utxo-鏈工程實務視角">2.4 常見 UTXO 鏈（工程實務視角）</a></h2>
<p>以下列出主要的 UTXO 系列區塊鏈，從工程實務的角度分析它們的特點和適用場景。</p>
<div class="table-wrapper"><table><thead><tr><th>鏈</th><th>模型</th><th>特點</th><th>常見用途</th></tr></thead><tbody>
<tr><td>Bitcoin</td><td>UTXO</td><td>安全與去中心化優先</td><td>價值儲存、結算</td></tr>
<tr><td>Litecoin</td><td>UTXO</td><td>區塊較快、支付友好</td><td>小額支付</td></tr>
<tr><td>Dogecoin</td><td>UTXO</td><td>社群與支付導向</td><td>零售/打賞</td></tr>
<tr><td>Bitcoin Cash</td><td>UTXO</td><td>大區塊路線</td><td>低費支付</td></tr>
<tr><td>Dash</td><td>UTXO</td><td>Masternode 特性</td><td>支付與治理</td></tr>
<tr><td>Zcash</td><td>UTXO + Shielded Pool</td><td>隱私交易能力</td><td>隱私支付</td></tr>
<tr><td>Monero</td><td>UTXO-like (RingCT)</td><td>強匿名性</td><td>隱私導向</td></tr>
<tr><td>Cardano</td><td>EUTXO</td><td>函數式合約模型</td><td>UTXO + 合約應用</td></tr>
<tr><td>Nervos CKB</td><td>Cell Model(UTXO 變體)</td><td>可編程 Cell</td><td>基礎資產層/擴展</td></tr>
<tr><td>Kaspa</td><td>UTXO + DAG</td><td>高吞吐 PoW 路線</td><td>高頻轉帳</td></tr>
</tbody></table>
</div>
<h3 id="bitcoin-工程實務"><a class="header" href="#bitcoin-工程實務">Bitcoin 工程實務</a></h3>
<p>Bitcoin 是 UTXO 模型的原型，也是在工程上最需要注意 UTXO 管理的鏈。在構建 Bitcoin 相關系統時，有幾個常見的工程挑戰：</p>
<p><strong>UTXO 碎片化管理：</strong> 當一個地址收到大量小額支付（例如交易所的入金地址），會產生大量小額 UTXO。當需要支付大額時，必須合併（consolidate）這些 UTXO，而每個輸入都需要消耗交易空間（因此增加手續費）。最佳實踐是在手續費低的時段（通常是週末或鏈上活動較少時）定期做 UTXO 合併。</p>
<pre><code class="language-text">UTXO 碎片化示例:

  問題場景: 交易所冷錢包有 10,000 個 UTXO，每個 0.001 BTC
  總餘額: 10 BTC
  要提現: 5 BTC

  交易大小 ≈ 10000 inputs × 148 bytes ≈ 1.48 MB
  (超過 Bitcoin 區塊大小限制 ~4 MB weight!)

  解決方案: 提前在低費率時段做 UTXO 合併
  - 分批合併 (每次 500 個 UTXO)
  - 監控 mempool 費率，在 &lt; 10 sat/vByte 時執行
</code></pre>
<p><strong>手續費估算：</strong> Bitcoin 的手續費不是按金額計算，而是按交易的資料大小（或更精確地說，weight unit）計算。一筆有 2 個輸入、2 個輸出的 P2WPKH 交易大約是 141 vBytes，如果當前費率是 20 sat/vByte，手續費就是 2,820 satoshis。RBF（Replace-by-Fee）和 CPFP（Child-Pays-for-Parent）是加速交易確認的兩種機制。</p>
<p><strong>地址類型選擇：</strong> P2TR（Taproot）是目前推薦的地址類型，提供最好的隱私性和最低的手續費。但需要注意與老系統的相容性——有些交易所和錢包可能尚未支援 Taproot 地址的發送。</p>
<h3 id="隱私鏈工程考量"><a class="header" href="#隱私鏈工程考量">隱私鏈工程考量</a></h3>
<p>Zcash 和 Monero 是兩條主要的隱私鏈，它們在工程上有特殊的挑戰：</p>
<p><strong>Zcash</strong> 的 Shielded Pool 使用 zk-SNARK 證明來隱藏交易的發送方、接收方和金額。生成 ZK 證明是計算密集型操作，在手機端可能需要數十秒甚至數分鐘。從合規角度，Zcash 支援 viewing key，允許持有者對監管機構披露交易歷史而不暴露私鑰。</p>
<p><strong>Monero</strong> 的隱私是強制性的（不是可選的），使用 Ring Signatures（環簽名）隱藏發送方、Stealth Address（隱匿地址）隱藏接收方、RingCT 隱藏金額。這對交易所的合規部門構成挑戰，因為無法通過鏈上分析追蹤資金流向。</p>
<h2 id="25-三角取捨"><a class="header" href="#25-三角取捨">2.5 三角取捨</a></h2>
<pre><code class="language-text">             去中心化
                /\
               /  \
              / BTC\
             / ETH  \
            /        \
           /  Rollups  \
          /    Cosmos    \
         /      SOL       \
   安全性  /________________\  可擴展性
          AppChain   Sui/Aptos
</code></pre>
<p>區塊鏈的「不可能三角」（Scalability Trilemma）是 Vitalik Buterin 提出的概念：一條區塊鏈不可能同時在去中心化、安全性和可擴展性三個維度上都做到極致。任何設計都是在這三者之間做取捨。</p>
<p>工程上不是選一個點，而是做「可接受風險集合」：</p>
<ul>
<li>資產託管系統偏安全/去中心化</li>
<li>交易撮合系統偏可擴展/低延遲</li>
<li>跨鏈系統偏向可驗證性與失效安全</li>
</ul>
<h3 id="實務中的取捨決策"><a class="header" href="#實務中的取捨決策">實務中的取捨決策</a></h3>
<p><strong>案例 1: DeFi 借貸協議。</strong> Aave 和 Compound 部署在 Ethereum 主網，因為借貸協議管理著數十億美元的資產，安全性是第一優先。即使 gas 費高昂，用戶可以接受，因為相比於借貸金額，幾美元的手續費是微不足道的。後來 Aave 也部署到 Arbitrum、Optimism 等 L2，為小額借貸的用戶提供低成本選項。</p>
<p><strong>案例 2: 鏈上遊戲。</strong> Axie Infinity 最初在 Ethereum 主網上運行，gas 費讓玩家無法承受。後來遷移到自建的 Ronin 側鏈（AppChain），犧牲了去中心化（只有少數驗證者），換取了低費用和高吞吐。代價是 Ronin Bridge 在 2022 年被攻擊，損失 6.25 億美元——這正是去中心化不足帶來的安全風險。</p>
<p><strong>案例 3: 穩定幣支付。</strong> Circle 的 USDC 部署在多條鏈上，包括 Ethereum（高安全性大額結算）、Solana（低費用零售支付）、Arbitrum（平衡方案）。不同場景使用不同鏈，是工程上最務實的做法。</p>
<h2 id="26-選鏈評估矩陣"><a class="header" href="#26-選鏈評估矩陣">2.6 選鏈評估矩陣</a></h2>
<p>選擇區塊鏈不是一次性的決策，而是需要持續評估的過程。以下是評估框架的各個維度，每個維度都附帶具體的衡量指標。</p>
<h3 id="安全"><a class="header" href="#安全">安全</a></h3>
<ul>
<li><strong>歷史事故：</strong> 該鏈是否曾經發生過嚴重的安全事件（共識失敗、停機、資金損失）？</li>
<li><strong>節點分散度：</strong> 驗證者數量、地理分佈、營運實體的多樣性。Ethereum 有超過 80 萬個驗證者，Solana 約 1,500 個。</li>
<li><strong>客戶端多樣性：</strong> 是否有多個獨立的客戶端實作？Ethereum 有 Geth、Nethermind、Besu、Erigon 等，降低了單一實作 Bug 導致全網故障的風險。如果只有一個客戶端實作，該客戶端的 Bug 就是全網的 Bug。</li>
</ul>
<h3 id="成本"><a class="header" href="#成本">成本</a></h3>
<ul>
<li><strong>平均手續費：</strong> 日常操作的平均 gas 費。Ethereum 主網數美元、Arbitrum 數美分、Solana 低於一美分。</li>
<li><strong>尖峰手續費：</strong> 在 NFT mint、空投搶奪等極端場景下的手續費。Ethereum 主網曾出現單筆交易超過 100 美元 gas 費的情況。</li>
<li><strong>橋接成本：</strong> 將資產從一條鏈移動到另一條鏈的費用，包括手續費和滑點。</li>
</ul>
<h3 id="可用性"><a class="header" href="#可用性">可用性</a></h3>
<ul>
<li><strong>RPC 穩定度：</strong> 公共和付費 RPC 端點的可用性和回應時間。</li>
<li><strong>重組機率：</strong> 區塊重組發生的頻率和深度。Ethereum PoS 後重組極為罕見（每年不到 1 次），Polygon PoS 曾發生較深的重組。</li>
<li><strong>最終性時間：</strong> 交易從送出到「不可逆」的時間。Ethereum 約 12 分鐘（2 個 epoch）、Solana 約 12 秒、Arbitrum 約 7 天（挑戰期）。</li>
</ul>
<h3 id="開發"><a class="header" href="#開發">開發</a></h3>
<ul>
<li><strong>SDK 成熟度：</strong> 是否有完善的開發工具包？ethers.js/viem 是 EVM 生態的標準，@solana/web3.js 是 Solana 的對應物。</li>
<li><strong>測試工具：</strong> Hardhat、Foundry（EVM）、Anchor（Solana）等本地測試框架的成熟度。</li>
<li><strong>審計供給：</strong> 能找到多少有經驗的安全審計公司？EVM 合約的審計市場最成熟，Move 語言的審計供給較少。</li>
</ul>
<h3 id="生態"><a class="header" href="#生態">生態</a></h3>
<ul>
<li><strong>TVL（Total Value Locked）：</strong> 鎖定在該鏈上 DeFi 協議中的總資產價值，反映了資本的信任程度。</li>
<li><strong>流動性深度：</strong> DEX 上的流動性是否足夠支撐大額交易而不產生過大滑點？</li>
<li><strong>協議組合性（Composability）：</strong> 不同協議之間是否可以無縫組合？這是 Ethereum 生態的最大優勢——你可以在一筆交易中同時呼叫 Uniswap、Aave 和 Curve。</li>
</ul>
<h3 id="合規"><a class="header" href="#合規">合規</a></h3>
<ul>
<li><strong>地區政策：</strong> 目標市場對加密貨幣的監管態度。某些司法管轄區對隱私幣有限制。</li>
<li><strong>交易監控：</strong> 是否有成熟的鏈上分析工具（Chainalysis、TRM Labs）支援該鏈？</li>
<li><strong>稽核需求：</strong> 金融級應用需要可審計的交易記錄。UTXO 模型天然具備較好的可追蹤性。</li>
</ul>
<h2 id="27-什麼時候選-utxo"><a class="header" href="#27-什麼時候選-utxo">2.7 什麼時候選 UTXO</a></h2>
<p>UTXO 模型並不適合所有場景，但在特定的使用情境中，它比 Account 模型有著顯著的優勢。以下是適合選擇 UTXO 鏈的場景分析。</p>
<h3 id="核心適用場景"><a class="header" href="#核心適用場景">核心適用場景</a></h3>
<ul>
<li>
<p><strong>以「資產可追蹤、可審計、穩定結算」為核心。</strong> UTXO 的圖結構天然提供了完整的資金流向追蹤能力。從任何一筆 UTXO 出發，你可以向前追溯它的來源（一直追到 coinbase 交易），也可以向後追蹤它被花費後的去向。這對合規、反洗錢（AML）和審計需求非常有價值。</p>
</li>
<li>
<p><strong>不需要複雜共享狀態合約。</strong> 如果你的業務邏輯主要是「A 付錢給 B」、「多人共同簽署一筆支付」、「時間鎖定支付」等支付類場景，UTXO 的腳本系統已經足夠。硬要在 UTXO 鏈上實現像 Uniswap 那樣的 AMM DEX，雖然技術上可行（如 Cardano 上的 DEX），但開發複雜度會比 Account 模型高出許多。</p>
</li>
<li>
<p><strong>對簽核流程與輸入輸出控制要求高。</strong> UTXO 模型允許你精確控制每一筆交易的輸入和輸出。在企業資金管理場景中，你可以強制要求「冷錢包的 UTXO 只能被轉到白名單地址」、「每筆 UTXO 的花費都需要 3-of-5 多簽」。這種細粒度的控制在 Account 模型中需要額外的合約邏輯才能實現。</p>
</li>
</ul>
<h3 id="不適合-utxo-的場景"><a class="header" href="#不適合-utxo-的場景">不適合 UTXO 的場景</a></h3>
<ul>
<li><strong>需要複雜的鏈上商業邏輯：</strong> AMM、借貸、衍生品等 DeFi 協議的核心邏輯依賴全域共享狀態。</li>
<li><strong>需要快速的開發迭代：</strong> EVM 生態的開發工具和開發者社群遠比 UTXO 鏈成熟。</li>
<li><strong>需要高度的協議組合性：</strong> DeFi 的「樂高積木」效應在 Account 模型中更容易實現。</li>
</ul>
<pre><code class="language-text">選擇決策樹:

  你的核心需求是什麼?
  │
  ├── 安全結算 / 資產託管 / 合規審計
  │   └── 選 UTXO 鏈 (Bitcoin / Litecoin)
  │
  ├── 複雜 DeFi / NFT / 遊戲
  │   └── 選 Account 鏈 (Ethereum / L2 / Solana)
  │
  ├── UTXO 資產 + 智能合約
  │   └── 選 EUTXO 鏈 (Cardano) 或 Cell Model (Nervos CKB)
  │
  └── 客製化治理 / 獨立鏈
      └── 選 AppChain (Cosmos SDK / Avalanche Subnet)
</code></pre>
<h2 id="白話總結-1"><a class="header" href="#白話總結-1">白話總結</a></h2>
<p>UTXO 可以把每筆錢想成獨立紙鈔，花錢時要拆紙鈔再找零；Account 像銀行帳戶，直接改餘額。兩種都能做系統，但工程思維完全不同。UTXO 模型強迫你思考「我要花哪幾張紙鈔、找零給誰」，這種思維方式使得每筆交易都是自包含的、可獨立驗證的，非常適合「付款-結算」類的業務場景。Account 模型讓你像操作資料庫一樣操作鏈上狀態，開發起來更直覺，但也帶來了全域狀態共享、重入攻擊等 Account 特有的風險。</p>
<p>選鏈不是選「最好的鏈」，而是選「最適合你業務的鏈」。如果你在做交易所的結算系統，Bitcoin 的安全性和可審計性是最重要的；如果你在做一個 DeFi 協議，Ethereum 或其 L2 的生態和組合性是關鍵；如果你在做一個高頻交易的鏈上訂單簿，Solana 的低延遲是剛需。很多成熟的業務會同時使用多條鏈——在 Ethereum 上做高價值結算、在 L2 上做日常互動、在 Bitcoin 上做最終的價值儲存。多鏈策略已經從選項變成了標配，但它也帶來了跨鏈資產管理和對帳的複雜性，這是你在做架構決策時必須預先考慮的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-共識最終性與重組"><a class="header" href="#3-共識最終性與重組">3. 共識、最終性與重組</a></h1>
<h2 id="31-共識模型"><a class="header" href="#31-共識模型">3.1 共識模型</a></h2>
<p>共識機制是區塊鏈的心臟——它決定了一群互不信任的節點如何對「哪些交易是有效的、以什麼順序執行」達成一致意見。不同的共識機制在安全性、去中心化程度、最終性速度和能源效率之間做出不同的取捨。作為區塊鏈系統工程師，你不需要發明新的共識機制，但必須深刻理解你所使用的鏈的共識特性，因為這直接影響你的系統在「何時可以信任一筆交易已經完成」這個問題上的設計。</p>
<h3 id="nakamoto-pow-機率最終性"><a class="header" href="#nakamoto-pow-機率最終性">Nakamoto PoW: 機率最終性</a></h3>
<p>Nakamoto Consensus（中本聰共識）是 Bitcoin 採用的共識機制，也是歷史上第一個成功解決拜占庭將軍問題的去中心化方案。其核心思想是「最長鏈規則」——所有節點都選擇累積工作量（Proof of Work）最多的鏈作為正確的鏈。礦工通過消耗計算資源來「挖礦」，找到符合難度要求的 hash 值後就可以產生新區塊。</p>
<p>重組風險隨確認數下降，但永遠不會降到零——這就是「機率最終性」（Probabilistic Finality）的含義。一筆交易被打包進區塊後，後面每多一個區塊確認，被重組的機率就指數級下降。Bitcoin 社群傳統上認為 6 個確認（約 60 分鐘）足夠安全，因為此時攻擊者需要控制超過全網 50% 的算力才有非微不足道的機率成功重組。</p>
<pre><code class="language-text">確認數與安全性 (假設攻擊者控制 10% 算力):

  確認數    被重組機率
  ────────────────────────
  1 確認    ~0.2%
  2 確認    ~0.04%
  3 確認    ~0.008%
  6 確認    ~0.00003%   &lt;── Bitcoin 傳統門檻
  12 確認   ~0.000000001%

  注意: 如果攻擊者控制更多算力，所需確認數要相應增加
</code></pre>
<p><strong>工程實務影響：</strong> 在構建接受 Bitcoin 支付的系統時，你必須決定每種場景需要多少個確認數。一杯咖啡的支付也許 0-confirmation 就可以接受（輔以其他風控手段），但一筆 100 BTC 的 OTC 交易可能需要 6 個甚至更多確認。不同確認數對應不同的等待時間（每個確認約 10 分鐘），這直接影響用戶體驗。</p>
<pre><code class="language-python"># 偽碼: 根據金額決定確認數
def required_confirmations(amount_btc: float) -&gt; int:
    if amount_btc &lt; 0.01:
        return 1     # 小額，快速確認
    elif amount_btc &lt; 1.0:
        return 3     # 中等金額
    elif amount_btc &lt; 10.0:
        return 6     # 大額，標準門檻
    else:
        return 12    # 超大額，最高安全
</code></pre>
<h3 id="pos--bft-經濟懲罰--檢查點"><a class="header" href="#pos--bft-經濟懲罰--檢查點">PoS + BFT: 經濟懲罰 + 檢查點</a></h3>
<p>Proof of Stake（權益證明）搭配 BFT（Byzantine Fault Tolerance）變種是目前大多數新一代區塊鏈採用的共識機制。Ethereum 在 2022 年 9 月完成 The Merge，從 PoW 轉換到 PoS。在 PoS 中，驗證者質押（stake）原生代幣作為保證金，如果他們試圖作弊（例如同時為兩個衝突的區塊簽名），他們的質押會被削減（slashing）。</p>
<p>Ethereum 的 PoS 共識（Casper FFG + LMD GHOST）將時間劃分為 slot（12 秒）和 epoch（32 個 slot = 6.4 分鐘）。每個 epoch 結束時，如果有超過 2/3 的驗證者對該 epoch 的檢查點投票，該檢查點就被「justified」；如果連續兩個 epoch 的檢查點都被 justified，較早的那個就被「finalized」。Finalized 的區塊在協議層面是不可逆的——要回滾它需要至少 1/3 的驗證者被 slashed（在 Ethereum 上意味著數十億美元的經濟損失）。</p>
<pre><code class="language-text">Ethereum PoS Finality 流程:

  Epoch N-1          Epoch N            Epoch N+1
  [32 slots]         [32 slots]         [32 slots]
  ─────────── ──────────────── ────────────────
       │                │                │
  Checkpoint A     Checkpoint B    Checkpoint C
       │                │                │
       └── justified ──&gt;│                │
                        └── justified ──&gt;│
                        │                │
                   A finalized!    B finalized!
                   (不可逆)

  從交易被打包到 finalized ≈ 12-15 分鐘
</code></pre>
<p><strong>其他 PoS + BFT 的實作：</strong></p>
<ul>
<li>
<p><strong>Tendermint（Cosmos 生態）：</strong> 採用即時最終性——一旦區塊被 2/3 的驗證者簽名確認，就立即 finalized，不存在分叉的可能。延遲通常在 6-7 秒。代價是如果超過 1/3 的驗證者離線，整條鏈會停止出塊（liveness 犧牲換取 safety）。</p>
</li>
<li>
<p><strong>Tower BFT（Solana）：</strong> 利用 Proof of History 作為時間戳機制，結合類 PBFT 共識。Solana 的 vote 交易佔了全網交易量的很大比例（有時超過 50%），這些 vote 就是驗證者在進行共識。Finality 通常在 12-15 秒。</p>
</li>
<li>
<p><strong>Narwhal + Bullshark（Sui）：</strong> 基於 DAG（有向無環圖）的共識，先做資料傳播（Narwhal），再做排序（Bullshark）。對不涉及共享物件的「簡單交易」可以跳過共識直接確認，延遲低於 500ms。</p>
</li>
</ul>
<h3 id="rollup-l2-本地排序--l1-結算最終性"><a class="header" href="#rollup-l2-本地排序--l1-結算最終性">Rollup: L2 本地排序 + L1 結算最終性</a></h3>
<p>Rollup 的共識模型與 L1 根本不同。Rollup 不需要自己的去中心化共識——它依賴 L1 的共識作為最終的安全保障。L2 的 Sequencer（排序器）只是決定交易的執行順序，然後把結果（以及證明）提交到 L1。</p>
<p>這產生了多層級的最終性，工程上需要非常小心地區分：</p>
<pre><code class="language-text">Rollup 最終性層級:

  ┌───────────────────────────────────────────────────────────────┐
  │ Level 0: Sequencer Confirmation (即時)                        │
  │   Sequencer 回傳「交易已收到並排序」                            │
  │   信任假設: 信任 Sequencer 不會惡意重排或丟棄                   │
  │   風險: Sequencer 可能當機、審查交易、MEV 重排                  │
  ├───────────────────────────────────────────────────────────────┤
  │ Level 1: L1 Batch Submission (數分鐘到數小時)                  │
  │   交易批次被提交到 L1 的合約中                                  │
  │   信任假設: 資料已在 L1 上可用，任何人可驗證                    │
  │   風險: 仍未被最終驗證（Optimistic Rollup 的挑戰期尚未開始）    │
  ├───────────────────────────────────────────────────────────────┤
  │ Level 2: L1 Finality (Optimistic: 7天 / ZK: 數小時)           │
  │   Optimistic: 7 天挑戰期過後無人提出欺詐證明                   │
  │   ZK: 零知識證明被 L1 合約驗證通過                              │
  │   信任假設: L1 的共識安全                                      │
  │   風險: 與 L1 相同（幾乎可忽略）                               │
  └───────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>工程決策：</strong> 大多數 Rollup 上的應用在 Level 0（Sequencer Confirmation）就視為交易完成。這對於 DEX 交易、遊戲互動等場景是合理的——Sequencer 惡意行為的機率很低，且即使發生，用戶可以通過 L1 的 escape hatch 機制取回資金。但對於大額跨鏈轉帳、交易所入金等高風險場景，應該等到 Level 1 甚至 Level 2。</p>
<h2 id="32-最終性層級"><a class="header" href="#32-最終性層級">3.2 最終性層級</a></h2>
<p>最終性（Finality）是區塊鏈工程中最容易被誤解的概念之一。很多開發者簡單地認為「交易被打包進區塊 = 交易完成」，但事實遠非如此。不同鏈、不同場景下的「完成」有著截然不同的含義和安全保障。</p>
<h3 id="soft-finality軟最終性"><a class="header" href="#soft-finality軟最終性">Soft Finality（軟最終性）</a></h3>
<p><strong>通常幾秒到幾分鐘，可能被重組。</strong> Soft Finality 是指交易已經被打包進區塊，但該區塊尚未積累足夠的確認或通過最終性檢查點。在這個階段，區塊有可能因為分叉競爭而被重組——你的交易可能從主鏈上消失。</p>
<p>Soft Finality 適用於低風險場景：查看 NFT 元資料、顯示交易歷史、更新 UI 狀態等。在這些場景中，即使交易最終被重組，也不會造成資金損失。</p>
<pre><code class="language-text">各鏈 Soft Finality 時間:

  Bitcoin:       ~10 分鐘 (1 個確認)
  Ethereum:      ~12 秒 (1 個 slot)
  Solana:        ~400ms (1 個 slot)
  Polygon PoS:   ~2 秒 (1 個區塊)
  Arbitrum:      即時 (Sequencer 回傳)
  Avalanche:     ~1-2 秒 (Snowball 協議)
</code></pre>
<h3 id="economic-finality經濟最終性"><a class="header" href="#economic-finality經濟最終性">Economic Finality（經濟最終性）</a></h3>
<p><strong>回滾成本高，實務可視為完成。</strong> Economic Finality 是指雖然協議層面理論上仍可能被回滾，但這樣做的經濟成本已經高到不理性的程度。例如，要回滾 Ethereum 的一個 finalized epoch，需要至少 1/3 的驗證者願意被 slashed——在當前質押量下，這意味著超過 100 億美元的經濟損失。理性的攻擊者不會這樣做，因為攻擊成本遠高於可能的收益。</p>
<p>Economic Finality 是大多數業務場景的實際依據。交易所的入金確認、支付閘道的訂單結算、DeFi 協議的清算觸發，通常都在 Economic Finality 階段就執行。</p>
<p><strong>如何評估 Economic Finality 的安全性？</strong> 核心公式是：</p>
<pre><code class="language-text">安全條件: 攻擊成本 &gt; 攻擊收益

Bitcoin PoW:
  攻擊成本 = 控制 51% 算力的硬體 + 電力 + 機會成本
           ≈ 數十億美元 (持續攻擊)
  攻擊收益 = 雙重花費的金額

Ethereum PoS:
  攻擊成本 = 1/3 質押量被 slashed
           ≈ 100+ 億美元
  攻擊收益 = 雙重花費的金額

小型 PoS 鏈:
  攻擊成本 = 1/3 質押量被 slashed
           ≈ 可能只有數百萬美元
  ⚠️ 如果你的業務涉及超過這個金額的交易，安全性不足！
</code></pre>
<h3 id="cryptographic-finality密碼學最終性"><a class="header" href="#cryptographic-finality密碼學最終性">Cryptographic Finality（密碼學最終性）</a></h3>
<p><strong>協議層不可逆（或需懲罰超過閾值）。</strong> 這是最強的最終性保證——交易一旦被標記為 finalized，在協議規則內就絕對不可能被回滾。Tendermint 共識的即時最終性、Ethereum 的 finalized checkpoint、ZK Rollup 的 proof 被 L1 驗證通過，都屬於 Cryptographic Finality。</p>
<pre><code class="language-text">最終性強度比較:

  弱 ──────────────────────────────────────────── 強

  Soft         Economic         Cryptographic
  (可能被       (回滾成本         (協議層
   重組)        極高)             不可逆)

  │             │                │
  1 確認        6+ 確認          Finalized
  Sequencer     L1 Batch         ZK Proof
  回傳          Submitted        Verified
</code></pre>
<h3 id="各鏈最終性時間對照"><a class="header" href="#各鏈最終性時間對照">各鏈最終性時間對照</a></h3>
<div class="table-wrapper"><table><thead><tr><th>鏈</th><th>Soft Finality</th><th>Economic Finality</th><th>Cryptographic Finality</th></tr></thead><tbody>
<tr><td>Bitcoin</td><td>~10 分鐘</td><td>~60 分鐘 (6 確認)</td><td>無（機率最終性）</td></tr>
<tr><td>Ethereum</td><td>~12 秒</td><td>~6 分鐘 (1 epoch)</td><td>~12 分鐘 (2 epochs)</td></tr>
<tr><td>Solana</td><td>~400ms</td><td>~12 秒 (32 slots)</td><td>~12 秒</td></tr>
<tr><td>Cosmos (Tendermint)</td><td>~6 秒</td><td>~6 秒</td><td>~6 秒（即時最終性）</td></tr>
<tr><td>Arbitrum (Optimistic)</td><td>即時</td><td>數分鐘 (L1 batch)</td><td>~7 天 (挑戰期)</td></tr>
<tr><td>zkSync (ZK Rollup)</td><td>即時</td><td>數分鐘 (L1 batch)</td><td>數小時 (proof 驗證)</td></tr>
</tbody></table>
</div>
<p><strong>工程上的關鍵決策：</strong> 你的系統在哪個最終性層級採取行動？這個決策直接影響用戶體驗和安全性的平衡。以下是常見的業務場景對應：</p>
<pre><code class="language-text">業務場景 vs 最終性需求:

  場景                        建議最終性層級       原因
  ──────────────────────────────────────────────────────────
  前端 UI 更新               Soft Finality       用戶體驗優先
  DEX swap 確認              Soft Finality       金額通常較小
  交易所入金 (小額)          Economic Finality   平衡速度和安全
  交易所入金 (大額)          Cryptographic        資金安全第一
  跨鏈橋資產釋放             Cryptographic        歷史事故慘痛
  財務結算/對帳               Cryptographic        會計準確性
</code></pre>
<h2 id="33-重組reorg工程處理"><a class="header" href="#33-重組reorg工程處理">3.3 重組（Reorg）工程處理</a></h2>
<p>區塊重組（Reorg）是區塊鏈系統中最危險、也最容易被忽視的場景。Reorg 發生時，原本被認為有效的區塊和交易被替換為另一條分叉鏈上的區塊和交易。你的系統之前基於「已確認」交易做出的所有決策——入金、出金、清算、狀態更新——可能全部需要回滾。</p>
<h3 id="為什麼會發生-reorg"><a class="header" href="#為什麼會發生-reorg">為什麼會發生 Reorg</a></h3>
<p>Reorg 的原因有多種：</p>
<ol>
<li>
<p><strong>自然分叉：</strong> 兩個礦工/驗證者幾乎同時產生了合法的區塊，網路短暫分裂。隨著下一個區塊產生，較短的分叉被拋棄。這種 reorg 通常只有 1-2 個區塊深度，在 PoW 鏈上最常見。</p>
</li>
<li>
<p><strong>網路延遲：</strong> 區塊傳播到全網需要時間。如果某些節點因為網路延遲而暫時落後，它們可能會在收到較長鏈後切換（reorg）。</p>
</li>
<li>
<p><strong>惡意攻擊：</strong> 攻擊者秘密挖掘一條更長的鏈，然後突然公布，迫使網路重組。目的通常是雙重花費（double spend）——在公開鏈上花費代幣購買商品，然後用秘密鏈替換，使花費交易消失。</p>
</li>
<li>
<p><strong>客戶端 Bug：</strong> 不同客戶端對同一區塊的有效性判斷不一致，導致部分節點接受而部分節點拒絕某個區塊，最終在分歧解決後發生 reorg。</p>
</li>
</ol>
<pre><code class="language-text">Block N      Block N+1      Block N+2
   |             |             |
   +------A------+------B------+------C-----&gt; 主鏈
            \
             +------B'-----C'-----------&gt; 分叉鏈(短暫)
</code></pre>
<pre><code class="language-text">深度 Reorg 攻擊示例:

  公開鏈:   ...──[100]──[101]──[102]──[103]──[104]
                                                    ^
                                            交易所確認入金
  攻擊者    ...──[100]──[101']──[102']──[103']──[104']──[105']
  秘密鏈:                                                 ^
                                                   攻擊者公布
                                                   網路切換到此鏈
                                                   交易所入金被回滾!
</code></pre>
<h3 id="事件處理採可回滾模型"><a class="header" href="#事件處理採可回滾模型">事件處理採「可回滾模型」</a></h3>
<p>在工程設計上，任何基於鏈上事件觸發的業務邏輯，都必須設計為可回滾的。這意味著你不能在收到一個事件後就立刻執行不可逆的操作（如匯出法幣、發送實體商品、刪除用戶記錄）。</p>
<pre><code class="language-text">可回滾事件處理架構:

  鏈上事件 ──&gt; 事件監聽器 ──&gt; 事件資料庫 ──&gt; 業務處理器
                   │              │              │
                   │         記錄區塊高度      根據狀態
                   │         和交易 hash       決定行動
                   │              │
                   │         Reorg 偵測器 ──&gt; 標記受影響事件
                   │              │              │
                   │              └──────────&gt; 回滾業務操作
                   │
                   └── 訂閱 newHeads
                       比對 parentHash
                       偵測 reorg
</code></pre>
<p><strong>Reorg 偵測的實作方式：</strong> 最可靠的方法是追蹤每個區塊的 parentHash。當你收到一個新區塊時，檢查它的 parentHash 是否等於你記錄的前一個區塊的 hash。如果不匹配，就發生了 reorg。你需要向前回溯，找到公共祖先區塊，然後重新處理從公共祖先之後的所有區塊。</p>
<pre><code class="language-python"># 偽碼: Reorg 偵測
class ReorgDetector:
    def __init__(self):
        self.block_cache = {}  # block_number -&gt; block_hash

    def process_block(self, block):
        expected_parent = self.block_cache.get(block.number - 1)

        if expected_parent and expected_parent != block.parent_hash:
            # 偵測到 Reorg!
            reorg_depth = self.find_common_ancestor(block)
            self.handle_reorg(reorg_depth)

        self.block_cache[block.number] = block.hash

    def find_common_ancestor(self, block):
        depth = 0
        current = block
        while current.parent_hash != self.block_cache.get(current.number - 1):
            depth += 1
            current = self.rpc.get_block(current.parent_hash)
        return depth

    def handle_reorg(self, depth):
        # 1. 找出受影響的事件
        # 2. 標記這些事件為 "reorged"
        # 3. 觸發業務回滾
        # 4. 重新處理新鏈上的區塊
        alert(f"Reorg detected! Depth: {depth}")
</code></pre>
<h3 id="入帳分級"><a class="header" href="#入帳分級">入帳分級</a></h3>
<p>入帳分級是處理最終性風險的核心機制。每筆交易經歷三個狀態：</p>
<ul>
<li>
<p><strong><code>pending</code></strong>: 交易已被偵測到（在 mempool 中或被打包進 1 個區塊），但尚未達到安全確認數。系統可以顯示「處理中」，但不能基於此執行任何業務操作。</p>
</li>
<li>
<p><strong><code>confirmed(k)</code></strong>: 交易已被 k 個區塊確認。k 的值取決於鏈和金額。在此狀態下，系統可以執行低風險的業務操作（如更新顯示餘額），但高風險操作（如允許提現）仍應等待。</p>
</li>
<li>
<p><strong><code>finalized</code></strong>: 交易已達到鏈的最終性保證。在此狀態下，系統可以執行所有業務操作，包括不可逆的操作。</p>
</li>
</ul>
<pre><code class="language-text">入帳狀態機:

  ┌─────────┐    k 個區塊確認    ┌──────────────┐    Finalized    ┌───────────┐
  │ pending  │ ────────────────&gt; │ confirmed(k) │ ─────────────&gt; │ finalized │
  └─────────┘                   └──────────────┘                └───────────┘
       │                              │
       │ Reorg                        │ Reorg (罕見但可能)
       ▼                              ▼
  ┌─────────┐                   ┌──────────────┐
  │ dropped │                   │  rolled_back │
  └─────────┘                   └──────────────┘
</code></pre>
<h3 id="針對大額交易提高確認數"><a class="header" href="#針對大額交易提高確認數">針對大額交易提高確認數</a></h3>
<p>這不只是「等久一點」那麼簡單。提高確認數的策略需要考慮以下因素：</p>
<ol>
<li>
<p><strong>確認數的階梯式設計：</strong> 根據交易金額設定不同的確認數門檻。小額交易 1-2 個確認即可，中額交易需要 6 個確認，大額交易需要 12 個以上確認或等待 finalized。</p>
</li>
<li>
<p><strong>動態調整：</strong> 根據當前的鏈上環境動態調整確認數。如果鏈上正在發生 reorg（即使只是淺層的 1-block reorg），自動提高所有交易的確認數門檻。</p>
</li>
<li>
<p><strong>同一地址的關聯分析：</strong> 如果同一個地址在短時間內送入多筆中等金額的交易，總金額可能超過大額門檻。風控系統需要將這些交易作為整體評估。</p>
</li>
</ol>
<pre><code class="language-text">確認數策略示例 (Ethereum):

  金額 (ETH)     所需確認數     等待時間
  ──────────────────────────────────────
  &lt; 0.1          1 slot         ~12 秒
  0.1 - 1.0      3 slots        ~36 秒
  1.0 - 10.0     1 epoch        ~6 分鐘
  10.0 - 100.0   2 epochs       ~12 分鐘 (finalized)
  &gt; 100.0        finalized +    ~12 分鐘 + 額外等待
                 人工審核
</code></pre>
<h2 id="34-檢查點策略"><a class="header" href="#34-檢查點策略">3.4 檢查點策略</a></h2>
<p>檢查點策略是將最終性理論轉化為工程實踐的關鍵環節。不同的業務系統有不同的風險承受能力，因此需要針對性的策略設計。</p>
<h3 id="交易策略-依資產風險配置確認數"><a class="header" href="#交易策略-依資產風險配置確認數">交易策略: 依資產風險配置確認數</a></h3>
<p>不同資產的風險等級不同。主流資產（BTC、ETH）的流動性好、市場深度大，被用於雙重花費攻擊的成本較高。但低市值代幣或流動性差的 NFT 可能被攻擊者利用：在一條鏈上出售，在另一條分叉上取消出售。</p>
<pre><code class="language-text">資產風險分級:

  Tier 1 (低風險): BTC, ETH, USDC, USDT
    確認數: 標準值
    原因: 市值大、流動性好、攻擊成本高

  Tier 2 (中風險): 主流 DeFi 代幣 (UNI, AAVE, LINK)
    確認數: 標準值 × 1.5
    原因: 市值中等、可能被閃電貸操縱

  Tier 3 (高風險): 小市值代幣、新上線代幣
    確認數: 標準值 × 3 或等待 finalized
    原因: 容易被操縱、可能是詐騙代幣

  特殊: NFT
    確認數: finalized
    原因: 不可替代、價值難以評估、Wash Trading 風險
</code></pre>
<h3 id="服務策略-api-對外預設-confirmed財務結算用-finalized"><a class="header" href="#服務策略-api-對外預設-confirmed財務結算用-finalized">服務策略: API 對外預設 confirmed，財務結算用 finalized</a></h3>
<p>設計對外 API 時，需要明確定義不同端點使用的最終性層級。一個常見的設計是讓查詢類 API 使用 <code>confirmed</code> 狀態（回應更快、用戶體驗更好），而財務結算相關的 API 使用 <code>finalized</code> 狀態（安全性優先）。</p>
<pre><code class="language-text">API 最終性設計:

  GET /api/v1/balance?address=0x...
    回傳: confirmed 餘額 (最新，但可能被 reorg)
    用途: 前端顯示

  GET /api/v1/balance?address=0x...&amp;finality=finalized
    回傳: finalized 餘額 (稍舊，但確定不會變)
    用途: 交易前的餘額驗證

  POST /api/v1/settlement
    要求: 所有輸入交易必須是 finalized 狀態
    原因: 結算是不可逆操作
</code></pre>
<pre><code class="language-javascript">// 偽碼: API 最終性中間件
function finalityMiddleware(req, res, next) {
  const finality = req.query.finality || 'confirmed';

  switch (finality) {
    case 'latest':
      // 最新區塊，可能被 reorg (最快)
      req.blockTag = 'latest';
      break;
    case 'confirmed':
      // 已確認但未 finalized (預設)
      req.blockTag = 'safe';  // Ethereum 的 safe tag
      break;
    case 'finalized':
      // 已 finalized (最安全)
      req.blockTag = 'finalized';
      break;
    default:
      return res.status(400).json({ error: 'Invalid finality level' });
  }

  next();
}
</code></pre>
<h3 id="風控策略-同一地址高頻提現套用延遲機制"><a class="header" href="#風控策略-同一地址高頻提現套用延遲機制">風控策略: 同一地址高頻提現套用延遲機制</a></h3>
<p>風控策略是最終性管理的最後一道防線。即使交易已經 finalized，如果風控系統偵測到異常模式，仍然應該延遲或阻止業務操作。</p>
<p><strong>常見的異常模式：</strong></p>
<ul>
<li><strong>高頻提現：</strong> 同一地址在短時間內發起多筆提現，可能是私鑰被盜後的快速轉移。</li>
<li><strong>新地址大額入金後立即提現：</strong> 可能是雙重花費攻擊的前奏——攻擊者先入金、快速提現、然後 reorg 取消入金。</li>
<li><strong>跨鏈閃電操作：</strong> 在多條鏈上同時進行入金/提現/swap 的複雜操作，可能是套利攻擊或跨鏈 MEV。</li>
</ul>
<pre><code class="language-text">風控規則示例:

  Rule 1: 單地址高頻提現
    條件: 同一地址在 1 小時內提現次數 &gt; 5
    動作: 後續提現自動延遲 30 分鐘 + 人工審核

  Rule 2: 新地址快速提現
    條件: 地址首次入金後 &lt; 24 小時即提現
    動作: 提現需等待 finalized + 額外 6 小時冷卻期

  Rule 3: 大額入金後全額提現
    條件: 入金 &gt; $10,000 且提現金額 &gt; 入金的 90%
    動作: 強制人工審核

  Rule 4: Reorg 期間凍結
    條件: 偵測到任何深度 &gt; 1 的 reorg
    動作: 暫停所有提現，等待鏈穩定後恢復
</code></pre>
<h2 id="35-跨鏈場景的最終性挑戰"><a class="header" href="#35-跨鏈場景的最終性挑戰">3.5 跨鏈場景的最終性挑戰</a></h2>
<p>跨鏈操作將最終性問題的複雜度提升了一個數量級。你不只需要確認源鏈上的交易已經 finalized，還需要確認目標鏈上的操作也已完成。兩條鏈有不同的最終性時間、不同的 reorg 機率、不同的安全假設——這些差異的組合使得跨鏈系統的設計極為棘手。</p>
<pre><code class="language-text">跨鏈最終性時間線:

  源鏈 (Ethereum)                     目標鏈 (Arbitrum)
  ─────────────────────────────────   ──────────────────────────
  [交易送出]
  │ ~12 秒
  [Soft Finality]
  │ ~12 分鐘
  [Finalized]
  │                                   [橋合約偵測到 finalized 事件]
  │                                   │ ~數分鐘
  │                                   [目標鏈釋放資產]
  │                                   │ ~即時 (Sequencer)
  │                                   [Soft Finality]
  │                                   │ ~7 天 (如需等待 L2 finality)
  │                                   [Cryptographic Finality]

  總時間: 12 分鐘 (最低) 到 7 天 (最高安全)
</code></pre>
<p><strong>最佳實踐：</strong></p>
<ol>
<li>
<p><strong>源鏈等待 finalized 再釋放目標鏈資產。</strong> 不要為了速度而在 Soft Finality 階段就釋放——Wormhole、Ronin Bridge 的事故都與不充分的源鏈驗證有關。</p>
</li>
<li>
<p><strong>目標鏈設置速率限制。</strong> 即使源鏈驗證通過，也應該對單位時間內跨鏈轉移的金額設置上限。這樣即使橋被攻破，損失也在可控範圍內。</p>
</li>
<li>
<p><strong>實施時間延遲提款。</strong> 大額跨鏈轉移應該有冷卻期，給監控系統時間來偵測和反應。</p>
</li>
</ol>
<h2 id="36-mev-與最終性的交互影響"><a class="header" href="#36-mev-與最終性的交互影響">3.6 MEV 與最終性的交互影響</a></h2>
<p>MEV（Maximal Extractable Value，最大可提取價值）是指礦工/驗證者/排序器通過控制交易排序而獲得的額外利潤。MEV 與最終性有著密切的關係：在交易從 pending 到 finalized 的過程中，MEV 搜索者有動機嘗試重新排序、插入或移除交易。</p>
<pre><code class="language-text">MEV 影響最終性的方式:

  1. Front-running (搶跑)
     看到 mempool 中的大額 swap 交易
     在它前面插入自己的 swap
     在 Soft Finality 階段就能獲利

  2. Sandwich Attack (三明治攻擊)
     在目標交易前後各插入一筆交易
     利用目標交易造成的價格滑點獲利

  3. Time-bandit Attack (時間強盜攻擊)
     如果重組的獲利 &gt; 重組的成本
     礦工有經濟動機去嘗試 reorg
     這直接威脅了 Economic Finality 的假設!

  防禦:
  - 使用 Flashbots 等私有交易池 (不進公開 mempool)
  - 設置合理的 slippage tolerance
  - 監控 mempool 中的可疑交易模式
</code></pre>
<p><strong>Time-bandit Attack</strong> 是 MEV 與 reorg 交集中最令人擔憂的場景。如果某個區塊包含一個極其有利可圖的 MEV 機會（例如大額清算），礦工可能會試圖重組該區塊，將 MEV 收入據為己有。這意味著 Economic Finality 的安全性不只取決於算力/質押量，還取決於區塊中的 MEV 價值。如果一個區塊的 MEV 價值超過了重組的成本，理性的攻擊者就有動機去嘗試 reorg。</p>
<h2 id="白話總結-2"><a class="header" href="#白話總結-2">白話總結</a></h2>
<p>「打包進區塊」不代表 100% 定案。工程上要把「可回滾」當預設，而不是例外。這是區塊鏈系統開發中最反直覺、也最重要的心智模型轉變。在傳統後端開發中，一旦資料寫入資料庫並 commit，你可以認為它就是確定的。但在區塊鏈上，交易被打包進區塊只是「暫時有效」——它隨時可能因為區塊重組而消失。</p>
<p>不同的鏈有不同的最終性模型。Bitcoin 永遠是機率最終性，6 個確認只是讓被重組的機率低到「可接受」的程度；Ethereum 有明確的 finalized 狀態，大約 12 分鐘後交易就真正不可逆了；Solana 和 Cosmos 等鏈有接近即時的最終性，但前者的安全保障較弱。作為工程師，你需要知道每條鏈的最終性時間表，並據此設計你的入帳策略。</p>
<p>入帳分級（pending / confirmed / finalized）是處理最終性問題的標準工程範式。不要把所有交易都當成「已確認」或「未確認」的二元狀態，而是要設計一個多階段的狀態機，讓不同風險等級的業務操作在不同的最終性階段被觸發。小額入金可以在 confirmed 就讓用戶看到餘額更新，但大額提現必須等到 finalized 才能放行。風控系統則是最後一道防線，即使交易已經 finalized，異常的行為模式仍然應該觸發延遲或人工審核。記住：在區塊鏈上，過度謹慎的代價只是「慢一點」，但不夠謹慎的代價可能是「錢沒了」。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-網路資料與節點結構"><a class="header" href="#4-網路資料與節點結構">4. 網路、資料與節點結構</a></h1>
<h2 id="41-節點角色"><a class="header" href="#41-節點角色">4.1 節點角色</a></h2>
<p>區塊鏈網路中的節點並非同質，不同角色承擔不同的驗證深度與資料儲存責任。理解每種節點的成本與能力邊界，是設計高可用鏈上基礎設施的第一步。</p>
<h3 id="full-node"><a class="header" href="#full-node">Full Node</a></h3>
<p>Full Node 是區塊鏈網路中最常見也最重要的角色。它會下載並驗證自創世區塊以來的每一個區塊與交易，維護當前最新的世界狀態（state）。當一筆新交易或新區塊被收到時，Full Node 會獨立執行所有驗證規則——包括簽名驗證、Gas 計算、狀態轉換——而非單純信任其他節點的結論。</p>
<p>在 Ethereum 上，一個 Full Node（如 Geth 或 Nethermind）通常需要 1-2TB 的 SSD 儲存空間與 16GB 以上的 RAM。它會保留最近 128 個區塊的完整狀態，但不會保留更早期的歷史狀態。這意味著你可以查詢當前餘額，但無法查詢「三個月前某地址的餘額」——那是 Archive Node 的工作。</p>
<p><strong>實務考量</strong>：對於大多數 DApp 後端和交易系統，Full Node 已經足夠。但如果你的服務需要頻繁查詢歷史狀態（例如鏈上數據分析平台），則必須考慮 Archive Node。</p>
<h3 id="archive-node"><a class="header" href="#archive-node">Archive Node</a></h3>
<p>Archive Node 在 Full Node 的基礎上，額外保留了每一個區塊高度的完整世界狀態快照。這使得你可以在任意歷史區塊上執行 <code>eth_call</code>，查詢任意過去時間點的合約狀態或帳戶餘額。</p>
<p>代價是巨大的儲存需求——以 Ethereum Mainnet 為例，一個 Archive Node 的儲存量可達 12TB 以上，且持續增長。運行成本高昂，通常只有鏈上數據公司（如 Etherscan、Dune Analytics）、大型交易所和機構級量化團隊才會自行維護。</p>
<pre><code class="language-text">┌─────────────────────────────────────────────────┐
│                 Archive Node                     │
│  ┌──────────────────────────────────────────┐   │
│  │ Block N 完整狀態 (State Trie Snapshot)    │   │
│  │ Block N-1 完整狀態                        │   │
│  │ Block N-2 完整狀態                        │   │
│  │ ...                                       │   │
│  │ Block 0 (Genesis) 完整狀態                │   │
│  └──────────────────────────────────────────┘   │
│                                                  │
│  可查詢: eth_call at any block height            │
│  儲存量: 12+ TB (Ethereum Mainnet)              │
└─────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────┐
│                  Full Node                       │
│  ┌──────────────────────────────────────────┐   │
│  │ Block N 完整狀態 (最新)                   │   │
│  │ Block N-1 ~ N-128 (近期剪枝範圍)         │   │
│  └──────────────────────────────────────────┘   │
│                                                  │
│  可查詢: 僅最近 128 個區塊的狀態               │
│  儲存量: 1-2 TB                                 │
└─────────────────────────────────────────────────┘
</code></pre>
<h3 id="validator--sequencer"><a class="header" href="#validator--sequencer">Validator / Sequencer</a></h3>
<p>在 Proof of Stake 網路中，Validator 負責提議（propose）新區塊並對其他區塊進行投票（attest）。Validator 必須質押一定數量的原生代幣（如 Ethereum 要求 32 ETH），並持續在線運行。離線或惡意行為會導致 slashing（削減質押金）。</p>
<p>在 Layer 2 的 Rollup 架構中，Sequencer 扮演類似角色——它負責收集使用者交易、排定執行順序、產生 L2 區塊，並將壓縮後的交易資料提交到 L1。目前大多數 Rollup（如 Optimism、Arbitrum、Base）仍使用中心化 Sequencer，這帶來了審查抗性和活性（liveness）的擔憂，但也提供了低延遲的使用者體驗。</p>
<p><strong>案例</strong>：2023 年 Arbitrum Sequencer 曾因硬體故障離線約 1 小時，導致所有 L2 交易暫停。這凸顯了中心化 Sequencer 的單點故障風險，也推動了去中心化 Sequencer 方案（如 Espresso、Astria）的研發。</p>
<h3 id="light-client"><a class="header" href="#light-client">Light Client</a></h3>
<p>Light Client 不下載完整區塊，僅下載區塊頭（block header）。它透過 Merkle Proof 來驗證特定交易或狀態是否被包含在某個區塊中，而無需信任任何特定的全節點。</p>
<p>Light Client 的資源需求極低（可在手機或瀏覽器中運行），適合用於：</p>
<ul>
<li>行動端錢包驗證交易狀態</li>
<li>跨鏈橋驗證來源鏈的區塊合法性</li>
<li>IoT 設備上的輕量級鏈上驗證</li>
</ul>
<p>Ethereum 的 Sync Committee 機制允許 Light Client 僅追蹤一組預選驗證者的簽名即可驗證區塊頭的合法性，大幅降低了同步成本。</p>
<hr />
<h2 id="42-p2p-與-mempool"><a class="header" href="#42-p2p-與-mempool">4.2 P2P 與 Mempool</a></h2>
<h3 id="mempool-的運作機制"><a class="header" href="#mempool-的運作機制">Mempool 的運作機制</a></h3>
<p>當使用者發送一筆交易時，它不會直接進入區塊，而是先被送到節點的 mempool（memory pool）——一個存放待處理交易的暫存區。節點之間透過 P2P gossip 協議互相傳播 mempool 中的交易，使得全網節點最終都能看到這筆交易。</p>
<p>Mempool 本質上是無序的——不同節點看到交易的時間不同，本地 mempool 的內容也不完全一致。出塊者（miner 或 validator）從自己的 mempool 中選擇交易打包進區塊，選擇標準通常是 Gas Price 從高到低排序，以最大化自身收益。</p>
<pre><code class="language-text">交易廣播與 Mempool 流程：

 User A           User B           User C
   |                |                |
   v                v                v
 Node 1          Node 2           Node 3
   |                |                |
   +----gossip------+----gossip------+
   |                |                |
   v                v                v
┌──────────┐  ┌──────────┐   ┌──────────┐
│ Mempool  │  │ Mempool  │   │ Mempool  │
│ (本地)    │  │ (本地)    │   │ (本地)    │
│          │  │          │   │          │
│ Tx1: 50  │  │ Tx1: 50  │   │ Tx2: 30  │
│ Tx2: 30  │  │ Tx3: 80  │   │ Tx3: 80  │
│ Tx3: 80  │  │ Tx2: 30  │   │ Tx1: 50  │
└──────────┘  └──────────┘   └──────────┘
   (各節點 mempool 內容可能不同步)

         出塊者選擇 Gas 最高的交易優先打包
                    |
                    v
         ┌──────────────────┐
         │ Block N+1        │
         │ Tx3 (80 gwei)    │
         │ Tx1 (50 gwei)    │
         │ Tx2 (30 gwei)    │
         └──────────────────┘
</code></pre>
<h3 id="費率市場"><a class="header" href="#費率市場">費率市場</a></h3>
<p>EIP-1559 引入的費率市場將 Gas 費拆分為 base fee 和 priority fee。Base fee 由協議根據上一個區塊的填充率動態調整——如果上一個區塊超過目標容量（50%），base fee 上升；反之下降。Priority fee 則是使用者給出塊者的「小費」，用於激勵出塊者優先打包。</p>
<p>這個設計的工程意義在於：你的交易系統不能只設定一個固定 Gas Price，而必須即時追蹤 base fee 的變化並動態調整出價策略。過低的出價會導致交易長時間卡在 mempool；過高則浪費成本。</p>
<p><strong>常見陷阱</strong>：在網路極度擁堵時（如 NFT 搶購），base fee 可能在幾個區塊內暴漲數十倍。如果你的系統沒有設定 <code>maxFeePerGas</code> 的上限，可能會支付天價 Gas Fee。務必在 policy engine 中設定 Gas 費的硬上限。</p>
<h3 id="私有交易通道"><a class="header" href="#私有交易通道">私有交易通道</a></h3>
<p>公開的 mempool 是透明的，任何人都可以觀察待處理的交易。這催生了 MEV（Maximal Extractable Value）——搜尋者（searcher）觀察 mempool 中的大額交易，搶先提交更高 Gas 的同類交易以獲利（front-running）。</p>
<p>為了對抗 MEV，出現了私有交易通道的概念。例如 Flashbots Protect 允許使用者直接將交易送給 block builder，跳過公開 mempool，避免被搶跑。在 Ethereum 的 PBS（Proposer-Builder Separation）架構下，builder 從搜尋者和使用者手中收集交易，組裝成最優區塊，再競標給 proposer。</p>
<pre><code class="language-text">公開 Mempool 路徑（有 MEV 風險）：
  User --&gt; Public Mempool --&gt; Searcher 觀察 --&gt; Front-run
                          --&gt; Validator 打包

私有交易路徑（降低 MEV 風險）：
  User --&gt; Flashbots Protect --&gt; Builder --&gt; Validator
           (跳過公開 mempool)
</code></pre>
<p><strong>最佳實踐</strong>：對於高價值交易（大額 swap、清算等），務必使用私有交易通道。對於一般性交易，公開 mempool 通常足夠。</p>
<hr />
<h2 id="43-狀態資料結構"><a class="header" href="#43-狀態資料結構">4.3 狀態資料結構</a></h2>
<p>區塊鏈的核心能力之一是「可驗證的狀態」——任何人都可以獨立驗證某個帳戶的餘額或合約的狀態是否正確，而無需信任任何第三方。這依賴於精心設計的密碼學資料結構。</p>
<h3 id="merkle-tree"><a class="header" href="#merkle-tree">Merkle Tree</a></h3>
<p>最基本的結構是 Merkle Tree（默克爾樹）。它是一棵二元雜湊樹：葉節點是原始資料的雜湊值，每個內部節點是其兩個子節點雜湊值的雜湊。樹根（Merkle Root）是整棵樹的「指紋」——任何葉節點的變更都會導致根雜湊完全改變。</p>
<p>Merkle Tree 的核心價值是 <strong>包含性證明（Inclusion Proof）</strong>：要證明某筆交易被包含在區塊中，只需提供從該交易葉節點到根的路徑上的兄弟節點雜湊值（稱為 Merkle Path），而不需要提供整棵樹。驗證者可以用 O(log N) 的雜湊計算確認其正確性。</p>
<pre><code class="language-text">Merkle Tree 結構與 Inclusion Proof：

             Root Hash (存在區塊頭)
            /           \
         H(AB)          H(CD)
        /    \          /    \
     H(A)   H(B)    H(C)   H(D)    &lt;-- 葉節點 = 交易雜湊
      |       |       |       |
     TxA    TxB     TxC    TxD

要證明 TxC 存在於此區塊：
  提供: H(D), H(AB)
  驗證: H(CD) = hash(H(C), H(D))
        Root  = hash(H(AB), H(CD))  ✓

  Proof 大小: O(log N)，N = 交易數量
  4 筆交易只需 2 個雜湊 = 64 bytes
</code></pre>
<h3 id="patricia-trie-mpt"><a class="header" href="#patricia-trie-mpt">Patricia Trie (MPT)</a></h3>
<p>Ethereum 使用的是 Modified Merkle Patricia Trie（MPT），一種結合了 Patricia Trie（前綴壓縮字典樹）與 Merkle Tree 的混合結構。MPT 以帳戶地址為 key、帳戶狀態為 value，形成一個可驗證的鍵值存儲。</p>
<p>MPT 的設計使得 Ethereum 可以在區塊頭中存放三棵 trie 的根雜湊：State Trie Root（所有帳戶的狀態）、Transaction Trie Root（區塊中的交易）、Receipt Trie Root（交易執行結果）。Light Client 可以透過這些根雜湊配合 Merkle Proof 驗證任何狀態。</p>
<p>然而，MPT 在工程上有顯著的效能問題。每次狀態更新都需要重新計算從葉到根的所有雜湊值，導致大量的磁碟隨機讀寫。Ethereum 社群一直在研究替代方案——例如 Verkle Tree，它使用向量承諾（vector commitment）來大幅縮小 proof 大小。</p>
<h3 id="sparse-merkle-tree-smt"><a class="header" href="#sparse-merkle-tree-smt">Sparse Merkle Tree (SMT)</a></h3>
<p>Sparse Merkle Tree 是一棵固定深度的完全二元樹，其中大部分葉節點為空（預設值）。它的優勢是可以高效地證明某個 key <strong>不存在</strong>（non-inclusion proof），這是普通 Merkle Tree 做不到的。</p>
<p>SMT 廣泛用於 zk-Rollup 和隱私協議中。例如在 zkSync 中，SMT 用來維護 L2 的帳戶狀態樹，因為 ZK 電路需要固定大小的資料結構來生成證明。</p>
<pre><code class="language-text">各資料結構比較：

┌──────────────────┬────────────┬──────────────┬─────────────────┐
│                  │ Merkle Tree│ Patricia Trie│ Sparse Merkle   │
├──────────────────┼────────────┼──────────────┼─────────────────┤
│ Inclusion Proof  │     ✓      │      ✓       │       ✓         │
│ Non-Inclusion    │     ✗      │      ✓       │       ✓         │
│ Key-Value 查詢   │     ✗      │      ✓       │       ✓         │
│ Proof 大小       │  O(log N)  │  O(key_len)  │   O(depth)      │
│ ZK 友好          │     △      │      ✗       │       ✓         │
│ 使用場景         │ BTC 交易   │ ETH 狀態     │ zk-Rollup       │
└──────────────────┴────────────┴──────────────┴─────────────────┘
</code></pre>
<hr />
<h2 id="44-企業級節點拓撲"><a class="header" href="#44-企業級節點拓撲">4.4 企業級節點拓撲</a></h2>
<p>在生產環境中，僅運行一個節點是完全不可接受的。企業級系統需要多層次的節點拓撲來確保高可用性、低延遲和故障隔離。以下是一個典型的生產架構：</p>
<pre><code class="language-text">                   ┌──────────────┐
                   │ Load Balancer│
                   │ (L7 / gRPC) │
                   └──────┬───────┘
                          │
     ┌────────────────────┼────────────────────┐
     v                    v                    v
┌───────────┐       ┌───────────┐       ┌───────────┐
│ RPC Node A│       │ RPC Node B│       │ RPC Node C│
│ (Read)    │       │ (Read)    │       │ (Write)   │
└─────┬─────┘       └─────┬─────┘       └─────┬─────┘
      │                   │                   │
      v                   v                   v
 ┌─────────┐         ┌─────────┐         ┌─────────┐
 │Indexer A│         │Indexer B│         │Indexer C│
 │(Events) │         │(Blocks) │         │(Txns)   │
 └────┬────┘         └────┬────┘         └────┬────┘
      └──────────────┬────┴────┬──────────────┘
                     v         v
               ┌────────────────────┐
               │ Data Lake / SIEM   │
               │ (ClickHouse / ELK) │
               └─────────┬──────────┘
                          │
              ┌───────────┼───────────┐
              v           v           v
        ┌──────────┐ ┌──────────┐ ┌──────────┐
        │Dashboard │ │ Alerting │ │ Audit    │
        │(Grafana) │ │(PagerD.) │ │ Trail   │
        └──────────┘ └──────────┘ └──────────┘
</code></pre>
<h3 id="讀寫分離架構"><a class="header" href="#讀寫分離架構">讀寫分離架構</a></h3>
<p>在高流量環境中，讀取請求（查餘額、查合約狀態、查歷史交易）的量通常是寫入請求（發送交易）的 100 倍以上。因此，將讀寫流量分離到不同的 RPC 節點是基本的架構原則。</p>
<p>讀取節點可以水平擴展，並且可以容忍短暫的區塊高度延遲（例如落後 1-2 個區塊）。寫入節點則需要保持與網路的最低延遲連接，以確保交易盡快被傳播。</p>
<h3 id="多供應商策略"><a class="header" href="#多供應商策略">多供應商策略</a></h3>
<p>不要將所有流量都指向單一的 RPC 供應商（如 Alchemy、Infura、QuickNode）。2022 年和 2023 年都曾發生過主流 RPC 供應商的大面積故障事件。推薦的策略是：</p>
<pre><code class="language-text">流量分配策略：

  主要供應商 (60%)   ──→  Alchemy / Infura
  備援供應商 (30%)   ──→  QuickNode / Ankr
  自建節點   (10%)   ──→  自行維護的 Full Node

  Fallback 機制：
  1. 主要供應商 timeout &gt; 2s → 切換備援
  2. 備援供應商 timeout &gt; 2s → 切換自建
  3. 所有供應商失敗 → 觸發告警 + 暫停寫入操作
</code></pre>
<h3 id="indexer-層的設計"><a class="header" href="#indexer-層的設計">Indexer 層的設計</a></h3>
<p>原生的 RPC 介面效能不足以支撐複雜查詢（例如「列出某地址過去 30 天的所有 ERC-20 轉帳」）。Indexer 層負責將鏈上資料結構化存入傳統資料庫（PostgreSQL、ClickHouse），並提供高效的查詢 API。</p>
<p>常見的 Indexer 方案：</p>
<ul>
<li><strong>The Graph</strong>：去中心化索引協議，適合公開資料</li>
<li><strong>Goldsky / Envio</strong>：托管式索引，低延遲</li>
<li><strong>自建 Indexer</strong>：完全控制，但維護成本高。通常使用 <code>eth_subscribe</code> 或 <code>eth_getLogs</code> 監聽事件，解析後寫入資料庫</li>
</ul>
<p><strong>常見陷阱</strong>：Indexer 必須處理 <strong>chain reorganization（reorg）</strong>。當區塊鏈發生 reorg 時，已經索引的資料可能變得無效。你的 Indexer 必須有回滾機制——監測到 reorg 時，刪除被撤銷區塊的資料，重新索引新的規範鏈。</p>
<hr />
<h2 id="45-實務要點"><a class="header" href="#45-實務要點">4.5 實務要點</a></h2>
<h3 id="不依賴單一-rpc-廠商"><a class="header" href="#不依賴單一-rpc-廠商">不依賴單一 RPC 廠商</a></h3>
<p>如前所述，RPC 廠商是中心化的服務提供商，有著非零的故障概率。即使是最大的供應商，也會因為底層雲端基礎設施（AWS、GCP）的故障而中斷服務。你的系統應該實作 circuit breaker 模式——當主要 RPC 持續報錯時，自動切換到備援。</p>
<pre><code class="language-python"># Pseudocode: RPC Failover with Circuit Breaker
class RPCManager:
    def __init__(self):
        self.providers = [
            {"url": "https://eth-mainnet.alchemy.com/v2/KEY", "weight": 60},
            {"url": "https://mainnet.infura.io/v3/KEY",       "weight": 30},
            {"url": "http://localhost:8545",                    "weight": 10},
        ]
        self.circuit_breaker = {}  # provider -&gt; failure_count

    def call(self, method, params):
        for provider in self.get_healthy_providers():
            try:
                result = rpc_call(provider["url"], method, params)
                self.circuit_breaker[provider["url"]] = 0
                return result
            except TimeoutError:
                self.circuit_breaker[provider["url"]] += 1
                if self.circuit_breaker[provider["url"]] &gt; 5:
                    self.mark_unhealthy(provider)
                continue
        raise AllProvidersDown("所有 RPC 供應商不可用")
</code></pre>
<h3 id="讀寫流量分離"><a class="header" href="#讀寫流量分離">讀寫流量分離</a></h3>
<p>對於寫入交易，延遲至關重要——你希望交易盡快被廣播到 mempool。使用與出塊者地理位置接近的節點，或直接與 builder 建立連接。</p>
<p>對於讀取操作，吞吐量更重要。可以使用 CDN 或快取層（Redis）來緩存常見查詢結果（如代幣價格、帳戶餘額），設定適當的 TTL（例如每 12 秒——一個區塊時間——過期一次）。</p>
<h3 id="區塊高度一致性監控"><a class="header" href="#區塊高度一致性監控">區塊高度一致性監控</a></h3>
<p>當你使用多個 RPC 節點時，它們可能處在不同的區塊高度。如果一個請求讀取了 Node A（block 1000）的狀態，緊接著的另一個請求被路由到 Node B（block 998），使用者可能會看到「餘額倒退」的詭異現象。</p>
<p>解法是持續監控所有節點的區塊高度，並在 Load Balancer 層過濾掉落後過多的節點：</p>
<pre><code class="language-text">區塊高度監控：

  Node A: block 19,234,567  ✓ (最新)
  Node B: block 19,234,566  ✓ (落後 1 塊，可接受)
  Node C: block 19,234,560  ✗ (落後 7 塊，暫時移出)

  閾值設定：
  - 讀取請求: 容忍落後 ≤ 3 塊
  - 寫入請求: 僅使用最新區塊的節點
  - 落後 &gt; 10 塊: 觸發告警
</code></pre>
<h3 id="延遲尖峰與-fork-告警"><a class="header" href="#延遲尖峰與-fork-告警">延遲尖峰與 Fork 告警</a></h3>
<p>RPC 延遲的突然上升通常是問題的先兆——可能是節點同步落後、網路擁堵、或供應商基礎設施出問題。建立延遲的 P99 基線，當偏離超過 2 倍時觸發告警。</p>
<p>鏈上 fork（分叉）則是更嚴重的事件。當你的節點報告不同的區塊雜湊時，表示可能發生了 reorg。你的系統應該暫停依賴最近幾個區塊狀態的關鍵操作（如確認入金），等待 fork 解決。</p>
<p><strong>最佳實踐清單</strong>：</p>
<ul>
<li>監控每個 RPC 供應商的 P50 / P95 / P99 延遲</li>
<li>設定區塊高度偏差告警（跨節點差異 &gt; 3 塊）</li>
<li>監控 mempool 交易的 pending 時間</li>
<li>追蹤 reorg 深度和頻率</li>
<li>為關鍵告警設定 PagerDuty / Opsgenie 自動呼叫</li>
</ul>
<hr />
<h2 id="白話總結-3"><a class="header" href="#白話總結-3">白話總結</a></h2>
<p>節點是你整個區塊鏈系統的地基，地基不穩，上面蓋什麼都會倒。不同類型的節點有不同的用途：Full Node 用來驗證最新狀態，Archive Node 用來查歷史，Validator 用來出塊，Light Client 用來在資源有限的環境做輕量驗證。在生產環境中，你絕對不能只靠一個節點或一家 RPC 供應商——你需要多節點、多供應商、讀寫分離的架構，外加完善的監控和告警。交易進入 mempool 後不是你能控制的，但你可以透過私有交易通道來降低被 MEV 搜尋者狙擊的風險。底層的資料結構（Merkle Tree、Patricia Trie）是讓區塊鏈能「無信任驗證」的數學基礎，理解它們有助於你判斷 proof 驗證的成本與限制。最後，永遠記得處理 chain reorg——你的 Indexer 和確認邏輯必須能回滾，否則在 reorg 發生時會產生錯誤的業務判斷。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-錢包金鑰與簽名流程"><a class="header" href="#5-錢包金鑰與簽名流程">5. 錢包、金鑰與簽名流程</a></h1>
<h2 id="51-錢包類型"><a class="header" href="#51-錢包類型">5.1 錢包類型</a></h2>
<p>錢包是使用者與區塊鏈互動的入口，但從工程角度來看，它不是「存放資產的容器」，而是「控制簽名權限的系統」。資產永遠在鏈上，錢包只是持有能夠移動這些資產的私鑰。不同類型的錢包在安全性、便利性和可程式性之間做出不同的權衡。</p>
<h3 id="eoaexternally-owned-account"><a class="header" href="#eoaexternally-owned-account">EOA（Externally Owned Account）</a></h3>
<p>EOA 是最傳統的錢包形式——由一把私鑰直接控制的帳戶。私鑰透過 ECDSA（Elliptic Curve Digital Signature Algorithm）在 secp256k1 曲線上進行簽名，公鑰經 Keccak-256 雜湊後取最後 20 bytes 作為地址。</p>
<p>EOA 的優點是簡單直接：一把 key 對應一個地址，簽名邏輯在鏈下完成，不消耗額外的 Gas。但它的致命缺陷是<strong>單點故障</strong>——私鑰丟失意味著永久失去帳戶控制權，私鑰洩漏則意味著所有資產可被立即轉走，且無法撤銷。</p>
<pre><code class="language-text">EOA 的金鑰衍生流程：

  隨機種子 (256 bits entropy)
       |
       v
  助記詞 (BIP-39, 12/24 words)
       |
       v
  Master Seed (BIP-32)
       |
       v
  HD Key Derivation (BIP-44 路徑: m/44'/60'/0'/0/n)
       |
       v
  Private Key (256 bits)
       |
       v
  Public Key = privateKey * G  (secp256k1 橢圓曲線乘法)
       |
       v
  Address = keccak256(publicKey)[12:32]  (取後 20 bytes)
</code></pre>
<p><strong>常見陷阱</strong>：很多開發者在測試環境使用明文私鑰，然後不小心將其 commit 到 Git。一旦私鑰出現在公開的 GitHub 倉庫中，機器人會在數秒內掃描到並轉走所有資產。永遠使用環境變數或 secrets manager 管理私鑰。</p>
<h3 id="smart-contract-walletaccount-abstraction"><a class="header" href="#smart-contract-walletaccount-abstraction">Smart Contract Wallet（Account Abstraction）</a></h3>
<p>Smart Contract Wallet 將錢包的控制邏輯從協議層移到了智慧合約層。ERC-4337（Account Abstraction）標準允許開發者定義任意的驗證邏輯——例如：多簽（3/5 簽名才能執行）、社交恢復（指定的朋友可以幫你重設簽名者）、每日轉帳額度限制、Gas 代付（paymaster 替使用者付 Gas）。</p>
<p>這是 Web3 使用者體驗的重大突破。傳統 EOA 要求使用者自行保管助記詞——對於非技術使用者來說，這是極高的心理和認知門檻。Smart Contract Wallet 則可以實現「用 email 登入」、「用手機指紋驗證交易」等接近 Web2 的體驗。</p>
<pre><code class="language-text">ERC-4337 Account Abstraction 架構：

  User                     Bundler                  EntryPoint Contract
   |                         |                           |
   |  1. 建構 UserOperation  |                           |
   |─────────────────────────&gt;                           |
   |                         |  2. 打包多筆 UserOp       |
   |                         |──────────────────────────&gt;|
   |                         |                           |
   |                         |  3. 逐一驗證 &amp; 執行       |
   |                         |                           |
   |                         |     ┌─────────────────┐   |
   |                         |     │ Smart Contract  │   |
   |                         |     │ Wallet          │   |
   |                         |     │                 │   |
   |                         |     │ validateUserOp()│&lt;──|
   |                         |     │ execute()       │&lt;──|
   |                         |     └─────────────────┘   |
   |                         |                           |
   |                         |     ┌─────────────────┐   |
   |                         |     │ Paymaster       │   |
   |                         |     │ (可選: 代付Gas) │&lt;──|
   |                         |     └─────────────────┘   |
</code></pre>
<p><strong>案例</strong>：Safe（前 Gnosis Safe）是目前最廣泛使用的多簽 Smart Contract Wallet，管理著超過 1000 億美元的鏈上資產。它要求 M-of-N 的簽名才能執行交易，大幅降低了單一金鑰被盜的風險。許多 DAO treasury、協議金庫、和機構投資者都使用 Safe 作為資產保管方案。</p>
<h3 id="mpc-wallet"><a class="header" href="#mpc-wallet">MPC Wallet</a></h3>
<p>MPC（Multi-Party Computation）Wallet 使用密碼學中的多方計算技術，將一把私鑰拆分為多個分片（key shares），分散存儲在不同的參與方。簽名時，各方使用自己的分片進行協同計算，產出合法的簽名，但<strong>完整的私鑰從未在任何單一地點被重建</strong>。</p>
<p>與多簽合約不同，MPC 簽名在鏈上看起來就是一個普通的 ECDSA 簽名——Gas 成本與 EOA 相同，且不依賴特定鏈的智慧合約支持。這使得 MPC Wallet 天然具有跨鏈能力。</p>
<pre><code class="language-text">MPC 簽名 vs 多簽合約比較：

┌─────────────────────┬──────────────────┬────────────────────┐
│                     │ MPC Wallet       │ Multisig Contract  │
├─────────────────────┼──────────────────┼────────────────────┤
│ 鏈上可見性          │ 普通 EOA 簽名    │ 合約呼叫           │
│ Gas 成本            │ 與 EOA 相同      │ 較高 (合約執行)    │
│ 跨鏈支持            │ 天然支持         │ 需每條鏈部署       │
│ 金鑰恢復            │ 依賴分片備份     │ 合約可實作恢復     │
│ 審計可見性          │ 鏈上不可見       │ 鏈上完全透明       │
│ 適用場景            │ 交易所/機構      │ DAO/協議金庫       │
└─────────────────────┴──────────────────┴────────────────────┘
</code></pre>
<p>主流 MPC 方案供應商包括 Fireblocks、Fordefi、Copper。需要注意的是，MPC 的安全性依賴於分片的分散保管——如果所有分片都存在同一家雲端供應商的不同帳號下，安全性並沒有本質提升。</p>
<h3 id="hardware-wallet"><a class="header" href="#hardware-wallet">Hardware Wallet</a></h3>
<p>Hardware Wallet（如 Ledger、Trezor）將私鑰儲存在專用的安全晶片（Secure Element）中。私鑰在晶片內生成，永遠不會離開晶片。所有簽名運算都在晶片內部完成，外部裝置只能向晶片發送「請簽名這份資料」的請求，並接收簽名結果。</p>
<p>這種物理隔離提供了最強的私鑰保護——即使使用者的電腦被惡意軟體完全控制，攻擊者也無法提取私鑰。但 Hardware Wallet 的限制也很明顯：簽名速度慢（需要人工按鍵確認）、不適合高頻自動化交易、設備本身可能丟失或損壞。</p>
<p><strong>最佳實踐</strong>：Hardware Wallet 最適合作為多簽方案中的一把 key，用於保護大額資產的冷存儲。將它與 MPC 或 Smart Contract Wallet 結合使用，可以兼顧安全性和便利性。</p>
<hr />
<h2 id="52-金鑰管理層級"><a class="header" href="#52-金鑰管理層級">5.2 金鑰管理層級</a></h2>
<p>在企業級的資金管理系統中，不是所有的錢都應該放在同一個地方。根據資金用途、存取頻率和風險承受度，金鑰管理通常分為三個層級。</p>
<h3 id="熱錢包hot-wallet"><a class="header" href="#熱錢包hot-wallet">熱錢包（Hot Wallet）</a></h3>
<p>熱錢包的私鑰存在聯網的伺服器上，可以即時自動簽名。適合小額、高頻的操作，例如：交易所的使用者提幣（小額自動審核）、DApp 後端的 Gas 費支付、自動化做市策略的交易執行。</p>
<p>熱錢包的風險最高——伺服器被入侵就等於私鑰被盜。因此，熱錢包中應該只保留業務運轉所需的最小資金量，並設定嚴格的單筆和單日轉帳上限。</p>
<pre><code class="language-text">熱錢包安全防護架構：

┌─────────────────────────────────────────┐
│              Hot Wallet 環境             │
│                                         │
│  ┌──────────┐    ┌──────────────────┐   │
│  │ Private  │    │ Policy Engine    │   │
│  │ Key      │    │                  │   │
│  │ (KMS/HSM)│    │ - 單筆上限: $5K │   │
│  │          │    │ - 日額上限: $50K │   │
│  └──────────┘    │ - 白名單地址     │   │
│       │          │ - 速率限制       │   │
│       v          └────────┬─────────┘   │
│  ┌──────────┐             │             │
│  │ Signer   │&lt;────────────┘             │
│  │ Service  │  policy check passed      │
│  └──────────┘                           │
│                                         │
│  監控: 餘額低於閾值 → 自動從溫錢包補充  │
└─────────────────────────────────────────┘
</code></pre>
<h3 id="溫錢包warm-wallet"><a class="header" href="#溫錢包warm-wallet">溫錢包（Warm Wallet）</a></h3>
<p>溫錢包介於熱與冷之間。私鑰可能存在受保護的環境中（如 HSM、AWS KMS、或 MPC 分片），但需要半自動的審核流程才能動用。典型場景：定期（例如每小時）從溫錢包向熱錢包補充資金、中等金額的轉帳需要 2/3 管理員審批。</p>
<p>溫錢包的設計目標是在安全和效率之間取得平衡。它不像冷錢包那樣需要完全離線操作（耗時且不方便），但比熱錢包多了一層人工審核的保護。</p>
<h3 id="冷錢包cold-wallet"><a class="header" href="#冷錢包cold-wallet">冷錢包（Cold Wallet）</a></h3>
<p>冷錢包的私鑰完全離線——可能存在 Hardware Wallet 中、寫在紙上（paper wallet）、或存在離線電腦的加密分割區中。動用冷錢包需要完整的操作流程：在離線環境中簽名 → 將簽名後的交易透過 USB 或 QR Code 傳輸到聯網設備 → 廣播上鏈。</p>
<pre><code class="language-text">三層金鑰管理架構：

       安全性                        便利性
        高                            低
         │    ┌──────────────────┐     │
         │    │  冷錢包          │     │
         │    │  離線簽名        │     │
         │    │  大額保管 (90%)  │     │
         │    │  多簽 + 延遲     │     │
         │    └────────┬─────────┘     │
         │             │ (人工觸發)     │
         │    ┌────────v─────────┐     │
         │    │  溫錢包          │     │
         │    │  半自動簽核      │     │
         │    │  中額調度 (8%)   │     │
         │    │  審批 + HSM      │     │
         │    └────────┬─────────┘     │
         │             │ (定時補充)     │
         │    ┌────────v─────────┐     │
         │    │  熱錢包          │     │
         │    │  線上自動簽名    │     │
         │    │  小額快取 (2%)   │     │
         │    │  策略引擎限制    │     │
         │    └──────────────────┘     │
        低                            高
</code></pre>
<p><strong>案例</strong>：2022 年 Ronin Bridge 被盜 6.25 億美元，根本原因之一就是金鑰管理層級不當——9 把驗證者私鑰中有 4 把由同一個組織控制，且安全防護不足。攻擊者只需要突破一個組織的安全就能取得足夠的簽名門檻。這個事件深刻教訓了業界：多簽的 key 必須由真正獨立的實體持有，否則「多簽」只是形式。</p>
<hr />
<h2 id="53-簽名流程"><a class="header" href="#53-簽名流程">5.3 簽名流程</a></h2>
<p>一筆交易從使用者意圖到最終上鏈，需要經過多個關卡。完善的簽名流程不是「收到請求就簽」，而是一個包含策略檢查、模擬驗證和風控攔截的完整流水線。</p>
<pre><code class="language-text">完整簽名流程：

User Intent (使用者意圖)
   |
   v
┌──────────────────────────────────────────────┐
│ 1. Policy Engine (策略引擎)                   │
│    - 額度檢查: 單筆/單日是否超限?             │
│    - 白名單檢查: 目標地址是否在許可名單?      │
│    - 時間窗檢查: 是否在允許的操作時間內?       │
│    - 頻率檢查: 短時間內是否異常密集?           │
│    - 合規檢查: 目標地址是否被制裁?             │
│                                               │
│    結果: Allow / Deny / Require Approval       │
└──────────────────────┬───────────────────────┘
                       │ (Allow)
                       v
┌──────────────────────────────────────────────┐
│ 2. Transaction Builder (交易建構)             │
│    - 設定 nonce (避免重複或跳號)               │
│    - 估算 Gas (eth_estimateGas)               │
│    - 編碼 calldata (ABI encoding)             │
│    - 設定 EIP-1559 費用參數                    │
└──────────────────────┬───────────────────────┘
                       │
                       v
┌──────────────────────────────────────────────┐
│ 3. Simulation (交易模擬)                      │
│    - eth_call 模擬執行結果                     │
│    - 預測 token 餘額變化                       │
│    - 檢查是否會 revert                         │
│    - 估算實際 Gas 消耗                         │
│    - 第三方模擬 (Tenderly / Blocknative)       │
└──────────────────────┬───────────────────────┘
                       │
                       v
┌──────────────────────────────────────────────┐
│ 4. Risk Check (風控檢查)                      │
│    - 模擬結果是否符合預期?                     │
│    - 滑點是否在容忍範圍內?                     │
│    - 是否涉及已知的釣魚合約?                   │
│    - Gas 費是否異常高?                         │
└──────────────────────┬───────────────────────┘
                       │ (Pass)
                       v
┌──────────────────────────────────────────────┐
│ 5. Signer (簽名)                              │
│    - EOA: 直接 ECDSA 簽名                     │
│    - MPC: 協同計算產出簽名                     │
│    - Multisig: 收集 M-of-N 簽名               │
│    - Hardware: 傳送到硬體設備簽名              │
└──────────────────────┬───────────────────────┘
                       │
                       v
┌──────────────────────────────────────────────┐
│ 6. Broadcast &amp; Monitor (廣播與追蹤)           │
│    - 送入 mempool 或私有通道                   │
│    - 監控 pending → included → confirmed      │
│    - 必要時 speed up (重送更高 Gas)            │
│    - 必要時 cancel (送同 nonce 的空交易)       │
└──────────────────────────────────────────────┘
</code></pre>
<h3 id="nonce-管理的工程細節"><a class="header" href="#nonce-管理的工程細節">Nonce 管理的工程細節</a></h3>
<p>Nonce 是帳戶的交易序號，從 0 開始，每筆成功交易加 1。Nonce 管理是交易系統中最容易出問題的地方之一。</p>
<pre><code class="language-python"># Pseudocode: Nonce Manager with Local Tracking
class NonceManager:
    def __init__(self, address, rpc):
        self.address = address
        self.rpc = rpc
        self.local_nonce = None
        self.lock = asyncio.Lock()

    async def get_next_nonce(self):
        async with self.lock:
            if self.local_nonce is None:
                # 初始化: 從鏈上取得 pending nonce
                self.local_nonce = await self.rpc.get_transaction_count(
                    self.address, "pending"
                )
            else:
                self.local_nonce += 1
            return self.local_nonce

    async def reset_nonce(self):
        """當交易被 drop 或系統重啟時，重新從鏈上同步"""
        async with self.lock:
            self.local_nonce = None
</code></pre>
<p><strong>常見陷阱</strong>：</p>
<ul>
<li><strong>Nonce 跳號</strong>：如果 nonce=5 的交易被 drop，nonce=6 及以後的交易都會卡住。解法是重新發送 nonce=5 的交易（可以是原交易或空交易）。</li>
<li><strong>並發衝突</strong>：多個線程同時取得相同 nonce，只有一筆會成功。解法是使用 mutex lock 或 nonce 分配器。</li>
<li><strong>系統重啟</strong>：重啟後本地 nonce 計數器歸零，必須從鏈上重新同步 pending nonce。</li>
</ul>
<hr />
<h2 id="54-常見錯誤"><a class="header" href="#54-常見錯誤">5.4 常見錯誤</a></h2>
<h3 id="未綁定-chain-id-導致-replay-風險"><a class="header" href="#未綁定-chain-id-導致-replay-風險">未綁定 Chain ID 導致 Replay 風險</a></h3>
<p>Chain ID 是區分不同區塊鏈網路的標識符（Ethereum Mainnet = 1, Polygon = 137, Arbitrum = 42161）。EIP-155 要求交易簽名中包含 chain ID，以防止同一筆簽名在不同鏈上被重播。</p>
<p>如果你的簽名程式碼沒有正確綁定 chain ID，攻擊者可以將你在測試網上簽的交易拿到主網重播（前提是地址和 nonce 匹配）。在多鏈環境中（你的系統同時支援 Ethereum、Polygon、Arbitrum），這個風險尤其顯著。</p>
<pre><code class="language-text">Replay Attack 範例：

  使用者在 Goerli 測試網簽署一筆 1 ETH 轉帳
  簽名中未包含 chain ID
       |
       v
  攻擊者取得簽名後的交易原始資料
       |
       v
  在 Ethereum Mainnet 廣播相同交易
       |
       v
  如果 nonce 和餘額匹配 → 交易成功執行
  使用者損失 1 ETH (主網)

  防禦: 永遠在簽名中包含 chain ID (EIP-155)
</code></pre>
<h3 id="盲簽blind-signing未驗證-calldata"><a class="header" href="#盲簽blind-signing未驗證-calldata">盲簽（Blind Signing）未驗證 Calldata</a></h3>
<p>盲簽是指簽名者在不理解交易內容的情況下直接簽名。這在技術上等同於簽了一份你沒讀過的合約。常見場景：Hardware Wallet 的螢幕太小，只顯示「確認交易？」而不顯示完整的交易內容；後端服務自動簽名時沒有解碼和驗證 calldata。</p>
<p>攻擊者可以構造一筆看似正常但實際將所有代幣 approve 給攻擊者地址的交易。如果簽名者未驗證 calldata 就盲簽，資產就會被盜。</p>
<p><strong>防禦措施</strong>：在簽名前，對 calldata 進行 ABI 解碼，將函式名稱和參數以人類可讀的形式呈現給簽名者確認。使用 EIP-712 typed data 進行結構化簽名，讓簽名者能清楚看到自己在簽什麼。</p>
<h3 id="權限分離不足"><a class="header" href="#權限分離不足">權限分離不足</a></h3>
<p>很多團隊在早期為了開發方便，讓營運帳號（用於部署合約、調參數）同時也是資金管理帳號。這意味著一個營運工程師的機器被入侵，就可以直接轉走金庫中的所有資金。</p>
<p>正確的做法是嚴格分離角色：</p>
<ul>
<li><strong>部署者帳號</strong>：只有部署合約的權限，無法操作資金</li>
<li><strong>管理者帳號</strong>：只能修改合約參數（如費率、白名單），使用 Timelock</li>
<li><strong>資金帳號</strong>：多簽控制，任何轉帳需要多方審批</li>
</ul>
<pre><code class="language-text">權限分離架構：

  ┌────────────┐   ┌────────────┐   ┌────────────┐
  │ Deployer   │   │ Admin      │   │ Treasury   │
  │ (1-of-1)   │   │ (2-of-3)   │   │ (3-of-5)   │
  └─────┬──────┘   └─────┬──────┘   └─────┬──────┘
        │                │                │
        v                v                v
   部署合約         修改參數          資金轉移
   (一次性)      (Timelock 48h)    (多簽 + 延遲)
</code></pre>
<hr />
<h2 id="55-防護實務"><a class="header" href="#55-防護實務">5.5 防護實務</a></h2>
<h3 id="eip-712-typed-data"><a class="header" href="#eip-712-typed-data">EIP-712 Typed Data</a></h3>
<p>EIP-712 定義了一套結構化資料簽名的標準。與直接簽名原始 bytes 不同，EIP-712 要求將待簽資料組織成具有明確類型定義的結構體，並包含 domain separator（域分隔符）以防止跨合約重播。</p>
<pre><code class="language-solidity">// EIP-712 Typed Data 範例 (Solidity)
bytes32 constant PERMIT_TYPEHASH = keccak256(
    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
);

// Domain Separator 包含:
// - name: 合約名稱
// - version: 版本
// - chainId: 鏈 ID
// - verifyingContract: 合約地址
bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(
    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
    keccak256("MyToken"),
    keccak256("1"),
    block.chainid,
    address(this)
));
</code></pre>
<p>錢包（如 MetaMask）會將 EIP-712 的結構化資料以人類可讀的形式呈現給使用者，而非一串不明所以的 hex 字串。這大幅降低了盲簽風險。</p>
<h3 id="簽名前可視化解碼與模擬"><a class="header" href="#簽名前可視化解碼與模擬">簽名前可視化解碼與模擬</a></h3>
<p>在簽名之前，應該對交易進行兩層驗證：</p>
<ol>
<li><strong>靜態解碼</strong>：將 calldata 用 ABI 解碼，顯示函式名稱和參數。例如：<code>transfer(0xAbC..., 1000000)</code> → 「轉帳 1 USDC 到地址 0xAbC...」</li>
<li><strong>動態模擬</strong>：使用 <code>eth_call</code> 或第三方模擬服務（Tenderly、Blowfish）模擬交易執行結果，預測代幣餘額的變化、顯示潛在的風險提示</li>
</ol>
<pre><code class="language-text">簽名前驗證流程：

  原始交易:
    to: 0x1234...
    data: 0xa9059cbb000000000000000000000000abcdef...00000000000000000000000000000f4240

  靜態解碼:
    函式: transfer(address to, uint256 amount)
    參數: to = 0xAbCdEf...
          amount = 1000000 (= 1 USDC, 6 decimals)

  動態模擬:
    發送者 USDC 餘額: 5000 → 4999
    接收者 USDC 餘額: 100 → 101
    Gas 消耗: ~65,000
    風險等級: 低 ✓

  ↓ 驗證通過後才送給 Signer
</code></pre>
<h3 id="資金動作必須多簽--延遲--監控"><a class="header" href="#資金動作必須多簽--延遲--監控">資金動作必須多簽 + 延遲 + 監控</a></h3>
<p>對於涉及大額資金的操作（金庫提領、合約升級、參數修改），應該實施三層防護：</p>
<ol>
<li><strong>多簽（Multisig）</strong>：至少 3/5 或 4/7 的簽名才能執行</li>
<li><strong>時間鎖（Timelock）</strong>：交易提交後需要等待一段時間（如 24-48 小時）才能執行，給團隊足夠的時間檢查和取消可疑操作</li>
<li><strong>即時監控</strong>：所有大額操作應觸發即時告警（Telegram Bot、Slack、PagerDuty），安全團隊可以在 timelock 期間審查並決定是否取消</li>
</ol>
<pre><code class="language-text">大額資金操作防護流水線：

  提交交易 → Multisig 收集簽名 (3/5)
                    │
                    v
            Timelock Queue (48h 等待)
                    │
                    ├── 期間: 監控系統告警通知安全團隊
                    ├── 期間: 社群可檢視待執行操作
                    ├── 如可疑: Guardian 可取消交易
                    │
                    v (48h 後)
            Execute 執行交易
                    │
                    v
            事後審計 + 日誌記錄
</code></pre>
<p><strong>案例</strong>：許多 DeFi 協議的重大安全事件都發生在合約升級環節。Timelock 的設計目的就是為了給社群和安全研究者一個「緩衝期」——如果升級的新合約包含惡意邏輯，在 timelock 期間就會被發現和阻止。</p>
<hr />
<h2 id="白話總結-4"><a class="header" href="#白話總結-4">白話總結</a></h2>
<p>錢包不是一個存錢的 App，它的本質是控制私鑰的系統——誰控制了私鑰，誰就控制了鏈上的資產。EOA 最簡單但風險最大，一把 key 丟了或洩漏就什麼都沒了。Smart Contract Wallet 可以加上多簽、額度限制、社交恢復等機制，是目前 Web3 UX 改善的主力方向。MPC Wallet 把私鑰拆成碎片分散保管，適合交易所和機構使用。在企業環境中，資金必須按照熱、溫、冷三層管理：日常營運用的小錢放熱錢包（自動簽名），中等金額放溫錢包（半自動審批），大額資產放冷錢包（離線多簽）。簽名不是收到請求就直接簽——正確的流程是先過策略引擎（檢查額度、白名單、時間窗），再模擬交易結果（確認不會 revert、不會被釣魚），最後才交給 Signer 簽名。最後，永遠記得三件事：綁定 chain ID 防止跨鏈重播、解碼 calldata 拒絕盲簽、大額操作必須多簽加時間鎖加監控。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-交易生命週期與-gas-市場"><a class="header" href="#6-交易生命週期與-gas-市場">6. 交易生命週期與 Gas 市場</a></h1>
<h2 id="61-生命週期"><a class="header" href="#61-生命週期">6.1 生命週期</a></h2>
<p>一筆區塊鏈交易從構思到最終確認，會經歷多個明確的階段。每個階段都有可能出錯，你的系統必須能夠追蹤和處理每一個狀態。以下是 EVM 鏈上交易的完整生命週期。</p>
<h3 id="1-建構交易nonce--gas--data--value"><a class="header" href="#1-建構交易nonce--gas--data--value">1. 建構交易（nonce / gas / data / value）</a></h3>
<p>交易建構是第一步，你需要組裝一個包含以下欄位的交易物件：</p>
<ul>
<li><strong>nonce</strong>：發送者帳戶的交易序號，必須嚴格遞增。查詢方式：<code>eth_getTransactionCount(address, "pending")</code></li>
<li><strong>to</strong>：目標地址。合約呼叫時是合約地址，部署合約時為 null</li>
<li><strong>value</strong>：轉帳的 ETH 數量（以 wei 為單位，1 ETH = 10^18 wei）</li>
<li><strong>data</strong>：合約呼叫時的 calldata（ABI 編碼後的函式選擇器 + 參數），純轉帳時可為空</li>
<li><strong>gasLimit</strong>：本次交易最多可消耗的 Gas 上限</li>
<li><strong>maxFeePerGas</strong> / <strong>maxPriorityFeePerGas</strong>：EIP-1559 的費用參數</li>
</ul>
<pre><code class="language-python"># Pseudocode: 交易建構範例
tx = {
    "chainId": 1,                          # Ethereum Mainnet
    "nonce": await get_nonce(sender),       # 當前帳戶 nonce
    "to": "0xdAC17F958D2ee523a2206206994597C13D831ec7",  # USDT 合約
    "value": 0,                            # 不轉 ETH
    "data": encode_abi(                    # ABI 編碼
        "transfer(address,uint256)",
        [recipient, amount]
    ),
    "maxFeePerGas": base_fee * 2 + priority_fee,
    "maxPriorityFeePerGas": priority_fee,
    "gas": estimated_gas * 1.2,            # 留 20% 緩衝
}
</code></pre>
<p><strong>常見陷阱</strong>：<code>gasLimit</code> 設太低會導致 out of gas（交易失敗但 Gas 照扣），設太高不會多收費（只收實際消耗量），但會佔用區塊空間，影響打包優先度。建議使用 <code>eth_estimateGas</code> 的結果乘以 1.1-1.2 的安全係數。</p>
<h3 id="2-本地或服務端模擬"><a class="header" href="#2-本地或服務端模擬">2. 本地或服務端模擬</a></h3>
<p>在簽名和廣播之前，應該先用 <code>eth_call</code> 模擬交易的執行結果。模擬會在 EVM 中「假裝」執行這筆交易，返回執行結果或錯誤資訊，但不會真的改變鏈上狀態。</p>
<p>模擬的價值在於：</p>
<ul>
<li><strong>避免浪費 Gas</strong>：如果交易會 revert，模擬會提前告訴你，省去上鏈後才發現失敗的成本</li>
<li><strong>預測結果</strong>：可以看到代幣餘額的變化，確認交易行為符合預期</li>
<li><strong>安全檢查</strong>：模擬可以偵測到一些詐騙合約（例如只能買不能賣的 token）</li>
</ul>
<pre><code class="language-text">模擬流程：

  建構好的交易 (unsigned)
        │
        v
  ┌─────────────────────────────┐
  │ eth_call (模擬)              │
  │                             │
  │ 成功 → 返回執行結果          │
  │   - return data             │
  │   - gas used                │
  │   - state changes (trace)   │
  │                             │
  │ 失敗 → 返回 revert reason   │
  │   - "insufficient balance"  │
  │   - "slippage too high"     │
  │   - custom error bytes      │
  └──────────────┬──────────────┘
                 │
        ┌────────┴────────┐
        v                 v
   模擬成功            模擬失敗
   → 進入簽名          → 停止，調查原因
</code></pre>
<p><strong>進階工具</strong>：Tenderly、Blocknative 等第三方服務提供更詳細的模擬結果，包括完整的 execution trace、state diff、event logs，甚至可以模擬多筆交易的組合執行效果。</p>
<h3 id="3-簽名"><a class="header" href="#3-簽名">3. 簽名</a></h3>
<p>使用私鑰對序列化後的交易資料進行 ECDSA 簽名，產出 <code>v</code>, <code>r</code>, <code>s</code> 三個值。簽名後的交易可以被任何節點驗證——只要從簽名中恢復出的公鑰對應的地址與 <code>from</code> 欄位一致即可。</p>
<p>簽名是不可逆的——一旦你簽了一筆交易，任何人拿到這個簽名後的交易都可以廣播上鏈。因此，簽名前的所有檢查（策略、模擬、風控）都必須在簽名之前完成。</p>
<h3 id="4-廣播到-mempool"><a class="header" href="#4-廣播到-mempool">4. 廣播到 Mempool</a></h3>
<p>簽名後的交易透過 <code>eth_sendRawTransaction</code> 發送到 RPC 節點，節點會進行初步驗證（簽名正確、nonce 合法、餘額足夠支付 Gas）後放入本地 mempool，並透過 P2P 網路傳播給其他節點。</p>
<p>這個階段的風險是<strong>交易被觀察和搶跑</strong>。任何人都可以訂閱 <code>pending transactions</code>，觀察你的交易內容。如果你的交易是一筆有利可圖的 DeFi 操作（如大額 swap），MEV 搜尋者可能會搶先執行類似交易來獲利。</p>
<h3 id="5-打包出塊"><a class="header" href="#5-打包出塊">5. 打包出塊</a></h3>
<p>出塊者（validator）從 mempool 中選擇交易打包進新區塊。在 PBS 架構下，實際的區塊組裝由 builder 完成，builder 根據 Gas 費排序交易以最大化收益，然後將區塊方案提交給 proposer。</p>
<p>交易被打包進區塊後，會獲得一個確定的位置：block number + transaction index。此時交易的狀態從 <code>pending</code> 變為 <code>included</code>。</p>
<h3 id="6-達到確認與最終性"><a class="header" href="#6-達到確認與最終性">6. 達到確認與最終性</a></h3>
<p>交易被包含在區塊中並不意味著「最終確定」。在 Proof of Work 時代，需要等待多個後續區塊（如 Bitcoin 的 6 個確認）才能認為交易不可逆。在 Ethereum 的 Proof of Stake 機制下，交易需要等待約 12-15 分鐘才能達到 finality（最終性）——此後除非超過 1/3 的驗證者串謀作惡，否則交易無法被撤銷。</p>
<pre><code class="language-text">確認等級與風險：

  時間軸 ──────────────────────────────────────&gt;

  Pending    Included   1 confirm  12 confirm  Finalized
    │          │          │          │            │
    │          │          │          │            │
    ▼          ▼          ▼          ▼            ▼
  風險: 高   風險: 中    風險: 低   風險: 極低   風險: ~0

  可被 drop  可被 reorg  reorg 機率  接近不可逆  協議保證
  或 replace 1-2 塊深    極低                   不可逆

  業務建議:
  - 小額 (&lt;$100):   1 confirm 即可確認
  - 中額 ($100-10K): 12 confirms
  - 大額 (&gt;$10K):   等待 finality
  - 交易所入金:      根據幣種設定不同確認數
</code></pre>
<hr />
<h2 id="62-evm-gaseip-1559"><a class="header" href="#62-evm-gaseip-1559">6.2 EVM Gas（EIP-1559）</a></h2>
<p>EIP-1559 是 Ethereum 在 2021 年 London 升級中引入的費率機制改革，徹底改變了 Gas 費的計價方式。理解 EIP-1559 對於正確設定交易費用至關重要。</p>
<h3 id="basefee-協議燃燒"><a class="header" href="#basefee-協議燃燒"><code>baseFee</code>: 協議燃燒</a></h3>
<p>Base fee 是由協議根據前一個區塊的填充率自動計算的最低費用。<strong>這筆費用不會給任何人，而是直接被燃燒（銷毀）</strong>，減少 ETH 的流通量。</p>
<p>Base fee 的調整規則：</p>
<ul>
<li>如果上一個區塊的 Gas 使用量超過目標值（15M Gas），base fee 上升，最多上升 12.5%</li>
<li>如果低於目標值，base fee 下降，最多下降 12.5%</li>
<li>目標是讓區塊平均約 50% 滿</li>
</ul>
<pre><code class="language-text">Base Fee 動態調整示意：

  Block N:   Gas Used = 30M (100% 滿)  → baseFee 上升 12.5%
  Block N+1: Gas Used = 25M (83% 滿)   → baseFee 上升 ~8%
  Block N+2: Gas Used = 15M (50% 滿)   → baseFee 不變
  Block N+3: Gas Used = 10M (33% 滿)   → baseFee 下降 ~4%
  Block N+4: Gas Used = 0   (空塊)     → baseFee 下降 12.5%

  baseFee
    ▲
    │    ╱╲
    │   ╱  ╲
    │  ╱    ╲───────╲
    │ ╱               ╲
    │╱                  ╲──
    └───────────────────────&gt; 區塊
         網路擁堵      正常    空閒
</code></pre>
<h3 id="priorityfee-給出塊者小費"><a class="header" href="#priorityfee-給出塊者小費"><code>priorityFee</code>: 給出塊者小費</a></h3>
<p>Priority fee（也稱為 tip）是使用者額外支付給出塊者的費用，用於激勵出塊者將你的交易優先打包。在不擁堵時，1-2 gwei 的 priority fee 通常就足夠。在擁堵時，你需要提高 priority fee 才能被優先打包。</p>
<h3 id="maxfee-使用者可接受上限"><a class="header" href="#maxfee-使用者可接受上限"><code>maxFee</code>: 使用者可接受上限</a></h3>
<p><code>maxFeePerGas</code> 是使用者願意為每單位 Gas 支付的最高價格。實際支付的 Gas 費用為：<code>min(maxFeePerGas, baseFee + maxPriorityFeePerGas)</code>。如果 <code>maxFeePerGas</code> 低於當前的 <code>baseFee</code>，交易會留在 mempool 中等待 baseFee 下降。</p>
<pre><code class="language-text">EIP-1559 費用計算：

  使用者設定:
    maxFeePerGas         = 100 gwei
    maxPriorityFeePerGas = 2 gwei

  當前狀態:
    baseFee              = 30 gwei

  實際費用:
    effectiveGasPrice = baseFee + priorityFee
                      = 30 + 2
                      = 32 gwei

  費用分配:
    燃燒 (burn):      30 gwei × gasUsed → 從流通中移除
    出塊者收入 (tip):  2 gwei × gasUsed → validator 收入
    退還使用者:        (100 - 32) × gasUsed → 不收取

  如果 baseFee 漲到 110 gwei:
    → 交易無法被打包 (maxFee &lt; baseFee)
    → 留在 mempool 等待 baseFee 下降
    → 或使用者 speed up (重送更高 maxFee)
</code></pre>
<h3 id="gas-費估算策略"><a class="header" href="#gas-費估算策略">Gas 費估算策略</a></h3>
<pre><code class="language-python"># Pseudocode: 動態 Gas 費估算
async def estimate_gas_fees(rpc, urgency="normal"):
    # 取得最新區塊的 baseFee
    latest_block = await rpc.get_block("latest")
    current_base_fee = latest_block["baseFeePerGas"]

    # 取得歷史 priority fee 分佈
    fee_history = await rpc.fee_history(
        block_count=10,
        newest_block="latest",
        reward_percentiles=[25, 50, 75]
    )

    if urgency == "low":
        # 不急: 目標下一個 baseFee，低 priority
        max_priority = fee_history.reward[25th_percentile]
        max_fee = current_base_fee * 1.1 + max_priority
    elif urgency == "normal":
        # 正常: 當前 baseFee 的 1.5 倍緩衝
        max_priority = fee_history.reward[50th_percentile]
        max_fee = current_base_fee * 1.5 + max_priority
    elif urgency == "high":
        # 緊急: 當前 baseFee 的 2 倍
        max_priority = fee_history.reward[75th_percentile]
        max_fee = current_base_fee * 2 + max_priority

    return {
        "maxFeePerGas": max_fee,
        "maxPriorityFeePerGas": max_priority
    }
</code></pre>
<hr />
<h2 id="63-交易失敗型態"><a class="header" href="#63-交易失敗型態">6.3 交易失敗型態</a></h2>
<p>交易失敗不是一個簡單的「成功/失敗」二元結果——不同的失敗模式有不同的原因、不同的 Gas 消耗行為、和不同的處理策略。</p>
<h3 id="out-of-gas"><a class="header" href="#out-of-gas">Out of Gas</a></h3>
<p>當交易執行過程中消耗的 Gas 超過了 <code>gasLimit</code>，EVM 會立即中止執行並 revert 所有狀態變更。<strong>但已消耗的 Gas 不會退還</strong>——這是最昂貴的失敗模式之一。</p>
<p>常見原因：</p>
<ul>
<li><code>gasLimit</code> 設得太保守（例如使用固定值 21000，但實際是合約呼叫）</li>
<li>合約中有無限迴圈或極深的遞迴</li>
<li>合約升級後 Gas 消耗增加，但呼叫端沒有更新估算</li>
</ul>
<h3 id="revertrequire--assert--custom-error"><a class="header" href="#revertrequire--assert--custom-error">Revert（require / assert / custom error）</a></h3>
<p>Revert 是合約主動拒絕執行。與 out of gas 不同，revert 會退還未使用的 Gas。</p>
<pre><code class="language-solidity">// Solidity 中的 revert 來源
function transfer(address to, uint256 amount) external {
    // require: 條件不滿足時 revert，包含錯誤訊息
    require(balanceOf[msg.sender] &gt;= amount, "Insufficient balance");

    // assert: 理論上不應該發生的情況，用於捕捉 bug
    assert(totalSupply &gt;= amount);

    // custom error: Solidity 0.8.4+ 更省 Gas 的錯誤格式
    if (to == address(0)) revert ZeroAddressNotAllowed();

    balanceOf[msg.sender] -= amount;
    balanceOf[to] += amount;
}
</code></pre>
<p><strong>工程建議</strong>：你的系統應該解碼 revert reason，將其轉換為對使用者有意義的錯誤訊息。例如，<code>"Insufficient balance"</code> 可以告訴使用者他們的餘額不足，而不是顯示一個不明所以的交易失敗通知。</p>
<h3 id="nonce-too-low--high"><a class="header" href="#nonce-too-low--high">Nonce Too Low / High</a></h3>
<ul>
<li><strong>Nonce too low</strong>：表示你提交的 nonce 已經被使用過。可能原因：交易已被打包但你的系統還不知道，或你正在重送一筆已確認的交易。</li>
<li><strong>Nonce too high</strong>：你提交的 nonce 比預期的下一個 nonce 大。中間有 nonce 缺口，RPC 節點會拒絕這筆交易（某些節點會接受並放入 mempool 等待缺口被填補）。</li>
</ul>
<pre><code class="language-text">Nonce 錯誤場景：

  帳戶當前 confirmed nonce: 5

  提交 nonce = 3  → "Nonce too low" (已使用過)
  提交 nonce = 5  → 正常 (下一筆應用的 nonce)
  提交 nonce = 7  → "Nonce too high" (跳過 6)
  提交 nonce = 5  → 如果之前 nonce=5 還在 pending，
                     則為替換交易 (需更高 Gas)
</code></pre>
<h3 id="slippage-保護觸發"><a class="header" href="#slippage-保護觸發">Slippage 保護觸發</a></h3>
<p>在 DEX 交易中，slippage tolerance（滑點容忍度）用於保護使用者免受價格大幅波動的影響。如果交易執行時的實際價格偏離預期超過設定的滑點，合約會 revert。</p>
<p>典型場景：你設定 0.5% 的滑點容忍，但在你的交易被打包之前，有人執行了大額 swap 改變了價格。如果價格變動超過 0.5%，你的交易會 revert。這不是 bug，而是保護機制在正常工作。</p>
<p><strong>但過寬的滑點設定是危險的</strong>——如果你設定 50% 的滑點，等於邀請三明治攻擊。MEV 搜尋者可以在你的交易前後各插一筆交易，先推高價格讓你以高價買入，再賣出獲利。</p>
<hr />
<h2 id="64-mev-與排序風險"><a class="header" href="#64-mev-與排序風險">6.4 MEV 與排序風險</a></h2>
<p>MEV（Maximal Extractable Value）是指區塊生產者（或與其合作的搜尋者）通過重新排序、插入或移除區塊中的交易所能獲取的最大利潤。MEV 是區塊鏈系統中一個深刻的結構性問題，對交易工程有直接影響。</p>
<h3 id="front-running"><a class="header" href="#front-running">Front-running</a></h3>
<p>搶跑（front-running）是指觀察到使用者的待處理交易後，搶先提交一筆類似的交易以從中獲利。經典場景是在 DEX 上：搜尋者看到你即將以市價買入大量 token，就搶先買入推高價格，你被迫以更高價成交。</p>
<pre><code class="language-text">Front-running 攻擊流程：

  時間軸 ────────────────────────────────&gt;

  1. User 提交: swap 100 ETH → TokenA
     (mempool 中可見)
         │
         v
  2. Searcher 觀察到大額 swap
     Searcher 提交: swap 10 ETH → TokenA (更高 Gas)
         │
         v
  3. 區塊打包順序:
     ┌─────────────────────────┐
     │ Tx1: Searcher 買入      │ ← 先執行，價格上升
     │ Tx2: User 買入 (高價)   │ ← 被迫以更高價成交
     └─────────────────────────┘

  結果: User 多付了價差，Searcher 獲利
</code></pre>
<h3 id="sandwich-attack"><a class="header" href="#sandwich-attack">Sandwich Attack</a></h3>
<p>三明治攻擊是 front-running 的進化版。攻擊者在目標交易前後各插入一筆交易：先買入推高價格（front-run），等目標交易以高價執行後，再賣出獲利（back-run）。</p>
<pre><code class="language-text">Sandwich Attack 結構：

  區塊中的交易順序:

  ┌─────────────────────────────────────┐
  │ Tx1 (Attacker): Buy TokenA          │  ← 推高價格
  │                 花 10 ETH 買 1000 A │
  │                                     │
  │ Tx2 (Victim):   Buy TokenA          │  ← 以高價成交
  │                 花 100 ETH 買 9500 A│  (本應得 10000 A)
  │                                     │
  │ Tx3 (Attacker): Sell TokenA         │  ← 賣出獲利
  │                 賣 1000 A 得 10.5 ETH│
  └─────────────────────────────────────┘

  Attacker 利潤: 0.5 ETH
  Victim 損失:   500 TokenA (約 0.5 ETH 等值)
</code></pre>
<h3 id="back-running"><a class="header" href="#back-running">Back-running</a></h3>
<p>尾隨（back-running）是在某筆交易之後緊接著執行的套利行為。例如：某個大額 swap 改變了 DEX 的價格，back-runner 緊接著在不同 DEX 之間套利。Back-running 通常不傷害使用者（使用者的交易已正常執行），但它展示了 MEV 的普遍性。</p>
<h3 id="工程防禦手段"><a class="header" href="#工程防禦手段">工程防禦手段</a></h3>
<pre><code class="language-text">MEV 防護策略矩陣：

┌──────────────────────┬─────────────────┬───────────────────┐
│ 策略                 │ 防護效果        │ 代價              │
├──────────────────────┼─────────────────┼───────────────────┤
│ 私有 RPC / Builder   │ 避免 mempool    │ 依賴中心化服務    │
│ (Flashbots Protect)  │ 曝光            │                   │
├──────────────────────┼─────────────────┼───────────────────┤
│ 交易批次化           │ 減少個別交易    │ 增加系統複雜度    │
│ (Batch transactions) │ 被觀察的機會    │                   │
├──────────────────────┼─────────────────┼───────────────────┤
│ 嚴格滑點保護         │ 限制攻擊者      │ 可能導致交易      │
│ (0.1-1% slippage)    │ 可獲利空間      │ 更容易失敗        │
├──────────────────────┼─────────────────┼───────────────────┤
│ Deadline 參數         │ 防止延遲執行    │ 需要合理設定      │
│ (交易過期時間)        │                │                   │
├──────────────────────┼─────────────────┼───────────────────┤
│ Commit-Reveal 機制    │ 隱藏交易意圖    │ 需要兩筆交易      │
│                      │ 直到揭露        │ 增加延遲和成本    │
└──────────────────────┴─────────────────┴───────────────────┘
</code></pre>
<p><strong>實務建議</strong>：</p>
<ol>
<li>
<p><strong>DeFi 交易必設 deadline</strong>：在 Uniswap 等 DEX 交易中，永遠設定 <code>deadline</code> 參數（例如當前時間 + 300 秒）。沒有 deadline 的交易可能被刻意延遲到對攻擊者有利的時刻再執行。</p>
</li>
<li>
<p><strong>使用 Flashbots Protect 或類似服務</strong>：對於主網上的高價值交易，通過 <code>https://rpc.flashbots.net</code> 發送交易，避免在公開 mempool 中曝光。</p>
</li>
<li>
<p><strong>監控 MEV 損失</strong>：使用 EigenPhi、Flashbots Explorer 等工具，定期檢查你的地址是否曾遭受 MEV 攻擊，並據此調整防護策略。</p>
</li>
</ol>
<hr />
<h2 id="65-狀態機視角"><a class="header" href="#65-狀態機視角">6.5 狀態機視角</a></h2>
<p>從工程角度來看，交易的生命週期本質上是一個<strong>有限狀態機（Finite State Machine）</strong>。你的交易追蹤系統應該明確建模每個狀態和狀態轉換。</p>
<pre><code class="language-text">交易狀態機完整定義：

                  ┌──────────────────────┐
                  │                      │
                  v                      │
  Draft ──→ Signed ──→ Pending ──→ Included ──→ Confirmed(k) ──→ Finalized
                         │           │     │
                         │           │     └──→ Reverted (交易失敗，但被包含在區塊中)
                         │           │
                         │           └──→ Uncle/Ommer (區塊被棄用，交易回到 Pending)
                         │
                         ├──→ Dropped (節點 mempool 滿，交易被丟棄)
                         │
                         └──→ Replaced (同 nonce 的新交易被打包，取代原交易)


狀態轉換觸發條件：

  Draft → Signed:       私鑰簽名完成
  Signed → Pending:     廣播到至少一個節點
  Pending → Included:   交易被打包進區塊
  Pending → Dropped:    mempool 過期 (通常 ~6 小時) 或節點重啟
  Pending → Replaced:   同 nonce 更高 Gas 的交易被打包
  Included → Confirmed: 後續區塊持續增加
  Included → Reverted:  交易執行失敗 (out of gas, require fail)
  Included → Uncle:     區塊被 reorg 棄用
  Confirmed → Finalized: 達到協議最終性 (PoS: ~12 min)
</code></pre>
<h3 id="狀態追蹤的工程實現"><a class="header" href="#狀態追蹤的工程實現">狀態追蹤的工程實現</a></h3>
<pre><code class="language-python"># Pseudocode: Transaction State Machine
from enum import Enum

class TxState(Enum):
    DRAFT = "draft"
    SIGNED = "signed"
    PENDING = "pending"
    INCLUDED = "included"
    CONFIRMED = "confirmed"
    FINALIZED = "finalized"
    REVERTED = "reverted"
    DROPPED = "dropped"
    REPLACED = "replaced"

class TransactionTracker:
    def __init__(self, tx_hash, rpc):
        self.tx_hash = tx_hash
        self.state = TxState.PENDING
        self.block_number = None
        self.confirmations = 0
        self.rpc = rpc

    async def poll_status(self):
        receipt = await self.rpc.get_transaction_receipt(self.tx_hash)

        if receipt is None:
            # 仍在 mempool 或已被 drop
            pending_tx = await self.rpc.get_transaction(self.tx_hash)
            if pending_tx is None:
                self.state = TxState.DROPPED
            else:
                self.state = TxState.PENDING
            return

        self.block_number = receipt["blockNumber"]

        if receipt["status"] == 0:
            self.state = TxState.REVERTED
            return

        latest_block = await self.rpc.get_block_number()
        self.confirmations = latest_block - self.block_number + 1

        if self.confirmations &gt;= FINALITY_THRESHOLD:  # e.g., 64 for Ethereum
            self.state = TxState.FINALIZED
        elif self.confirmations &gt;= CONFIRMATION_THRESHOLD:  # e.g., 12
            self.state = TxState.CONFIRMED
        else:
            self.state = TxState.INCLUDED
</code></pre>
<p><strong>關鍵設計決策</strong>：</p>
<ul>
<li><strong>輪詢 vs 訂閱</strong>：可以用 <code>eth_subscribe("newHeads")</code> 監聽新區塊來觸發狀態更新，而非定時輪詢。但 WebSocket 連接可能斷開，因此需要 fallback 到輪詢機制。</li>
<li><strong>Reorg 處理</strong>：即使交易已被確認 3 個區塊，仍有可能因為 reorg 而被撤銷。你的狀態機必須允許 <code>CONFIRMED → PENDING</code> 的回退。</li>
<li><strong>Timeout 策略</strong>：如果交易在 mempool 中停留超過設定時間（如 30 分鐘），應該自動嘗試 speed up（重送更高 Gas）或 cancel（送同 nonce 的空交易）。</li>
</ul>
<hr />
<h2 id="66-utxo-交易生命週期"><a class="header" href="#66-utxo-交易生命週期">6.6 UTXO 交易生命週期</a></h2>
<p>Bitcoin 和其他 UTXO 模型的區塊鏈有著與 EVM 帳戶模型完全不同的交易結構。UTXO（Unspent Transaction Output）模型中，沒有「帳戶餘額」的概念——你的「餘額」是所有指向你地址的未花費交易輸出的總和。</p>
<h3 id="1-coin-selection選哪些-utxo-當-inputs"><a class="header" href="#1-coin-selection選哪些-utxo-當-inputs">1. Coin Selection（選哪些 UTXO 當 inputs）</a></h3>
<p>要建構一筆交易，首先要從你擁有的 UTXO 集合中選擇足夠的輸入。這個過程稱為 coin selection，是一個涉及隱私、費用和 UTXO 集合管理的最佳化問題。</p>
<pre><code class="language-text">Coin Selection 範例：

  你的 UTXO 集合：
  ┌─────────────────────────────────┐
  │ UTXO_1: 0.3 BTC (txid:abc...#0)│
  │ UTXO_2: 0.5 BTC (txid:def...#1)│
  │ UTXO_3: 1.2 BTC (txid:ghi...#2)│
  │ UTXO_4: 0.1 BTC (txid:jkl...#0)│
  └─────────────────────────────────┘

  目標: 發送 0.7 BTC

  策略 A (最少輸入): 使用 UTXO_3 (1.2 BTC)
    → 找零 = 1.2 - 0.7 - fee ≈ 0.4998 BTC
    → 優點: 交易體積小，費用低
    → 缺點: 產生大額找零

  策略 B (精確匹配): 使用 UTXO_1 + UTXO_2 (0.8 BTC)
    → 找零 = 0.8 - 0.7 - fee ≈ 0.0998 BTC
    → 優點: 找零小，隱私較好
    → 缺點: 兩個輸入，交易體積略大
</code></pre>
<p>常見的 coin selection 演算法：</p>
<ul>
<li><strong>Largest First</strong>：選最大的 UTXO，簡單但可能產生大額找零</li>
<li><strong>Branch and Bound</strong>：嘗試找到精確匹配（無找零）的組合</li>
<li><strong>Random Selection</strong>：隨機選擇以提高隱私性</li>
</ul>
<h3 id="2-估算-fee-ratesatvb-等"><a class="header" href="#2-估算-fee-ratesatvb-等">2. 估算 Fee Rate（sat/vB 等）</a></h3>
<p>Bitcoin 的交易費用按照交易的虛擬位元組（virtual bytes, vB）計價，而非固定金額。你需要根據當前 mempool 的擁堵程度來設定適當的 fee rate。</p>
<pre><code class="language-text">Bitcoin Fee Rate 估算：

  Mempool 狀態:
  ┌────────────────────────────────────┐
  │ 下一區塊 (≤10 min): 50+ sat/vB   │
  │ 1-3 區塊 (≤30 min): 30-50 sat/vB │
  │ 3-6 區塊 (≤1 hour): 10-30 sat/vB │
  │ 低優先 (數小時):    1-10 sat/vB   │
  └────────────────────────────────────┘

  交易大小估算:
  - P2WPKH 1-in-1-out: ~110 vB
  - P2WPKH 2-in-2-out: ~208 vB
  - P2TR  1-in-1-out:  ~112 vB

  費用計算:
  交易費 = fee_rate (sat/vB) × 交易大小 (vB)
  例: 50 sat/vB × 208 vB = 10,400 sat ≈ 0.000104 BTC
</code></pre>
<h3 id="3-產生-outputs收款--change"><a class="header" href="#3-產生-outputs收款--change">3. 產生 Outputs（收款 + Change）</a></h3>
<p>一筆 UTXO 交易通常有兩個輸出：一個是給收款人的金額，另一個是找零（change）——把多餘的金額退回給自己。找零地址通常使用新的地址以提高隱私性。</p>
<p><strong>常見陷阱</strong>：如果你忘記加上找零輸出，所有的「多餘」金額都會變成礦工費。曾有使用者因為這個錯誤付了 500 BTC 的手續費。</p>
<h3 id="4-本地簽名含-witness"><a class="header" href="#4-本地簽名含-witness">4. 本地簽名（含 Witness）</a></h3>
<p>在 SegWit（隔離見證）交易中，簽名資料被放在 witness 區域，不計入傳統的交易大小。這有效降低了交易費用，並解決了交易延展性（transaction malleability）問題。</p>
<h3 id="5-廣播與-mempool-排序"><a class="header" href="#5-廣播與-mempool-排序">5. 廣播與 Mempool 排序</a></h3>
<p>Bitcoin 的 mempool 按 fee rate 排序。與 Ethereum 不同，Bitcoin 沒有 nonce 的概念——同一個地址的多筆交易之間不需要嚴格排序（但花費同一個 UTXO 的交易會互相衝突）。</p>
<h3 id="6-必要時-rbf--cpfp-加速"><a class="header" href="#6-必要時-rbf--cpfp-加速">6. 必要時 RBF / CPFP 加速</a></h3>
<p>如果交易卡在 mempool 中，有兩種加速方式：</p>
<ul>
<li><strong>RBF（Replace-By-Fee）</strong>：重新建構一筆花費相同 UTXO 但 fee rate 更高的交易。原交易必須在建構時設定了 RBF 信號（nSequence &lt; 0xFFFFFFFE）。</li>
<li><strong>CPFP（Child-Pays-For-Parent）</strong>：建構一筆新交易花費卡住交易的找零輸出，並為新交易設定足夠高的 fee rate。礦工為了收取子交易的費用，會連同父交易一起打包。</li>
</ul>
<pre><code class="language-text">RBF vs CPFP 比較：

  RBF (Replace-By-Fee):
  ┌──────────────────────────────┐
  │ 原交易 (5 sat/vB) → 作廢    │
  │ 替換交易 (50 sat/vB) → 打包 │
  │                              │
  │ 條件: 原交易設有 RBF 信號    │
  │ 優點: 可以修改任何欄位       │
  │ 缺點: 接收者看到交易消失     │
  └──────────────────────────────┘

  CPFP (Child-Pays-For-Parent):
  ┌──────────────────────────────┐
  │ 父交易 (5 sat/vB) ─┐        │
  │                     │ 一起   │
  │ 子交易 (100 sat/vB)─┘ 打包   │
  │                              │
  │ 條件: 有可花費的找零輸出     │
  │ 優點: 不影響原交易           │
  │ 缺點: 額外交易費用           │
  └──────────────────────────────┘
</code></pre>
<h3 id="7-入塊後按確認數提升信任等級"><a class="header" href="#7-入塊後按確認數提升信任等級">7. 入塊後按確認數提升信任等級</a></h3>
<p>Bitcoin 沒有協議層的最終性保證——理論上任何交易都可以被更長的鏈覆蓋。但隨著後續區塊的增加，覆蓋的計算成本呈指數級增長。業界慣例的確認數：</p>
<ul>
<li>小額交易：1-2 個確認（10-20 分鐘）</li>
<li>中等金額：3-6 個確認（30-60 分鐘）</li>
<li>大額交易（交易所入金）：6 個確認（約 1 小時）</li>
<li>極大額交易：可能要求 30-60 個確認</li>
</ul>
<hr />
<h2 id="白話總結-5"><a class="header" href="#白話總結-5">白話總結</a></h2>
<p>一筆交易從你按下「發送」到真正「不可逆」，中間要經過建構、模擬、簽名、廣播、進入 mempool、被打包出塊、累積確認數、最終達到 finality 這一連串的步驟。你的系統不能只關心「成功」和「失敗」兩種結果——交易可能卡在 mempool（pending）、被更高 Gas 的交易替換（replaced）、被節點丟棄（dropped）、執行失敗但仍被包含在區塊中（reverted）、甚至已經確認又因為 reorg 而被撤銷。Gas 費不是一個固定數字，它是一個動態市場——base fee 根據網路擁堵程度自動調整，priority fee 是你給出塊者的小費。MEV 是一個你必須面對的現實：如果你的大額 DeFi 交易在公開 mempool 中暴露，搜尋者可能會搶跑或三明治攻擊你。防禦手段包括使用私有交易通道、設定嚴格的滑點保護、以及為交易設定 deadline。UTXO 模型（Bitcoin）和帳戶模型（Ethereum）的交易結構完全不同——UTXO 沒有 nonce，但有 coin selection 和找零的問題。不管是哪種模型，你的交易追蹤系統都必須建模為完整的狀態機，覆蓋每一種可能的狀態和轉換路徑。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-智能合約執行模型"><a class="header" href="#7-智能合約執行模型">7. 智能合約執行模型</a></h1>
<h2 id="71-合約生命週期"><a class="header" href="#71-合約生命週期">7.1 合約生命週期</a></h2>
<p>智能合約的生命週期可以類比為傳統軟體工程中的 SDLC（Software Development Life Cycle），但有一個根本性差異：<strong>合約一旦部署上鏈，其程式碼就是不可變的</strong>（除非使用 Proxy 升級模式）。這意味著每一個階段都必須比傳統開發更加謹慎，因為修復錯誤的成本極高——不僅是技術成本，更可能涉及真金白銀的損失。</p>
<h3 id="設計階段"><a class="header" href="#設計階段">設計階段</a></h3>
<p>設計階段是整個生命週期中最關鍵的環節。工程師需要明確定義以下三個核心要素：</p>
<ul>
<li><strong>規格（Specification）</strong>：合約要解決什麼問題？接受哪些輸入？產出哪些狀態變更？建議使用 NatSpec 格式撰寫函式規格，讓文件與程式碼緊密結合。</li>
<li><strong>狀態機（State Machine）</strong>：合約中的狀態轉換必須明確建模。例如一個眾籌合約可能有 <code>Funding -&gt; GoalReached -&gt; Withdrawn</code> 或 <code>Funding -&gt; Failed -&gt; Refunded</code> 兩條路徑，每個狀態轉換都必須定義清楚的觸發條件與前置檢查。</li>
<li><strong>權限模型（Access Control）</strong>：誰能呼叫哪些函式？使用 Role-Based Access Control（RBAC）還是簡單的 <code>onlyOwner</code>？權限模型的設計直接決定了合約的安全邊界。</li>
</ul>
<pre><code class="language-text">合約狀態機範例（簡化的眾籌合約）：

    ┌──────────┐   達標    ┌──────────────┐   owner提款   ┌────────────┐
    │ Funding  │─────────&gt;│ GoalReached  │────────────&gt;│ Withdrawn  │
    └──────────┘          └──────────────┘             └────────────┘
         │
         │ 超時未達標
         v
    ┌──────────┐   用戶退款  ┌────────────┐
    │  Failed  │──────────&gt;│  Refunded  │
    └──────────┘           └────────────┘
</code></pre>
<h3 id="開發階段"><a class="header" href="#開發階段">開發階段</a></h3>
<p>開發階段遵循 TDD 原則，測試策略分為三個層次：</p>
<ul>
<li><strong>單元測試（Unit Test）</strong>：針對每個函式的邏輯正確性。使用 Foundry 的 <code>forge test</code> 或 Hardhat 的測試框架，覆蓋率應達 95% 以上。重點測試邊界條件，例如 <code>uint256</code> 的溢位、零地址輸入、空陣列等。</li>
<li><strong>Fuzz Testing</strong>：讓測試框架隨機產生輸入值，嘗試找出人類測試者不會想到的邊界條件。Foundry 原生支援 fuzz testing，只需在測試函式的參數中加入變數即可。一般建議至少跑 10,000 輪 fuzz。</li>
<li><strong>Invariant Testing</strong>：定義系統中「永遠不應被違反」的不變量。例如「Vault 合約的總餘額永遠等於所有用戶存款之和」。Invariant testing 會在隨機操作序列後檢查這些不變量是否仍然成立。</li>
</ul>
<pre><code class="language-solidity">// Foundry Fuzz Test 範例
function testFuzz_deposit(uint256 amount) public {
    // 限制輸入範圍
    amount = bound(amount, 1, type(uint128).max);

    token.mint(user, amount);
    vm.prank(user);
    token.approve(address(vault), amount);

    vm.prank(user);
    vault.deposit(amount);

    // 不變量：用戶存款後餘額正確
    assertEq(vault.balanceOf(user), amount);
    assertEq(token.balanceOf(address(vault)), amount);
}
</code></pre>
<h3 id="審計階段"><a class="header" href="#審計階段">審計階段</a></h3>
<p>審計是部署前的最後防線，通常結合三種方法：</p>
<ul>
<li><strong>靜態分析（Static Analysis）</strong>：使用工具如 Slither、Mythril 自動掃描常見漏洞模式。靜態分析能快速發現 reentrancy、未檢查的外部呼叫回傳值等問題，但容易產生 false positive。</li>
<li><strong>動態分析（Dynamic Analysis）</strong>：實際執行合約並監控行為，包含 symbolic execution（符號執行）。工具如 Echidna（基於 property-based testing）能發現靜態分析無法觸及的路徑問題。</li>
<li><strong>人工審計（Manual Audit）</strong>：由經驗豐富的安全研究員逐行檢視程式碼。重點關注業務邏輯的正確性、經濟模型的可操縱性、以及各模組間的交互風險。一份完整的人工審計通常需要 2-4 週。</li>
</ul>
<p><strong>最佳實踐</strong>：在審計前先跑完靜態分析並修復所有 high/medium 級別的問題，讓人工審計師能專注在更深層的邏輯問題上。</p>
<h3 id="部署階段"><a class="header" href="#部署階段">部署階段</a></h3>
<p>部署不僅僅是把合約放上鏈，更重要的是環境管理與權限配置：</p>
<ul>
<li><strong>分環境部署</strong>：Testnet（Sepolia/Goerli）→ Staging（Mainnet fork）→ Mainnet。每個環境都要跑完整測試套件。使用 Foundry 的 <code>forge script</code> 搭配 <code>--fork-url</code> 可以在 mainnet fork 上模擬真實部署。</li>
<li><strong>權限最小化</strong>：部署完成後立即將 owner 轉移到 multisig，而非留在部署者的 EOA。初始化函式只能呼叫一次，必須加上 <code>initializer</code> modifier。</li>
<li><strong>驗證合約原始碼</strong>：在 Etherscan 上驗證原始碼，讓社群能審查已部署的程式碼與審計報告是否一致。</li>
</ul>
<h3 id="維運階段"><a class="header" href="#維運階段">維運階段</a></h3>
<p>合約上鏈後的維運工作同樣關鍵：</p>
<ul>
<li><strong>升級治理</strong>：如果使用 Proxy 模式，升級流程必須經過 Timelock（通常 24-48 小時延遲）和多簽核准。社群應有足夠時間審視升級內容。</li>
<li><strong>監控（Monitoring）</strong>：使用 Tenderly、Forta 或自建監控系統，追蹤異常交易模式。例如：大額轉帳、短時間內大量清算、合約餘額驟降等。</li>
<li><strong>應急處理（Incident Response）</strong>：預先定義 <code>pause()</code> 機制和緊急撤資路徑。建議維護一份 War Room Playbook，明確列出各種緊急情境的處理步驟和負責人。</li>
</ul>
<pre><code class="language-text">維運監控架構：

┌─────────────┐     ┌──────────────┐     ┌─────────────┐
│  On-chain   │────&gt;│  Event       │────&gt;│  Alert      │
│  Contract   │     │  Indexer     │     │  System     │
└─────────────┘     └──────────────┘     └─────────────┘
                          │                     │
                          v                     v
                    ┌──────────────┐     ┌─────────────┐
                    │  Dashboard   │     │  PagerDuty  │
                    │  (Grafana)   │     │  / Slack    │
                    └──────────────┘     └─────────────┘
</code></pre>
<h2 id="72-常見架構"><a class="header" href="#72-常見架構">7.2 常見架構</a></h2>
<p>智能合約的架構設計直接影響可維護性、升級彈性和安全性。選擇架構時需要權衡複雜度與靈活性。</p>
<h3 id="monolith單體合約"><a class="header" href="#monolith單體合約">Monolith（單體合約）</a></h3>
<p>最簡單的架構模式，所有邏輯集中在一個合約中。適用於功能單純、不需要升級的場景，例如一次性的 Token Sale 合約或簡單的 NFT Mint 合約。</p>
<p><strong>優點</strong>：</p>
<ul>
<li>部署簡單，gas 成本低（只需部署一個合約）</li>
<li>程式碼易於理解，審計成本低</li>
<li>沒有跨合約呼叫的複雜性</li>
</ul>
<p><strong>缺點</strong>：</p>
<ul>
<li>一旦部署無法修改任何邏輯</li>
<li>合約大小受限於 EIP-170 的 24KB 限制</li>
<li>功能耦合度高，難以復用</li>
</ul>
<p><strong>適用場景</strong>：Token 合約（ERC-20/721）、簡單的 Escrow、一次性活動合約。</p>
<h3 id="modular模組化架構"><a class="header" href="#modular模組化架構">Modular（模組化架構）</a></h3>
<p>將合約拆分為多個獨立模組，透過 Router（路由器）統一入口，Vault（金庫）管理資金，Library（函式庫）提供共用邏輯。這是中大型 DeFi 協議最常見的架構。</p>
<pre><code class="language-text">模組化架構圖：

                    ┌──────────────────┐
                    │     Router       │
                    │  (Entry Point)   │
                    └────────┬─────────┘
                             │
              ┌──────────────┼──────────────┐
              │              │              │
              v              v              v
       ┌────────────┐ ┌───────────┐ ┌────────────┐
       │   Module A  │ │  Module B │ │  Module C  │
       │  (Trading)  │ │ (Lending) │ │ (Staking)  │
       └──────┬─────┘ └─────┬─────┘ └──────┬─────┘
              │              │              │
              └──────────────┼──────────────┘
                             │
                      ┌──────v──────┐
                      │    Vault    │
                      │  (Treasury) │
                      └──────┬──────┘
                             │
                      ┌──────v──────┐
                      │   Library   │
                      │  (Math/    │
                      │   Utils)    │
                      └─────────────┘
</code></pre>
<p><strong>真實案例</strong>：Uniswap V4 使用 Singleton 模式將所有流動性池集中在一個合約中，但透過 Hooks 機制實現模組化的自定義邏輯。GMX V2 則使用 Router + DataStore + Handler 的模組化設計，將資料儲存、業務邏輯和入口路由完全分離。</p>
<h3 id="proxy-upgrade代理升級模式"><a class="header" href="#proxy-upgrade代理升級模式">Proxy Upgrade（代理升級模式）</a></h3>
<p>透過將「狀態儲存」和「邏輯執行」分離，實現合約可升級性。使用者始終與 Proxy 合約互動，Proxy 透過 <code>delegatecall</code> 將呼叫轉發到 Implementation（實作合約）。</p>
<p>三種主要的 Proxy 模式：</p>
<div class="table-wrapper"><table><thead><tr><th>模式</th><th>升級邏輯位置</th><th>優點</th><th>缺點</th></tr></thead><tbody>
<tr><td><strong>Transparent Proxy</strong></td><td>Proxy 合約</td><td>明確分離 admin/user 呼叫</td><td>Gas 稍高（每次檢查 caller）</td></tr>
<tr><td><strong>UUPS</strong></td><td>Implementation 合約</td><td>Gas 更低、更靈活</td><td>如果忘記在新版本保留升級函式則永久鎖死</td></tr>
<tr><td><strong>Beacon Proxy</strong></td><td>Beacon 合約</td><td>多個 Proxy 共享一個 Implementation</td><td>增加一層間接層</td></tr>
</tbody></table>
</div>
<pre><code class="language-solidity">// UUPS Proxy 升級流程虛擬碼
contract MyContractV1 is UUPSUpgradeable {
    uint256 public value;

    function initialize(uint256 _value) public initializer {
        value = _value;
    }

    // 注意：如果 V2 忘記實作這個函式，合約將永遠無法再升級
    function _authorizeUpgrade(address newImpl) internal override onlyOwner {}
}

contract MyContractV2 is UUPSUpgradeable {
    uint256 public value;
    uint256 public newFeature;  // 只能新增 storage variable，不能修改既有的

    function _authorizeUpgrade(address newImpl) internal override onlyOwner {}
}
</code></pre>
<p><strong>常見陷阱</strong>：在升級時改變既有 storage variable 的順序或型別會導致 storage collision，這是最危險的 Proxy 相關漏洞之一。務必使用 OpenZeppelin 的 <code>@openzeppelin/upgrades</code> 套件來自動檢測 storage layout 衝突。</p>
<h2 id="73-重要安全議題"><a class="header" href="#73-重要安全議題">7.3 重要安全議題</a></h2>
<p>智能合約的安全問題可以粗略分為「程式碼層面」和「設計層面」兩類。以下列出最常見且損失最慘重的五大安全議題。</p>
<h3 id="reentrancy重入攻擊"><a class="header" href="#reentrancy重入攻擊">Reentrancy（重入攻擊）</a></h3>
<p>Reentrancy 是智能合約安全史上最具代表性的漏洞，2016 年的 The DAO 事件因此損失約 360 萬 ETH（當時價值約 6,000 萬美元）。攻擊原理是在合約將資金轉出後、但尚未更新狀態變數之前，攻擊者透過 fallback function 再次呼叫提款函式。</p>
<pre><code class="language-solidity">// ❌ 有漏洞的寫法
function withdraw(uint256 amount) external {
    require(balances[msg.sender] &gt;= amount);
    (bool ok, ) = msg.sender.call{value: amount}("");  // 1. 先轉帳
    require(ok);
    balances[msg.sender] -= amount;  // 2. 才更新狀態 → 攻擊者可在步驟1重入
}

// ✅ 安全的寫法（Checks-Effects-Interactions 模式）
function withdraw(uint256 amount) external nonReentrant {
    require(balances[msg.sender] &gt;= amount);  // Check
    balances[msg.sender] -= amount;           // Effect（先更新狀態）
    (bool ok, ) = msg.sender.call{value: amount}("");  // Interaction（最後才外部互動）
    require(ok);
}
</code></pre>
<p><strong>防禦策略</strong>：</p>
<ol>
<li>遵循 CEI（Checks-Effects-Interactions）模式</li>
<li>使用 OpenZeppelin 的 <code>ReentrancyGuard</code>（<code>nonReentrant</code> modifier）</li>
<li>在跨合約呼叫時特別注意 read-only reentrancy（攻擊者重入的是另一個合約的 view function，讀到過時的狀態）</li>
</ol>
<h3 id="access-control-錯配"><a class="header" href="#access-control-錯配">Access Control 錯配</a></h3>
<p>權限控制的錯誤配置是最常見的漏洞類型之一。常見情境包括：忘記給關鍵函式加上權限修飾器、<code>initialize()</code> 函式沒有加上 <code>initializer</code> modifier 導致任何人可以重新初始化、以及權限轉移過程中的空窗期。</p>
<p><strong>真實案例</strong>：2022 年 Wintermute 事件中，某合約的 <code>initialize()</code> 函式在部署後未被呼叫，攻擊者搶先呼叫並將自己設為 owner，盜走了 1.6 億美元。</p>
<p><strong>最佳實踐</strong>：使用 OpenZeppelin 的 <code>AccessControl</code> 而非手寫 <code>onlyOwner</code>。為每個敏感操作定義明確的 role（例如 <code>MINTER_ROLE</code>、<code>PAUSER_ROLE</code>、<code>UPGRADER_ROLE</code>），並在部署腳本中驗證所有 role 的分配。</p>
<h3 id="delegatecall-汙染"><a class="header" href="#delegatecall-汙染">Delegatecall 汙染</a></h3>
<p><code>delegatecall</code> 是 Proxy 模式的核心機制，它讓被呼叫合約的程式碼在呼叫者的 storage context 中執行。如果被 delegatecall 的目標合約被惡意替換，或目標合約本身有寫入 storage 的行為，就會汙染 Proxy 合約的狀態。</p>
<pre><code class="language-text">Delegatecall 執行模型：

Proxy Contract (Storage)          Implementation Contract (Logic)
┌──────────────────────┐          ┌──────────────────────┐
│ slot 0: owner        │  ←───── │ slot 0: owner        │
│ slot 1: balance      │  ←───── │ slot 1: balance      │
│ slot 2: impl address │         │                      │
└──────────────────────┘          └──────────────────────┘
        ↑                                  ↑
        │ storage 存在 Proxy                │ 邏輯定義在 Implementation
        │ 但 delegatecall 讓               │ 但在 Proxy 的 context 執行
        │ Implementation 的程式碼            │
        │ 操作 Proxy 的 storage             │
</code></pre>
<p><strong>防禦策略</strong>：Implementation 合約的 constructor 中呼叫 <code>_disableInitializers()</code> 防止直接初始化。確保 Proxy 和 Implementation 的 storage layout 完全一致。</p>
<h3 id="storage-slot-衝突升級相關"><a class="header" href="#storage-slot-衝突升級相關">Storage Slot 衝突（升級相關）</a></h3>
<p>在合約升級時，新版本的 Implementation 合約必須保持與舊版本完全相同的 storage layout。如果在已有的 storage variable 之間插入新變數，或改變變數型別，將導致資料讀取錯位。</p>
<pre><code class="language-solidity">// V1
contract MyContractV1 {
    uint256 public totalSupply;    // slot 0
    address public owner;          // slot 1
}

// ❌ 錯誤的 V2（插入新變數到中間）
contract MyContractV2 {
    uint256 public totalSupply;    // slot 0
    uint256 public newVariable;    // slot 1 ← 衝突！原本 owner 在這裡
    address public owner;          // slot 2 ← 讀到的是垃圾資料
}

// ✅ 正確的 V2（只在最後新增）
contract MyContractV2 {
    uint256 public totalSupply;    // slot 0
    address public owner;          // slot 1（保持不變）
    uint256 public newVariable;    // slot 2（新增在最後）
}
</code></pre>
<p><strong>最佳實踐</strong>：使用 OpenZeppelin 的 <code>forge inspect</code> 或 <code>hardhat-upgrades</code> 的 storage layout 比對功能，在升級前自動檢測衝突。考慮使用 EIP-7201（Namespaced Storage Layout）來避免 storage collision。</p>
<h3 id="oracle-操縱"><a class="header" href="#oracle-操縱">Oracle 操縱</a></h3>
<p>DeFi 協議高度依賴 Oracle（預言機）提供鏈外資料（價格、利率等）。如果 Oracle 回傳的價格可以被操縱，攻擊者就能以不合理的價格執行交易、清算或鑄造資產。</p>
<p><strong>常見攻擊手法</strong>：</p>
<ul>
<li><strong>閃電貸操縱 AMM 價格</strong>：攻擊者用閃電貸大量買入某 Token，推高 AMM 的即時價格，利用被操縱的價格在借貸協議中超額借貸，然後歸還閃電貸。</li>
<li><strong>TWAP Oracle 延遲利用</strong>：Time-Weighted Average Price 雖然比即時價格更難操縱，但在市場劇烈波動時會有延遲，攻擊者可以利用這個價差。</li>
</ul>
<p><strong>防禦策略</strong>：使用 Chainlink 等去中心化 Oracle 網路、設定價格偏差閾值（例如單一區塊內價格變化超過 10% 則拒絕交易）、結合多個 Oracle 來源做交叉驗證。</p>
<h2 id="74-執行流程圖"><a class="header" href="#74-執行流程圖">7.4 執行流程圖</a></h2>
<p>理解智能合約的執行流程對於除錯和安全分析至關重要。以下是一筆典型的合約呼叫從進入到完成的完整流程：</p>
<pre><code class="language-text">                         External Call (tx or internal call)
                                    │
                                    v
                        ┌───────────────────────┐
                        │   Receive ETH?         │
                        │   (msg.value &gt; 0 &amp;&amp;    │
                        │    no calldata)         │
                        └───────┬────────┬───────┘
                           Yes  │        │  No
                                v        v
                        ┌──────────┐  ┌──────────────────────┐
                        │ receive()│  │ Function Selector     │
                        │ /fallback│  │ (first 4 bytes of     │
                        └──────────┘  │  keccak256(signature))│
                                      └──────────┬───────────┘
                                                  │
                                                  v
                                      ┌──────────────────────┐
                                      │ Modifier Chain       │
                                      │ (onlyOwner,          │
                                      │  nonReentrant,       │
                                      │  whenNotPaused...)   │
                                      └──────────┬───────────┘
                                                  │
                                                  v
                                      ┌──────────────────────┐
                                      │ Business Logic       │
                                      │ (require checks,     │
                                      │  state mutations,    │
                                      │  calculations)       │
                                      └──────────┬───────────┘
                                                  │
                              ┌────────────────────┼────────────────────┐
                              │                    │                    │
                              v                    v                    v
                    ┌──────────────┐    ┌──────────────┐    ┌──────────────┐
                    │ State Write  │    │ External     │    │ Event Emit   │
                    │ (SSTORE)     │    │ Interaction  │    │ (LOG0-LOG4)  │
                    │              │    │ (CALL/       │    │              │
                    │ 每個 slot    │    │  DELEGATECALL│    │ 用於鏈下     │
                    │ 首次寫入     │    │  /STATICCALL)│    │ indexing     │
                    │ 20,000 gas   │    │              │    │              │
                    └──────────────┘    └──────────────┘    └──────────────┘
</code></pre>
<h3 id="gas-成本剖析"><a class="header" href="#gas-成本剖析">Gas 成本剖析</a></h3>
<p>理解 EVM 的 gas 成本模型對於撰寫高效合約至關重要：</p>
<div class="table-wrapper"><table><thead><tr><th>操作</th><th>Gas 成本</th><th>說明</th></tr></thead><tbody>
<tr><td>SLOAD（讀 storage）</td><td>2,100（cold） / 100（warm）</td><td>EIP-2929 引入 cold/warm 概念</td></tr>
<tr><td>SSTORE（寫 storage）</td><td>20,000（新 slot） / 5,000（更新）</td><td>最昂貴的操作之一</td></tr>
<tr><td>CALL（外部呼叫）</td><td>2,600（cold）</td><td>加上被呼叫合約的 gas 消耗</td></tr>
<tr><td>LOG（事件）</td><td>375 + 375 * topics + 8 * bytes</td><td>Topic 數量和資料長度影響成本</td></tr>
<tr><td>Memory 擴展</td><td>二次方增長</td><td>超過一定大小後 gas 急劇增加</td></tr>
</tbody></table>
</div>
<p><strong>Gas 優化技巧</strong>：</p>
<ul>
<li>將多個 <code>bool</code> 變數 pack 進同一個 <code>uint256</code> storage slot</li>
<li>使用 <code>calldata</code> 而非 <code>memory</code> 作為外部函式的陣列參數</li>
<li>將常用的 storage 讀取結果快取到 memory 變數中</li>
</ul>
<h2 id="75-最小權限設計"><a class="header" href="#75-最小權限設計">7.5 最小權限設計</a></h2>
<p>最小權限原則（Principle of Least Privilege）是合約安全設計的基石。在區塊鏈上，權限過度集中不僅是安全風險，更是信任風險——如果一個 EOA 擁有無限權力，那麼所有用戶的資金安全取決於一把私鑰的安全。</p>
<h3 id="owner-不直接掌資金"><a class="header" href="#owner-不直接掌資金">Owner 不直接掌資金</a></h3>
<p><code>owner</code> 角色應只負責協議治理（參數調整、升級等），而非資金管理。資金應由獨立的 Treasury Multisig 控制。這樣即使 owner 私鑰洩露，攻擊者也無法直接提走資金。</p>
<pre><code class="language-text">權限分離架構：

┌────────────────────────────────────────────────────────┐
│                    Protocol Governance                   │
│                                                          │
│  ┌──────────────┐    ┌──────────────┐    ┌────────────┐ │
│  │ Owner Role   │    │ Treasury     │    │ Emergency  │ │
│  │ (Multisig A) │    │ (Multisig B) │    │ (Multisig C│ │
│  ├──────────────┤    ├──────────────┤    ├────────────┤ │
│  │ - 參數調整   │    │ - 資金轉移   │    │ - pause()  │ │
│  │ - 合約升級   │    │ - 預算分配   │    │ - 緊急提款 │ │
│  │ - 角色管理   │    │ - 薪資發放   │    │            │ │
│  └──────┬───────┘    └──────────────┘    └────────────┘ │
│         │                                                │
│         v                                                │
│  ┌──────────────┐                                        │
│  │  Timelock    │  24-48 小時延遲                         │
│  │  Contract    │  讓社群有時間審查                        │
│  └──────────────┘                                        │
└────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="管理操作進-timelock"><a class="header" href="#管理操作進-timelock">管理操作進 Timelock</a></h3>
<p>所有重大管理操作（參數調整、升級、新增白名單等）都應通過 Timelock 合約。Timelock 引入強制延遲（通常 24-48 小時），在延遲期間社群可以審查即將執行的操作，必要時可以取消。</p>
<p><strong>典型流程</strong>：</p>
<ol>
<li>Multisig 提交操作提案到 Timelock</li>
<li>Timelock 排入佇列，啟動倒計時（例如 48 小時）</li>
<li>社群透過 on-chain event 看到提案內容</li>
<li>倒計時結束後，任何人都可以執行（execute）該操作</li>
<li>如果社群發現問題，Multisig 可以在執行前取消</li>
</ol>
<h3 id="pause-與-unpause-分離角色"><a class="header" href="#pause-與-unpause-分離角色">pause 與 unpause 分離角色</a></h3>
<p>緊急暫停機制是應對 0-day 漏洞的最後防線。關鍵設計原則是：<strong>pause 操作應該門檻低（快速反應），但 unpause 操作應該門檻高（確認安全後才恢復）</strong>。</p>
<pre><code class="language-solidity">// 權限分離範例
bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
bytes32 public constant UNPAUSER_ROLE = keccak256("UNPAUSER_ROLE");

// PAUSER_ROLE: 可以是單一可信的 EOA（快速反應）
// UNPAUSER_ROLE: 必須是 Multisig + Timelock（確保安全後才恢復）

function pause() external onlyRole(PAUSER_ROLE) {
    _pause();
}

function unpause() external onlyRole(UNPAUSER_ROLE) {
    _unpause();
}
</code></pre>
<p><strong>真實案例</strong>：2022 年 Nomad Bridge 被攻擊時，由於缺乏有效的暫停機制，攻擊在數小時內被多人複製，最終損失約 1.9 億美元。如果有快速暫停機制，損失可以大幅減少。</p>
<h3 id="其他最小權限設計建議"><a class="header" href="#其他最小權限設計建議">其他最小權限設計建議</a></h3>
<ul>
<li><strong>函式可見性最小化</strong>：能用 <code>private</code> 就不用 <code>internal</code>，能用 <code>internal</code> 就不用 <code>public</code>。不需要被外部呼叫的函式絕對不要設為 <code>external</code> 或 <code>public</code>。</li>
<li><strong>Approve 限額控制</strong>：合約與外部協議互動時，只 approve 當次操作所需的金額，操作完成後立即將 allowance 設回 0。避免無限 approve（<code>type(uint256).max</code>）造成的潛在風險。</li>
<li><strong>角色過期機制</strong>：考慮為某些臨時性角色設定過期時間，例如部署初期的 <code>MINTER_ROLE</code> 在 7 天後自動失效。</li>
</ul>
<h2 id="白話總結-6"><a class="header" href="#白話總結-6">白話總結</a></h2>
<p>智能合約可以想像成一台自動販賣機——一旦放到街上（部署上鏈），你就不能輕易打開它的外殼來修改內部電路了。所以在設計和製造階段，你必須把所有可能的情況都想清楚：如果有人塞假幣怎麼辦？如果有人同時按兩個按鈕怎麼辦？如果停電了（鏈暫停了）怎麼辦？</p>
<p>合約的架構設計就像蓋房子，簡單的需求（一間工具間）用 Monolith 就好，複雜的需求（一棟商業大樓）就需要模組化設計，而如果你預期未來需要改建或擴建，就要用 Proxy 模式預留彈性。但 Proxy 模式也帶來額外的複雜度和風險，特別是 storage layout 衝突的問題，所以不是所有合約都適合用 Proxy。</p>
<p>安全方面，重入攻擊（Reentrancy）是最經典的問題，它的本質就是「在你還沒記帳之前就讓你再付一次錢」。解法很簡單：先記帳再付錢。但現實中的安全問題往往更微妙，比如 Oracle 操縱就像是有人偷改了商品的標價牌，然後以錯誤的價格購買。</p>
<p>權限管理的核心思想是「不要把所有鑰匙交給同一個人」。資金管理用一把鑰匙（Treasury Multisig），參數調整用另一把（Owner Multisig），緊急暫停用第三把（Pauser）。這樣即使某一把鑰匙被偷，損害也會被限制在最小範圍內。</p>
<p>最後，監控和應急機制就像是大樓的消防系統——你希望永遠用不到它，但絕對不能沒有。一個好的合約系統應該能在發現異常的第一時間暫停運作，等待人類判斷和修復，而不是讓攻擊者有幾個小時的時間慢慢搬空資金。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="8-l1l2跨鏈與橋接"><a class="header" href="#8-l1l2跨鏈與橋接">8. L1/L2/跨鏈與橋接</a></h1>
<h2 id="81-為什麼需要-l2"><a class="header" href="#81-為什麼需要-l2">8.1 為什麼需要 L2</a></h2>
<p>區塊鏈的「不可能三角」（Blockchain Trilemma）指出，去中心化、安全性和擴展性三者難以同時兼顧。以太坊選擇了去中心化和安全性，犧牲了擴展性——Ethereum Mainnet 目前每秒只能處理約 15-30 筆交易，遠不足以支撐大規模應用。Layer 2（L2）的出現正是為了解決這個瓶頸。</p>
<h3 id="降低交易成本"><a class="header" href="#降低交易成本">降低交易成本</a></h3>
<p>在 Ethereum Mainnet 上執行一筆簡單的 ERC-20 轉帳需要約 65,000 gas，在 gas price 為 30 gwei 時約需 0.002 ETH。而一筆 Uniswap swap 可能需要 150,000-300,000 gas，成本可達數美元甚至數十美元。L2 透過將大量交易打包後壓縮提交到 L1，讓每筆交易分攤的 L1 成本大幅降低。以 Arbitrum 為例，同樣的 swap 操作成本通常只需 L1 的 1/10 到 1/50。</p>
<p>EIP-4844（Proto-Danksharding）的引入進一步降低了 L2 的資料可用性成本。它引入了一種新的交易類型 blob transaction，讓 L2 可以用更便宜的方式將資料發佈到 L1。Blob 資料在 L1 上只會被保存約 18 天（而非永久），對於 L2 來說這已經足夠，因為挑戰期通常只有 7 天。</p>
<h3 id="提高吞吐量"><a class="header" href="#提高吞吐量">提高吞吐量</a></h3>
<p>L2 透過在鏈外執行交易來提高吞吐量。L1 只需要驗證「一批交易的結果是正確的」，而不需要逐筆重新執行。這意味著 L2 的 TPS（Transactions Per Second）主要受限於 sequencer 的處理能力和 L1 的資料可用性頻寬，而非 L1 本身的執行能力。</p>
<p>目前主要的 L2 理論 TPS 上限如下：</p>
<div class="table-wrapper"><table><thead><tr><th>L2</th><th>理論 TPS</th><th>實際觀察 TPS</th><th>限制因素</th></tr></thead><tbody>
<tr><td>Arbitrum One</td><td>~40,000</td><td>數百-數千</td><td>Sequencer 處理能力</td></tr>
<tr><td>Optimism</td><td>~2,000</td><td>數百</td><td>類似</td></tr>
<tr><td>zkSync Era</td><td>~100,000+</td><td>數百-數千</td><td>ZK proof 生成速度</td></tr>
<tr><td>Base</td><td>~2,000</td><td>數百-數千</td><td>共享 OP Stack</td></tr>
</tbody></table>
</div>
<h3 id="把計算外包到-l2把安全錨定在-l1"><a class="header" href="#把計算外包到-l2把安全錨定在-l1">把計算外包到 L2，把安全錨定在 L1</a></h3>
<p>L2 的核心設計哲學是：<strong>L2 負責執行，L1 負責驗證和最終性</strong>。使用者在 L2 上享受高速低費的交易體驗，但所有交易最終都會被提交到 L1 並獲得 L1 等級的安全保障。這就像是在地方法院（L2）處理日常案件，但重大案件可以上訴到最高法院（L1）。</p>
<pre><code class="language-text">L1/L2 安全模型：

┌──────────────────────────────────────────────────────┐
│                    L1 (Ethereum)                       │
│                                                        │
│  ┌───────────────┐  ┌───────────────┐  ┌────────────┐ │
│  │ State Root    │  │ Data Avail.   │  │ Fraud/     │ │
│  │ Commitment    │  │ (calldata /   │  │ Validity   │ │
│  │               │  │  blob)        │  │ Proof      │ │
│  └───────┬───────┘  └───────┬───────┘  └──────┬─────┘ │
│          │                  │                  │       │
│          │     安全性錨定在 L1 的共識機制上       │       │
└──────────┼──────────────────┼──────────────────┼───────┘
           │                  │                  │
           v                  v                  v
┌──────────────────────────────────────────────────────┐
│                    L2 (Rollup)                         │
│                                                        │
│  ┌───────────────┐  ┌───────────────┐                  │
│  │  Sequencer    │  │  Full Node    │                  │
│  │ (排序 &amp; 執行)  │  │ (驗證 &amp; 同步)  │                  │
│  └───────────────┘  └───────────────┘                  │
│                                                        │
│  高吞吐 + 低費用 + L1 級安全保障                          │
└──────────────────────────────────────────────────────┘
</code></pre>
<p><strong>需要注意的風險</strong>：目前大部分 L2 的 sequencer 仍然是中心化的。雖然 sequencer 無法竊取使用者資金（因為 L1 上有強制退出機制），但它可以審查交易、對交易排序以獲取 MEV、或者暫時停止出塊。L2 的去中心化 sequencer 方案仍在積極開發中。</p>
<h2 id="82-rollup-差異"><a class="header" href="#82-rollup-差異">8.2 Rollup 差異</a></h2>
<p>Rollup 是目前最主流的 L2 擴展方案，分為兩大陣營：Optimistic Rollup 和 ZK Rollup。兩者的核心差異在於「如何讓 L1 相信 L2 提交的狀態是正確的」。</p>
<h3 id="optimistic-rollup挑戰期--fraud-proof"><a class="header" href="#optimistic-rollup挑戰期--fraud-proof">Optimistic Rollup：挑戰期 + Fraud Proof</a></h3>
<p>Optimistic Rollup 採用「先信任，後驗證」的策略。Sequencer 將一批交易和執行後的狀態根提交到 L1，預設這些狀態都是正確的（optimistic）。在一段挑戰期（通常 7 天）內，任何人都可以提出 fraud proof 來質疑某個狀態轉換的正確性。</p>
<pre><code class="language-text">Optimistic Rollup 工作流程：

時間線 ──────────────────────────────────────────&gt;

         提交狀態          挑戰期 (7 天)              最終確認
         ┌──┐   ┌─────────────────────────────┐   ┌──────┐
Batch N  │TX│──&gt;│  任何人可提交 fraud proof     │──&gt;│ Final│
         └──┘   │                              │   └──────┘
                │  若無挑戰 → 狀態確認           │
                │  若有挑戰 → 進入仲裁流程        │
                └─────────────────────────────┘

仲裁流程（以 Arbitrum 的 Interactive Fraud Proof 為例）：

挑戰者: "Batch N 的狀態不對！"
         │
         v
    ┌──────────────────────────────────────────┐
    │  二分搜尋 (Bisection Protocol)             │
    │                                            │
    │  Step 1: 將 N 條指令分成兩半               │
    │  Step 2: 雙方同意前半部分是正確的           │
    │  Step 3: 繼續二分後半部分                   │
    │  ...重複直到找到單條有爭議的指令...          │
    │                                            │
    │  Step Final: L1 合約執行該單條指令           │
    │              判定誰是對的                    │
    └──────────────────────────────────────────┘
</code></pre>
<p><strong>Optimistic Rollup 的關鍵特性</strong>：</p>
<ul>
<li><strong>提款延遲</strong>：從 L2 提款到 L1 需要等待整個挑戰期（7 天），這是最大的用戶體驗痛點。第三方流動性橋（如 Hop Protocol、Across）透過預先墊付來解決這個問題，但會收取費用。</li>
<li><strong>EVM 等效性</strong>：Optimistic Rollup 通常能做到 EVM 等效（EVM Equivalence），意味著 L1 上的 Solidity 合約可以幾乎不做修改地部署到 L2。Arbitrum 和 Optimism 都宣稱具有高度的 EVM 相容性。</li>
<li><strong>資料可用性需求</strong>：所有交易資料必須發佈到 L1，確保任何人都能重建 L2 狀態並提出挑戰。</li>
</ul>
<p><strong>代表項目</strong>：Arbitrum One、Optimism（OP Mainnet）、Base（使用 OP Stack）。</p>
<h3 id="zk-rollupvalidity-proof-快速最終性"><a class="header" href="#zk-rollupvalidity-proof-快速最終性">ZK Rollup：Validity Proof 快速最終性</a></h3>
<p>ZK Rollup 採用相反的策略：「先驗證，再信任」。Sequencer 在提交狀態時同時附上一個密碼學證明（validity proof），這個證明可以數學上保證狀態轉換是正確的。L1 合約只需要驗證這個證明（成本很低），而不需要任何挑戰期。</p>
<pre><code class="language-text">ZK Rollup 工作流程：

┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│   Sequencer  │────&gt;│  Prover      │────&gt;│  L1 Verifier │
│   收集交易    │     │  生成 ZK     │     │  驗證 proof   │
│   執行狀態    │     │  Proof       │     │  更新狀態     │
└──────────────┘     └──────────────┘     └──────────────┘
     │                     │                     │
     │  毫秒級              │  分鐘~小時級         │  秒級
     │  (交易執行)          │  (proof 生成)        │  (on-chain 驗證)
     v                     v                     v
  使用者感受            後台處理              最終確認
  即時確認             計算密集               無需挑戰期
</code></pre>
<p><strong>ZK Rollup 的關鍵特性</strong>：</p>
<ul>
<li><strong>快速最終性</strong>：一旦 validity proof 在 L1 上被驗證，狀態就是最終確認的。提款不需要等待 7 天，理論上只需等待 proof 生成和驗證的時間（目前約數分鐘到數小時）。</li>
<li><strong>Proof 生成成本</strong>：生成 ZK proof 需要大量計算資源，這是 ZK Rollup 的主要成本瓶頸。專用硬體（FPGA、ASIC）正在開發中以降低成本。</li>
<li><strong>EVM 相容性挑戰</strong>：EVM 的設計並非為 ZK 友善。某些 EVM opcode（如 KECCAK256）在 ZK 電路中成本極高。zkEVM 的實現分為不同等級的相容性，從 Type 1（完全等效）到 Type 4（高級語言相容）。</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>zkEVM 類型</th><th>相容性</th><th>代表項目</th><th>說明</th></tr></thead><tbody>
<tr><td>Type 1</td><td>完全等效以太坊</td><td>Taiko</td><td>可直接驗證 Ethereum 區塊</td></tr>
<tr><td>Type 2</td><td>EVM 等效</td><td>Scroll、Polygon zkEVM</td><td>少量差異（如 gas 計量）</td></tr>
<tr><td>Type 2.5</td><td>EVM 等效（部分 gas 不同）</td><td>-</td><td>某些 opcode gas 不同</td></tr>
<tr><td>Type 3</td><td>幾乎 EVM 等效</td><td>-</td><td>移除少數難以 ZK 化的功能</td></tr>
<tr><td>Type 4</td><td>高級語言相容</td><td>zkSync Era</td><td>從 Solidity 編譯為 ZK 友善的 bytecode</td></tr>
</tbody></table>
</div>
<p><strong>代表項目</strong>：zkSync Era、StarkNet（使用 STARK 而非 SNARK）、Scroll、Polygon zkEVM、Linea。</p>
<h3 id="兩者比較總覽"><a class="header" href="#兩者比較總覽">兩者比較總覽</a></h3>
<pre><code class="language-text">                   Optimistic Rollup          ZK Rollup
                   ──────────────────         ──────────────
提款延遲            7 天（挑戰期）              分鐘~小時（等 proof）
鏈上成本            中（發佈 calldata）         高（驗證 proof + calldata）
鏈下成本            低                         高（proof 生成）
EVM 相容性          高（幾乎等效）              中~高（取決於 zkEVM 類型）
安全假設            至少需要 1 個誠實驗證者       數學保證（密碼學假設）
成熟度              高（已上線數年）             中（快速發展中）
</code></pre>
<h2 id="83-跨鏈橋模型"><a class="header" href="#83-跨鏈橋模型">8.3 跨鏈橋模型</a></h2>
<p>跨鏈橋是連接不同區塊鏈的基礎設施，讓資產和訊息能在鏈與鏈之間流動。由於不同的區塊鏈有各自獨立的共識機制和狀態空間，跨鏈橋本質上是在解決「如何讓一條鏈信任另一條鏈上發生的事情」這個問題。</p>
<h3 id="lock--mint"><a class="header" href="#lock--mint">Lock &amp; Mint</a></h3>
<p>最常見的跨鏈模型。使用者在來源鏈上將資產鎖定在橋合約中，橋在目標鏈上鑄造等量的 wrapped token。這些 wrapped token 的價值由鎖定的原始資產背書。</p>
<pre><code class="language-text">Lock &amp; Mint 流程：

Source Chain (Ethereum)              Target Chain (Arbitrum)
┌─────────────────────┐              ┌─────────────────────┐
│                     │              │                     │
│  User: 100 USDC     │              │  User: 0 USDC      │
│         │           │              │                     │
│         v           │              │                     │
│  ┌─────────────┐    │   Relayer    │  ┌─────────────┐    │
│  │ Bridge      │    │ ──────────&gt; │  │ Bridge      │    │
│  │ Contract    │    │   訊息傳遞   │  │ Contract    │    │
│  │             │    │              │  │             │    │
│  │ Lock 100    │    │              │  │ Mint 100    │    │
│  │ USDC        │    │              │  │ wUSDC       │    │
│  └─────────────┘    │              │  └─────────────┘    │
│                     │              │                     │
│  User: 0 USDC       │              │  User: 100 wUSDC   │
│  Bridge: 100 USDC   │              │                     │
└─────────────────────┘              └─────────────────────┘
</code></pre>
<p><strong>特性與風險</strong>：鎖定在來源鏈上的資產構成一個巨大的蜜罐（honeypot），歷史上多個橋的攻擊事件都是針對這個鎖定合約。如果橋被攻破，鑄造出來的 wrapped token 將失去背書價值，形成「空氣幣」。</p>
<h3 id="burn--release"><a class="header" href="#burn--release">Burn &amp; Release</a></h3>
<p>與 Lock &amp; Mint 相反的流程。使用者在目標鏈上銷毀（burn）wrapped token，橋在來源鏈上釋放（release）等量的原始資產。通常作為 Lock &amp; Mint 的回程操作。</p>
<pre><code class="language-text">Burn &amp; Release 流程（回程）：

Target Chain (Arbitrum)              Source Chain (Ethereum)
┌─────────────────────┐              ┌─────────────────────┐
│                     │              │                     │
│  User: 100 wUSDC    │   Relayer    │  Bridge: 100 USDC   │
│         │           │ ──────────&gt; │         │           │
│         v           │              │         v           │
│  ┌─────────────┐    │              │  ┌─────────────┐    │
│  │ Burn 100    │    │              │  │ Release 100 │    │
│  │ wUSDC       │    │              │  │ USDC        │    │
│  └─────────────┘    │              │  └─────────────┘    │
│                     │              │                     │
│  User: 0 wUSDC      │              │  User: 100 USDC    │
└─────────────────────┘              └─────────────────────┘
</code></pre>
<h3 id="light-client-bridge"><a class="header" href="#light-client-bridge">Light-Client Bridge</a></h3>
<p>最安全但也最昂貴的跨鏈方案。在目標鏈上部署來源鏈的 light client（輕節點），直接驗證來源鏈的區塊頭和 Merkle proof。這種方式不需要信任任何中間人，安全性等同於來源鏈本身。</p>
<p><strong>工作原理</strong>：目標鏈上的 light client 合約持續追蹤來源鏈的驗證者集合和區塊頭。當有跨鏈訊息要驗證時，只需提交 Merkle proof 即可在 light client 中驗證該事件是否真的在來源鏈上發生過。</p>
<pre><code class="language-text">Light-Client Bridge 驗證流程：

Source Chain                                Target Chain
┌────────────────────┐                     ┌────────────────────┐
│                    │                     │                    │
│  Block N           │   Block Header      │  Light Client      │
│  ├── Header ───────│─────────────────────&gt;│  Contract          │
│  ├── Tx Root       │                     │  ├── Headers[]     │
│  │   ├── Tx 1      │   Merkle Proof       │  ├── Validator Set│
│  │   ├── Tx 2 ─────│─────────────────────&gt;│  │                │
│  │   └── ...       │                     │  │  verify(        │
│  └── State Root    │                     │  │    blockHeader,  │
│                    │                     │  │    merkleProof,   │
│                    │                     │  │    txData         │
│                    │                     │  │  ) → true/false  │
└────────────────────┘                     └────────────────────┘
</code></pre>
<p><strong>優點</strong>：最高等級的安全性，無需信任第三方。IBC（Inter-Blockchain Communication，Cosmos 生態的跨鏈協議）就是基於 light client 的設計。</p>
<p><strong>缺點</strong>：在 EVM 上部署和維護 light client 的 gas 成本極高，特別是對於使用 PoS 的區塊鏈（需要驗證大量簽名）。ZK 技術正在被用來壓縮 light client 的驗證成本——例如 Succinct Labs 的方案可以用 ZK proof 來證明「一組驗證者確實簽署了某個區塊頭」，將鏈上驗證成本從數百萬 gas 降低到約 30 萬 gas。</p>
<h3 id="external-validator-bridge"><a class="header" href="#external-validator-bridge">External Validator Bridge</a></h3>
<p>使用一組外部驗證者（通常是 multisig 或 MPC 節點集合）來見證跨鏈訊息。當來源鏈上的事件被足夠數量的驗證者確認後，目標鏈上就執行相應操作。</p>
<pre><code class="language-text">External Validator Bridge：

Source Chain          Validator Set (M-of-N)         Target Chain
┌──────────┐        ┌─────────────────────┐        ┌──────────┐
│          │        │  Validator 1  ✓     │        │          │
│  Event   │───────&gt;│  Validator 2  ✓     │───────&gt;│  Execute │
│  Emit    │        │  Validator 3  ✗     │        │  Action  │
│          │        │  Validator 4  ✓     │        │          │
│          │        │  (3-of-4 threshold) │        │          │
└──────────┘        └─────────────────────┘        └──────────┘
</code></pre>
<p><strong>優點</strong>：實作簡單、成本低、速度快（不需要等待區塊確認）。</p>
<p><strong>缺點</strong>：安全性完全取決於驗證者集合。如果超過門檻數量的驗證者被攻破或串謀，橋就會被完全攻破。歷史上最大的幾起橋接攻擊（Ronin Bridge 6.24 億美元、Wormhole 3.2 億美元）都是因為外部驗證者被攻破。</p>
<p><strong>改進方向</strong>：使用 TEE（Trusted Execution Environment）來保護驗證者的私鑰、增加驗證者數量並引入 slashing 機制、結合 light client 驗證作為額外安全層。</p>
<h2 id="84-跨鏈風險"><a class="header" href="#84-跨鏈風險">8.4 跨鏈風險</a></h2>
<p>跨鏈橋是區塊鏈生態中被攻擊最頻繁、損失最慘重的領域。根據統計，2021-2023 年間跨鏈橋攻擊造成的總損失超過 25 億美元。理解這些風險對於選擇和使用跨鏈橋至關重要。</p>
<h3 id="驗證者集中"><a class="header" href="#驗證者集中">驗證者集中</a></h3>
<p>當跨鏈橋依賴一小組驗證者時，攻擊面集中在這些驗證者的私鑰安全性上。攻擊者只需攻破足夠數量的驗證者（通常是 M-of-N 門檻中的 M 個），就能完全控制橋。</p>
<p><strong>案例分析——Ronin Bridge（2022 年 3 月）</strong>：Axie Infinity 的 Ronin Bridge 使用 9 個驗證者的 5-of-9 multisig。攻擊者（後證實為北韓 Lazarus Group）透過社會工程攻擊取得了 5 個驗證者的私鑰，偽造了 17.36 萬 ETH 和 2,550 萬 USDC 的提款，總計約 6.24 億美元。更糟糕的是，攻擊發生後 6 天才被發現。</p>
<p><strong>防禦措施</strong>：增加驗證者數量（至少 20 個以上）、使用 MPC（Multi-Party Computation）取代 multisig（私鑰碎片化，沒有人持有完整私鑰）、定期輪換驗證者、監控異常簽名活動。</p>
<h3 id="訊息重放"><a class="header" href="#訊息重放">訊息重放</a></h3>
<p>跨鏈訊息如果缺乏唯一標識符（nonce 或 message ID），攻擊者可以將同一筆跨鏈訊息重複提交，造成重複鑄幣或重複提款。</p>
<pre><code class="language-text">訊息重放攻擊示意：

正常流程：
  Source: Lock(100 USDC, nonce=1) → Target: Mint(100 USDC, nonce=1) ✓

重放攻擊（無 nonce 保護）：
  攻擊者重複提交同一筆訊息：
  Target: Mint(100 USDC) ✓  ← 第一次
  Target: Mint(100 USDC) ✓  ← 第二次（重放！）
  Target: Mint(100 USDC) ✓  ← 第三次（重放！）

防禦：
  Target 合約維護 processedNonces mapping
  Mint(100 USDC, nonce=1) ✓  ← 第一次
  Mint(100 USDC, nonce=1) ✗  ← "nonce already processed"
</code></pre>
<p><strong>防禦措施</strong>：每筆跨鏈訊息必須包含唯一 nonce，目標鏈合約記錄已處理的 nonce 並拒絕重複處理。使用 message hash 作為唯一標識符是更通用的做法。</p>
<h3 id="錯誤最終性假設"><a class="header" href="#錯誤最終性假設">錯誤最終性假設</a></h3>
<p>不同區塊鏈有不同的最終性語義。如果橋對來源鏈的最終性做了過於激進的假設，可能在來源鏈發生 reorg（區塊重組）時導致資金問題。</p>
<p><strong>問題場景</strong>：假設橋在來源鏈上看到 1 個區塊確認就認為交易最終確認，並在目標鏈上鑄幣。如果來源鏈隨後發生 reorg，該交易被回滾，但目標鏈上的鑄幣已經完成且無法回滾——結果是 wrapped token 沒有對應的鎖定資產。</p>
<p><strong>不同鏈的最終性特徵</strong>：</p>
<div class="table-wrapper"><table><thead><tr><th>區塊鏈</th><th>最終性類型</th><th>建議等待確認數</th><th>大約時間</th></tr></thead><tbody>
<tr><td>Ethereum（PoS）</td><td>經濟最終性（2 epoch）</td><td>64 blocks</td><td>~13 分鐘</td></tr>
<tr><td>Bitcoin</td><td>概率性最終性</td><td>6 blocks</td><td>~60 分鐘</td></tr>
<tr><td>Solana</td><td>樂觀確認 / 最終確認</td><td>32 slots（最終）</td><td>~13 秒</td></tr>
<tr><td>Polygon PoS</td><td>依賴 checkpoint 到 ETH</td><td>256 blocks</td><td>~10 分鐘</td></tr>
</tbody></table>
</div>
<p><strong>防禦措施</strong>：根據轉帳金額動態調整等待確認數。小額交易可以接受較少確認，大額交易必須等待經濟最終性。設定金額閾值，超過閾值的交易需要額外人工審核。</p>
<h3 id="升級權限過大"><a class="header" href="#升級權限過大">升級權限過大</a></h3>
<p>許多橋合約使用可升級的 Proxy 模式，如果升級權限被單一 EOA 或少數人的 multisig 控制，攻擊者只需攻破升級權限就能替換整個合約邏輯。</p>
<p><strong>案例分析——Wormhole（2022 年 2 月）</strong>：攻擊者利用 Solana 上 Wormhole 合約的一個漏洞，繞過了簽名驗證，偽造了 guardian 的確認訊息，鑄造了 12 萬 wETH（約 3.2 億美元）。雖然這不是直接的升級權限問題，但它展示了合約邏輯漏洞的毀滅性影響。</p>
<p><strong>防禦措施</strong>：</p>
<ul>
<li>升級必須經過 Timelock（至少 48 小時延遲）</li>
<li>升級需要多簽核准（門檻至少 2/3 以上）</li>
<li>設定升級冷卻期，避免連續快速升級</li>
<li>升級前必須通過完整的審計流程</li>
</ul>
<h2 id="85-訊息流"><a class="header" href="#85-訊息流">8.5 訊息流</a></h2>
<p>跨鏈訊息傳遞是橋接的核心機制。一筆完整的跨鏈操作涉及多個步驟和多個參與者的協作。以下是一個典型的跨鏈訊息流的詳細分解：</p>
<pre><code class="language-text">完整跨鏈訊息流：

Chain A                    Relayer Layer                    Chain B
┌──────────────┐          ┌──────────────┐          ┌──────────────┐
│              │          │              │          │              │
│ 1. User 發起 │          │              │          │              │
│    跨鏈交易   │          │              │          │              │
│      │       │          │              │          │              │
│      v       │          │              │          │              │
│ 2. Bridge    │  ─────&gt;  │ 3. Relayer   │  ─────&gt;  │ 5. Verifier  │
│    Contract  │  Event   │    監聽事件   │  Submit  │    Contract  │
│    emit      │  Log     │    收集證明   │  Proof   │    驗證證明   │
│    CrossChain│          │              │          │      │       │
│    Event     │          │ 4. 等待足夠   │          │      v       │
│              │          │    區塊確認   │          │ 6. Execute   │
│              │          │              │          │    目標操作   │
│              │          │              │          │      │       │
│              │          │              │          │      v       │
│ 9. 更新狀態   │  &lt;─────  │ 8. Relayer   │  &lt;─────  │ 7. Emit     │
│    (optional)│  ACK     │    回傳確認   │  Event   │    完成事件   │
│              │          │              │          │              │
└──────────────┘          └──────────────┘          └──────────────┘

時間線：
|-- 交易確認 --|-- 等待最終性 --|-- 證明傳遞 --|-- 驗證 &amp; 執行 --|
     秒級          分鐘~小時         秒級           秒級
</code></pre>
<h3 id="訊息編碼格式"><a class="header" href="#訊息編碼格式">訊息編碼格式</a></h3>
<p>跨鏈訊息通常包含以下標準欄位：</p>
<pre><code class="language-solidity">struct CrossChainMessage {
    uint256 nonce;          // 唯一序號，防止重放
    uint256 srcChainId;     // 來源鏈 ID
    uint256 dstChainId;     // 目標鏈 ID
    address sender;         // 來源鏈發送者
    address receiver;       // 目標鏈接收者
    bytes payload;          // 執行資料（calldata）
    uint256 gasLimit;       // 目標鏈執行 gas 上限
    uint256 fee;            // 跨鏈費用
}
</code></pre>
<h3 id="失敗處理"><a class="header" href="#失敗處理">失敗處理</a></h3>
<p>跨鏈操作的失敗處理尤其重要，因為涉及兩條獨立的鏈。如果目標鏈上的操作失敗，來源鏈上鎖定的資產必須有退款機制。</p>
<pre><code class="language-text">失敗處理流程：

正常流程：
  Chain A: Lock → Chain B: Execute Success → 完成

失敗流程 1（目標鏈執行失敗）：
  Chain A: Lock → Chain B: Execute Fail → Relayer 回報 → Chain A: Refund

失敗流程 2（Relayer 離線）：
  Chain A: Lock → [timeout] → Chain A: User 手動退款（需等待超時期）

失敗流程 3（目標鏈 gas 不足）：
  Chain A: Lock → Chain B: Out of Gas → 訊息待重試 → User 補 gas → 重試
</code></pre>
<p><strong>工程建議</strong>：永遠為跨鏈操作設定超時機制。如果目標鏈在超時時間內沒有確認，來源鏈上的資金應可被退還。建議超時時間設為正常操作時間的 5-10 倍。</p>
<h2 id="86-防禦準則"><a class="header" href="#86-防禦準則">8.6 防禦準則</a></h2>
<p>設計和使用跨鏈橋時，以下防禦準則應被視為最低安全標準：</p>
<h3 id="大額跨鏈用分批與速率限制"><a class="header" href="#大額跨鏈用分批與速率限制">大額跨鏈用分批與速率限制</a></h3>
<p>單筆跨鏈操作不應超過橋的總鎖定量的某個百分比（建議不超過 5-10%）。對於大額轉帳，應自動拆分為多筆交易，並在每批之間設定冷卻期。</p>
<pre><code class="language-text">速率限制策略範例：

┌──────────────────────────────────────────────────┐
│                Rate Limiter                        │
│                                                    │
│  規則 1: 單筆上限 = min(TVL * 5%, $10M)            │
│  規則 2: 每小時累計上限 = TVL * 10%                 │
│  規則 3: 每日累計上限 = TVL * 30%                   │
│  規則 4: 超過單筆 $1M 需要額外確認延遲（2 小時）     │
│                                                    │
│  觸發任一規則 → 交易進入排隊 / 人工審核              │
└──────────────────────────────────────────────────┘
</code></pre>
<p><strong>真實案例</strong>：2024 年 Orbiter Finance 和多個橋接協議開始引入動態速率限制，根據近期的橋接活動量自動調整閾值。這種「熔斷器」機制類似傳統金融中的 circuit breaker。</p>
<h3 id="橋接白名單與路由選擇策略"><a class="header" href="#橋接白名單與路由選擇策略">橋接白名單與路由選擇策略</a></h3>
<p>不是所有橋都適合所有場景。工程團隊應建立橋接白名單和路由選擇策略：</p>
<p><strong>評估維度</strong>：</p>
<ul>
<li><strong>安全模型</strong>：Light client &gt; ZK proof &gt; Optimistic with fraud proof &gt; External validator</li>
<li><strong>流動性深度</strong>：橋上的可用流動性是否足以支持預期的轉帳量</li>
<li><strong>歷史紀錄</strong>：該橋是否有過安全事件？事件後的應對和改進措施如何？</li>
<li><strong>審計狀況</strong>：是否有多家獨立審計機構的報告？最近一次審計是什麼時候？</li>
<li><strong>去中心化程度</strong>：升級權限由誰控制？是否有 Timelock？</li>
</ul>
<pre><code class="language-text">路由選擇決策樹：

                    ┌─────────────────┐
                    │  跨鏈需求發生     │
                    └────────┬────────┘
                             │
                    ┌────────v────────┐
                    │ 金額 &gt; $100K ?   │
                    └───┬─────────┬───┘
                   Yes  │         │  No
                        v         v
              ┌──────────────┐  ┌──────────────┐
              │ 使用原生橋    │  │ 使用第三方    │
              │ (L1&lt;-&gt;L2)    │  │ 快速橋       │
              │ 或 Light     │  │ (Across,     │
              │ Client 橋    │  │  Stargate)    │
              └──────────────┘  └──────────────┘
</code></pre>
<h3 id="目的鏈最終性達標才入帳"><a class="header" href="#目的鏈最終性達標才入帳">目的鏈最終性達標才入帳</a></h3>
<p>在目標鏈執行跨鏈操作前，必須等待來源鏈上的交易達到經濟最終性。對於 Optimistic Rollup 的 L2→L1 提款，這意味著等待 7 天的挑戰期。對於 ZK Rollup，則等待 validity proof 在 L1 上被驗證。</p>
<p><strong>實作建議</strong>：建立一個 finality oracle 服務，根據不同鏈的特性自動計算所需的確認數。將最終性確認邏輯放在橋的 relayer 端，而非合約端——因為最終性規則可能需要根據網路狀況動態調整。</p>
<pre><code class="language-solidity">// 虛擬碼：動態最終性確認
function getRequiredConfirmations(
    uint256 chainId,
    uint256 amount
) public view returns (uint256) {
    uint256 baseConfirmations = chainConfirmations[chainId];

    // 大額交易需要更多確認
    if (amount &gt; HIGH_VALUE_THRESHOLD) {
        return baseConfirmations * 2;
    }

    return baseConfirmations;
}
</code></pre>
<h3 id="其他防禦建議"><a class="header" href="#其他防禦建議">其他防禦建議</a></h3>
<ul>
<li><strong>多橋驗證</strong>：對於高價值操作，可以同時透過兩個獨立的橋傳遞訊息，只有兩個橋都確認才執行。這增加了成本和延遲，但大幅提高了安全性。</li>
<li><strong>橋監控與告警</strong>：部署即時監控系統，追蹤橋的 TVL 變化、異常大額轉帳、驗證者行為異常等指標。設定告警閾值，在異常發生時第一時間通知團隊。</li>
<li><strong>緊急暫停機制</strong>：橋合約必須具備 <code>pause()</code> 功能，並且暫停操作的門檻應低於正常操作門檻。建議設定自動暫停觸發條件，例如「單一小時內跨鏈金額超過 TVL 的 25%」自動暫停。</li>
<li><strong>保險與風險對沖</strong>：對於管理大量用戶資金的協議，考慮透過 Nexus Mutual 等鏈上保險協議為跨鏈風險投保。</li>
</ul>
<h2 id="白話總結-7"><a class="header" href="#白話總結-7">白話總結</a></h2>
<p>跨鏈橋可以想像成國際銀行之間的匯款系統。你在台灣的銀行（Chain A）匯錢到美國的銀行（Chain B），台灣的銀行會凍結你的存款，然後通知美國的銀行給收款人等額的美金。問題在於：兩家銀行怎麼信任彼此的通知？</p>
<p>最安全的方式是兩家銀行各自派人到對方銀行駐點查帳（Light Client Bridge），但這成本很高。比較便宜的方式是找一群公證人來見證（External Validator Bridge），但如果公證人被收買就完了。還有一種方式是先匯款後讓對方有時間檢查是否有問題（Optimistic Rollup），或者附上一份數學證明讓對方一看就知道匯款是真的（ZK Rollup）。</p>
<p>L2 的存在是因為以太坊主鏈就像一條繁忙的高速公路，車太多就會塞車（gas 費飆高）。L2 就像是在旁邊蓋了快速道路，把大部分的車引導到那裡，只有收費站（結算）還在主幹道上。Optimistic Rollup 像是「先放行，出問題再罰款」，ZK Rollup 像是「每台車都要先出示通行證才能上路」。</p>
<p>跨鏈橋是目前區塊鏈生態中最危險的環節之一。歷史上的攻擊事件已經造成超過 25 億美元的損失。防禦的核心思想是：不信任任何單一組件，用多層防禦來降低風險。速率限制、分批處理、等待最終性確認、以及緊急暫停機制，都是工程團隊必須內建的安全措施。</p>
<p>選擇跨鏈橋時，安全性永遠比速度和成本重要。大額資金應使用原生橋或 light client 橋，只有小額快速轉帳才考慮使用信任假設較弱的第三方橋。記住：你的資產的安全性取決於橋的最弱環節。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9-defi-原語與組合性"><a class="header" href="#9-defi-原語與組合性">9. DeFi 原語與組合性</a></h1>
<h2 id="91-基本原語"><a class="header" href="#91-基本原語">9.1 基本原語</a></h2>
<p>DeFi（Decentralized Finance，去中心化金融）的核心理念是將傳統金融服務拆解為可程式化、可組合的「原語」（primitives）。每個原語都是一個獨立的智能合約或合約系統，提供特定的金融功能。這些原語可以像樂高積木一樣自由組合，創造出傳統金融難以實現的複雜金融產品。</p>
<h3 id="ammautomated-market-maker自動做市商"><a class="header" href="#ammautomated-market-maker自動做市商">AMM（Automated Market Maker，自動做市商）</a></h3>
<p>AMM 是 DeFi 中最基礎的原語之一，它取代了傳統交易所的訂單簿模式，使用數學公式和流動性池來自動定價和撮合交易。</p>
<p><strong>恆定乘積公式 x * y = k</strong></p>
<p>Uniswap V2 引入的 <code>x * y = k</code> 是最經典的 AMM 公式。其中 x 和 y 分別代表池中兩種 token 的數量，k 是一個常數。當交易者買入 token A 時，池中 A 的數量減少，B 的數量增加，價格因此變動。這個公式保證了流動性在任何價格區間都可用，但代價是資本效率低——大部分流動性分散在不太可能被使用到的價格區間。</p>
<pre><code class="language-text">恆定乘積曲線 x * y = k：

    y (Token B)
    │
    │
    │╲
    │  ╲
    │    ╲             ← 大部分流動性在這裡
    │      ╲              但很少有交易在這個價格
    │        ╲
    │          ╲
    │            ╲
    │              ╲
    │                ╲___________
    │                            ← 實際交易集中在這個區域
    └──────────────────────────── x (Token A)

交易範例：
  池子初始狀態: x=1000 ETH, y=2,000,000 USDC (k=2,000,000,000)
  價格: 1 ETH = 2000 USDC

  買入 10 ETH：
  新 x = 1000 - 10 = 990
  新 y = k / 990 = 2,020,202 USDC
  用戶支付 = 2,020,202 - 2,000,000 = 20,202 USDC
  實際價格 = 20,202 / 10 = 2,020.2 USDC/ETH （含滑點）
</code></pre>
<p><strong>集中流動性（Concentrated Liquidity）</strong></p>
<p>Uniswap V3 引入了集中流動性的概念，允許流動性提供者（LP）將資金集中在特定的價格區間。例如，如果 LP 認為 ETH/USDC 的價格會在 1,800-2,200 之間波動，就只在這個區間提供流動性。這大幅提高了資本效率（理論上可達 4,000 倍），但也增加了 LP 的管理複雜度和無常損失（Impermanent Loss）的風險。</p>
<pre><code class="language-text">Uniswap V3 集中流動性 vs V2 均勻流動性：

V2（均勻分佈）：                    V3（集中在 $1800-$2200）：
流動性                              流動性
│████████████████████│               │                    │
│████████████████████│               │    ┌──────────┐    │
│████████████████████│               │    │██████████│    │
│████████████████████│               │    │██████████│    │
│████████████████████│               │    │██████████│    │
└────────────────────                └────────────────────
$0        $∞                         $1800       $2200
  相同的資金，V3 在目標區間的深度遠大於 V2
</code></pre>
<p><strong>常見 AMM 變體</strong>：</p>
<ul>
<li><strong>Curve（StableSwap）</strong>：針對穩定幣對優化的 AMM 曲線，在接近 1:1 的價格區間提供極低滑點。使用修改後的 <code>x + y = k</code> 和 <code>x * y = k</code> 的混合公式。</li>
<li><strong>Balancer</strong>：支援多資產池（最多 8 種 token）和自定義權重（例如 80/20 而非 50/50）。</li>
<li><strong>Maverick、Trader Joe V2</strong>：使用 bin-based 的流動性分佈，進一步細化流動性管理。</li>
</ul>
<h3 id="lending借貸協議"><a class="header" href="#lending借貸協議">Lending（借貸協議）</a></h3>
<p>借貸協議允許使用者存入資產賺取利息，或抵押資產借出其他資產。這是 DeFi 中 TVL（Total Value Locked）最大的類別。</p>
<p><strong>核心機制</strong>：</p>
<pre><code class="language-text">借貸協議運作流程：

存款方 (Lender)                    借款方 (Borrower)
┌──────────────┐                  ┌──────────────┐
│ 存入 1000    │                  │ 存入 2 ETH   │
│ USDC         │                  │ 作為抵押品    │
│              │                  │              │
│ 獲得 cUSDC   │                  │ 借出 1500    │
│ (計息代幣)   │                  │ USDC         │
└──────┬───────┘                  └──────┬───────┘
       │                                 │
       v                                 v
┌─────────────────────────────────────────────────┐
│              Lending Pool                         │
│                                                   │
│  USDC Pool: 10,000 USDC                          │
│  利用率: 75%                                      │
│  存款 APY: 3.5%  (隨利用率動態調整)                │
│  借款 APY: 5.2%  (利差 = 協議收入)                 │
│                                                   │
│  利率曲線：                                        │
│  APY                                              │
│  │                           ╱                    │
│  │                         ╱                      │
│  │                       ╱  ← 超過最優利用率       │
│  │                     ╱      利率急劇上升         │
│  │          ╱─────────╱                            │
│  │        ╱                                       │
│  │      ╱                                         │
│  │    ╱                                           │
│  └──╱──────────────────────── 利用率               │
│     0%    50%   80%  90%  100%                     │
│                  ↑                                 │
│            最優利用率(kink)                          │
└─────────────────────────────────────────────────┘
</code></pre>
<p><strong>健康因子（Health Factor）</strong></p>
<p>健康因子是衡量借款人抵押品安全程度的核心指標。計算公式為：</p>
<pre><code>Health Factor = (抵押品價值 × 清算門檻) / 借款總額

範例：
  抵押品: 2 ETH × $2,000 = $4,000
  清算門檻: 82.5% (ETH 在 Aave 上的設定)
  借款: $2,500 USDC

  Health Factor = ($4,000 × 0.825) / $2,500 = 1.32

  HF &gt; 1.0: 安全（目前狀態）
  HF = 1.0: 觸發清算
  HF &lt; 1.0: 理論上不應出現（清算機器人會搶先）
</code></pre>
<p><strong>清算機制（Liquidation）</strong></p>
<p>當借款人的健康因子降至 1.0 以下時，任何人都可以代為償還部分借款並獲得折價的抵押品作為獎勵。清算獎勵通常為 5-10%。清算機制確保協議始終保持超額抵押，是借貸協議安全性的基石。</p>
<pre><code class="language-text">清算流程：

ETH 價格從 $2,000 跌至 $1,500
┌────────────────────────────────────────┐
│  借款人原始狀態:                        │
│  抵押: 2 ETH × $2,000 = $4,000         │
│  借款: $2,500 USDC                      │
│  HF = ($4,000 × 0.825) / $2,500 = 1.32 │
│                                          │
│  價格下跌後:                             │
│  抵押: 2 ETH × $1,500 = $3,000         │
│  借款: $2,500 USDC                      │
│  HF = ($3,000 × 0.825) / $2,500 = 0.99 │
│  → 觸發清算！                            │
│                                          │
│  清算人操作:                             │
│  償還: $1,250 USDC (50% close factor)   │
│  獲得: $1,250 × 1.05 = $1,312.5 等值   │
│         的 ETH (含 5% 清算獎勵)          │
│  利潤: $62.5                             │
└────────────────────────────────────────┘
</code></pre>
<p><strong>代表項目</strong>：Aave、Compound、Morpho（點對點匹配 + 池模式混合）。</p>
<h3 id="derivatives衍生品協議"><a class="header" href="#derivatives衍生品協議">Derivatives（衍生品協議）</a></h3>
<p>鏈上衍生品協議將傳統金融中的期貨、期權等工具帶到 DeFi 中。其中永續合約（Perpetual Contract）是最受歡迎的產品。</p>
<p><strong>永續合約</strong></p>
<p>永續合約是一種沒有到期日的衍生品。交易者可以做多（看漲）或做空（看跌），並使用槓桿放大收益和風險。永續合約的價格透過「資金費率」（Funding Rate）機制錨定在現貨價格附近。</p>
<p><strong>資金費率（Funding Rate）</strong></p>
<p>資金費率是永續合約獨有的機制，每隔一段時間（通常 8 小時）在多空雙方之間結算一次。當市場看多情緒過強（永續價格 &gt; 現貨價格）時，多頭向空頭支付資金費率，反之亦然。這個機制激勵交易者對抗主流方向，將永續價格拉回現貨價格。</p>
<pre><code class="language-text">資金費率機制：

永續價格 &gt; 現貨價格 (正基差)：
  多頭 ──── 支付費率 ────&gt; 空頭
  效果：鼓勵做空，抑制做多，拉回價格

永續價格 &lt; 現貨價格 (負基差)：
  空頭 ──── 支付費率 ────&gt; 多頭
  效果：鼓勵做多，抑制做空，推升價格

結算頻率：通常每 8 小時
費率計算：Funding Rate = clamp(TWAP(永續 - 現貨) / 現貨, -0.05%, +0.05%)
</code></pre>
<p><strong>鏈上衍生品的挑戰</strong>：</p>
<ul>
<li><strong>Oracle 延遲</strong>：價格更新的延遲讓攻擊者可以「搶先交易」（front-running）。解法包括使用 Pyth Network 的 pull oracle 模式，或在交易提交和執行之間加入延遲（GMX V2 的做法）。</li>
<li><strong>流動性碎片化</strong>：不同交易對的流動性分散在各自的市場中。共享流動性模型（如 GMX 的 GLP/GM 池）試圖解決這個問題。</li>
<li><strong>Gas 成本</strong>：複雜的保證金計算和倉位管理需要大量 gas，這也是為什麼大多數鏈上衍生品協議部署在 L2 上。</li>
</ul>
<p><strong>代表項目</strong>：GMX（Arbitrum/Avalanche）、dYdX（自建 L2 → Cosmos 鏈）、Synthetix Perps（Optimism）、Hyperliquid（自建 L1）。</p>
<h3 id="stablecoin穩定幣"><a class="header" href="#stablecoin穩定幣">Stablecoin（穩定幣）</a></h3>
<p>穩定幣是 DeFi 的基礎貨幣，旨在將價格穩定在 1 美元（或其他法幣）附近。根據其穩定機制可分為三大類：</p>
<p><strong>抵押型穩定幣（Collateralized）</strong></p>
<p>使用加密資產作為超額抵押來鑄造穩定幣。代表項目是 MakerDAO 的 DAI。使用者需要存入至少 150% 價值的 ETH（或其他抵押品）來鑄造 DAI。</p>
<pre><code class="language-text">超額抵押鑄造 DAI：

用戶存入 $3,000 等值的 ETH
         │
         v
┌─────────────────────────────┐
│      MakerDAO CDP / Vault    │
│                               │
│  抵押品: $3,000 ETH           │
│  鑄造: 2,000 DAI              │
│  抵押率: 150%                 │
│  最低抵押率: 150%             │
│                               │
│  穩定費(年利率): 3.5%         │
│  → 用戶需支付 DAI 借款利息     │
│                               │
│  若 ETH 跌至抵押率 &lt; 150%     │
│  → 觸發清算                   │
└─────────────────────────────┘
         │
         v
用戶獲得 2,000 DAI（可在 DeFi 中使用）
</code></pre>
<p><strong>演算法穩定幣（Algorithmic）</strong></p>
<p>不依賴外部抵押品，而是透過演算法和套利機制來維持價格穩定。這類穩定幣的歷史充滿了失敗案例。</p>
<p><strong>案例分析——UST/LUNA 崩盤（2022 年 5 月）</strong>：Terra 的 UST 使用雙代幣機制：1 UST 可以兌換 $1 等值的 LUNA。當 UST 價格低於 $1 時，套利者燒毀 UST 換取 LUNA 並在市場上賣出，減少 UST 供應推升價格。但在極端拋壓下，大量 UST 被兌換成 LUNA，LUNA 供應暴增導致價格崩盤，進而加劇 UST 的脫鉤——形成「死亡螺旋」。最終 UST 和 LUNA 雙雙歸零，市場損失超過 400 億美元。</p>
<p><strong>法幣儲備型穩定幣（Fiat-Backed）</strong></p>
<p>由法幣或等價物（短期國債、銀行存款等）1:1 背書。代表項目包括 USDC（Circle）和 USDT（Tether）。這類穩定幣的信任模型依賴於發行方的信譽和定期審計。</p>
<div class="table-wrapper"><table><thead><tr><th>穩定幣類型</th><th>代表</th><th>優點</th><th>缺點</th></tr></thead><tbody>
<tr><td>抵押型</td><td>DAI、LUSD</td><td>去中心化、透明</td><td>資本效率低（超額抵押）</td></tr>
<tr><td>演算法型</td><td>FRAX（混合）、歷史上的 UST</td><td>資本效率高</td><td>極端行情下可能脫鉤崩盤</td></tr>
<tr><td>法幣儲備型</td><td>USDC、USDT</td><td>穩定性最高、流動性最好</td><td>中心化、監管風險、凍結風險</td></tr>
</tbody></table>
</div>
<h2 id="92-系統風險"><a class="header" href="#92-系統風險">9.2 系統風險</a></h2>
<p>DeFi 系統的風險往往是系統性的——單一協議的問題可能透過組合性傳導到整個生態系統。理解這些系統風險是工程師設計穩健協議的前提。</p>
<h3 id="流動性枯竭"><a class="header" href="#流動性枯竭">流動性枯竭</a></h3>
<p>當市場恐慌時，流動性提供者會迅速撤出資金（即「bank run」效應），導致池子深度驟降、滑點暴增、甚至無法執行交易。借貸協議在這種情況下尤其脆弱——存款人爭相提款，但大部分資金已被借出，導致利用率飆升到接近 100%。</p>
<pre><code class="language-text">流動性危機的連鎖反應：

┌──────────────┐     ┌──────────────┐     ┌──────────────┐
│ 市場恐慌      │     │ LP 大量撤出   │     │ 滑點暴增     │
│ (黑天鵝事件)  │────&gt;│ 流動性       │────&gt;│ 交易無法     │
│              │     │              │     │ 正常執行     │
└──────────────┘     └──────────────┘     └──────┬───────┘
                                                  │
                              ┌────────────────────┘
                              v
                     ┌──────────────┐     ┌──────────────┐
                     │ 清算無法完成  │     │ 壞帳產生     │
                     │ (滑點太大    │────&gt;│ 協議資不     │
                     │  清算無利可圖)│     │ 抵債         │
                     └──────────────┘     └──────────────┘
</code></pre>
<p><strong>真實案例</strong>：2023 年 3 月 USDC 脫鉤事件中（受矽谷銀行倒閉影響），Curve 的 3pool（DAI/USDC/USDT）出現嚴重的流動性失衡——USDC 佔比飆升至 70% 以上，DAI 和 USDT 幾乎被換光。</p>
<p><strong>防禦措施</strong>：設定協議層級的流動性底線（minimum liquidity threshold），當流動性低於閾值時自動限制新借款或大額交易。建立協議儲備金（protocol-owned liquidity）作為緩衝。</p>
<h3 id="oracle-延遲或操縱"><a class="header" href="#oracle-延遲或操縱">Oracle 延遲或操縱</a></h3>
<p>Oracle 是 DeFi 的「眼睛」，幾乎所有需要價格資訊的操作都依賴 Oracle。Oracle 的延遲或被操縱會直接導致錯誤的定價，進而被攻擊者利用。</p>
<p><strong>延遲問題</strong>：鏈下價格已經大幅變動，但 Oracle 更新有延遲（Chainlink 通常有 heartbeat interval 和 deviation threshold），攻擊者利用過時價格進行套利。</p>
<p><strong>操縱問題</strong>：攻擊者透過閃電貸在 DEX 上大幅推動價格，如果 DeFi 協議使用該 DEX 的即時價格作為 Oracle，就會被操縱。</p>
<pre><code class="language-text">Oracle 操縱攻擊流程：

Step 1: 攻擊者借入 $10M 閃電貸
Step 2: 在 DEX 上大量買入 Token X，推高價格 50%
Step 3: 在使用該 DEX 價格的借貸協議中，
        用 Token X 作為抵押品（被高估）借出大量穩定幣
Step 4: 歸還閃電貸
Step 5: DEX 價格恢復正常，但攻擊者已帶走超額借款
結果: 借貸協議產生壞帳
</code></pre>
<p><strong>防禦措施</strong>：使用 Chainlink 等去中心化 Oracle（聚合多個資料源）。設定合理的價格偏差閾值。對於低流動性 token，不應作為借貸抵押品。實作 TWAP（Time-Weighted Average Price）緩衝突發價格波動。</p>
<h3 id="清算擁塞"><a class="header" href="#清算擁塞">清算擁塞</a></h3>
<p>在市場大幅下跌時，大量倉位同時觸發清算，導致清算機器人之間的 gas 競爭（gas war），推高 gas 費用，讓部分清算交易無法及時執行。同時，大量清算拋售進一步壓低價格，形成負面循環。</p>
<p><strong>2020 年 3 月 12 日「黑色星期四」</strong>：ETH 價格在 24 小時內暴跌 50%，MakerDAO 系統中的大量 CDP 需要清算。由於 gas 費用暴漲和以太坊網路擁塞，許多清算交易失敗或延遲，部分清算人甚至以 0 DAI 的出價贏得了拍賣（因為沒有競爭者），導致 MakerDAO 產生約 530 萬美元的壞帳。</p>
<p><strong>防禦措施</strong>：</p>
<ul>
<li>引入漸進式清算（partial liquidation），而非一次性全額清算</li>
<li>為清算機器人提供優先通道（如 Flashbots 的 MEV 拍賣）</li>
<li>設定緊急價格底線（circuit breaker），當價格在短時間內下跌超過閾值時暫停清算</li>
<li>使用荷蘭拍賣（Dutch auction）機制，讓清算價格從高到低遞減，確保有競爭者參與</li>
</ul>
<h3 id="參數治理失誤"><a class="header" href="#參數治理失誤">參數治理失誤</a></h3>
<p>DeFi 協議的許多關鍵參數（利率模型、抵押率、清算獎勵等）由社群治理決定。如果參數設定不當，可能導致嚴重的經濟後果。</p>
<p><strong>常見的參數治理風險</strong>：</p>
<ul>
<li><strong>抵押率設太低</strong>：市場快速下跌時來不及清算，產生壞帳</li>
<li><strong>清算獎勵設太低</strong>：無人願意執行清算，壞帳累積</li>
<li><strong>利率曲線斜率不當</strong>：利用率 100% 時利率不夠高，無法激勵還款</li>
<li><strong>新增高風險抵押品</strong>：為追求 TVL 增長而上架低流動性、高波動的 token 作為抵押品</li>
</ul>
<p><strong>案例分析——Aave 凍結 CRV 市場（2022 年）</strong>：攻擊者透過在 Aave 上大量借入 CRV 做空，利用 CRV 的低流動性嘗試製造清算瀑布。雖然攻擊最終未成功（CRV 價格未崩盤），但 Aave 還是產生了約 170 萬美元的壞帳，並因此凍結了 CRV 的借貸功能。</p>
<h2 id="93-交易路由層"><a class="header" href="#93-交易路由層">9.3 交易路由層</a></h2>
<p>在 DeFi 中執行交易不像在中心化交易所那麼簡單。流動性分散在數十個 DEX、數百個流動性池中，找到最優的交易路徑是一個複雜的路由問題。</p>
<h3 id="aggregator-比價"><a class="header" href="#aggregator-比價">Aggregator 比價</a></h3>
<p>DEX Aggregator（如 1inch、ParaSwap、CowSwap）會同時查詢多個 DEX 的價格，找到給定交易量下的最優路徑。對於大額交易，Aggregator 可能會將交易拆分到多個 DEX 以減少滑點。</p>
<pre><code class="language-text">Aggregator 路由邏輯：

用戶: 賣出 100 ETH 買入 USDC

直接在 Uniswap V3 交易:
  100 ETH → Uniswap V3 → 199,500 USDC (滑點 0.25%)

Aggregator 優化路由:
  ┌── 40 ETH → Uniswap V3 ──→  80,200 USDC
  │
  ├── 35 ETH → Curve ETH/USDC → 70,140 USDC
  │
  └── 25 ETH → SushiSwap ─────→ 50,050 USDC
                                 ──────────────
                        Total:   200,390 USDC (多得 890 USDC)
</code></pre>
<h3 id="multi-hop-路徑"><a class="header" href="#multi-hop-路徑">Multi-hop 路徑</a></h3>
<p>有時最優路徑不是直接交易，而是透過中間 token 進行多跳交易。例如將 Token A 換成 Token C，直接 A→C 的池子流動性不佳，但 A→ETH→C 的路徑可能更優。</p>
<pre><code class="language-text">Multi-hop 路由範例：

直接路徑（低流動性）：
  LINK ──────────────────────&gt; MKR
  滑點: 3.5%

Multi-hop 路徑（高流動性中間池）：
  LINK ──&gt; ETH ──&gt; USDC ──&gt; MKR
  滑點:  0.1%   0.05%    0.2%  = 0.35% 總滑點

  節省滑點: 3.15%
</code></pre>
<p><strong>路由演算法</strong>：大部分 Aggregator 使用圖搜尋演算法（類似 Dijkstra 或 Bellman-Ford），將每個流動性池視為圖中的邊，權重為交易成本（滑點 + 手續費 + gas）。目標是找到從輸入 token 到輸出 token 的最低成本路徑。</p>
<h3 id="mev-保護與最小輸出"><a class="header" href="#mev-保護與最小輸出">MEV 保護與最小輸出</a></h3>
<p>MEV（Maximal Extractable Value）是指區塊生產者或 Searcher 透過重新排序、插入或刪除交易來獲取的利潤。對普通用戶而言，MEV 通常意味著被「夾擊」（sandwich attack）。</p>
<pre><code class="language-text">Sandwich Attack（三明治攻擊）：

正常交易:
  User: 賣出 10 ETH → 買入 USDC

被夾擊後:
  1. 攻擊者先買: 買入大量 ETH → 推高 ETH 價格
  2. User 的交易執行: 以更高的價格買到更少的 USDC
  3. 攻擊者後賣: 賣出 ETH → 獲利

時間線:
  ┌──────────┐  ┌──────────┐  ┌──────────┐
  │攻擊者    │  │ User 的   │  │攻擊者    │
  │前置交易   │──│ 交易     │──│後置交易   │
  │(買 ETH)  │  │(賣 ETH)  │  │(賣 ETH)  │
  └──────────┘  └──────────┘  └──────────┘
  在同一個區塊內，攻擊者控制交易順序
</code></pre>
<p><strong>防禦措施</strong>：</p>
<ul>
<li><strong>設定最小輸出量（minAmountOut）</strong>：確保即使被夾擊，損失也在可接受範圍內。例如設定 0.5% 的滑點容忍度。</li>
<li><strong>使用 MEV 保護服務</strong>：如 Flashbots Protect 或 CowSwap（批次拍賣模式，天然抗 MEV）。</li>
<li><strong>Private mempool</strong>：將交易發送到私有記憶池，避免被公開 mempool 中的 Searcher 看到。</li>
<li><strong>Transaction deadline</strong>：設定交易的有效期限，避免交易在 mempool 中停留過久被攻擊。</li>
</ul>
<pre><code class="language-solidity">// 防 MEV 的交易參數設定
function swapExactTokensForTokens(
    uint256 amountIn,
    uint256 amountOutMin,    // 最小輸出量（防滑點 + 防 MEV）
    address[] calldata path,
    address to,
    uint256 deadline          // 交易截止時間
) external returns (uint256[] memory amounts);

// 建議的 amountOutMin 計算
// amountOutMin = expectedOutput * (1 - slippageTolerance)
// 例如: expectedOutput = 2000 USDC, slippage = 0.5%
// amountOutMin = 2000 * 0.995 = 1990 USDC
</code></pre>
<h2 id="94-組合性收益與風險"><a class="header" href="#94-組合性收益與風險">9.4 組合性收益與風險</a></h2>
<p>DeFi 的「可組合性」（Composability）是其最大的特色和最大的風險來源。不同協議之間可以自由互操作，創造出比單一協議更複雜的金融策略。</p>
<h3 id="收益來自費率與槓桿"><a class="header" href="#收益來自費率與槓桿">收益來自費率與槓桿</a></h3>
<p>DeFi Yield 的來源可以歸納為以下幾類：</p>
<ol>
<li><strong>交易手續費</strong>：LP 從每筆交易中收取手續費（通常 0.01%-1%）</li>
<li><strong>借貸利差</strong>：存款利率和借款利率之間的差額</li>
<li><strong>流動性挖礦獎勵</strong>：協議發放治理代幣作為激勵（但這本質上是代幣通膨稀釋）</li>
<li><strong>套利收益</strong>：不同協議或不同鏈之間的價格差異</li>
<li><strong>槓桿收益</strong>：透過循環借貸放大收益（但也放大風險）</li>
</ol>
<pre><code class="language-text">循環借貸槓桿策略（Looping）：

Step 1: 存入 1,000 USDC 到 Aave           → 獲得存款利息
Step 2: 借出 750 USDC (75% LTV)            → 支付借款利息
Step 3: 再存入 750 USDC 到 Aave            → 獲得更多存款利息
Step 4: 再借出 562 USDC                    → 支付更多借款利息
Step 5: 再存入 562 USDC ...
...

最終：
  總存款 ≈ 4,000 USDC（原始 1,000 的 4 倍槓桿）
  總借款 ≈ 3,000 USDC
  淨收益 = (存款利息 × 4,000) - (借款利息 × 3,000) + 獎勵代幣

風險：如果存款利率下降或借款利率上升，策略可能虧損
風險：如果 USDC 脫鉤，可能觸發清算
</code></pre>
<h3 id="風險來自協議依賴鏈"><a class="header" href="#風險來自協議依賴鏈">風險來自協議依賴鏈</a></h3>
<p>當策略依賴多個協議時，任何一個協議的問題都可能導致整個策略失敗。這種依賴鏈的長度決定了策略的風險倍數。</p>
<pre><code class="language-text">Yield Aggregator 的依賴鏈示例：

User -&gt; Vault -&gt; Strategy A (Lending on Aave)
              │   依賴: Aave 合約 + Chainlink Oracle + USDC 穩定性
              │
              ├─&gt; Strategy B (LP Farming on Uniswap V3)
              │   依賴: Uniswap V3 合約 + LP 池流動性 + Token 價格穩定
              │
              └─&gt; Strategy C (Basis Trade on GMX)
                  依賴: GMX 合約 + GLP 池 + 多個 Oracle + Arbitrum L2 正常運作

總依賴數: ~15 個獨立組件
任一組件故障都可能影響 Vault 的整體收益甚至本金

依賴風險矩陣：
┌──────────────────┬────────────────┬──────────────┐
│ 依賴類型          │ 故障影響        │ 歷史故障頻率  │
├──────────────────┼────────────────┼──────────────┤
│ 智能合約漏洞      │ 本金損失        │ 低但致命     │
│ Oracle 異常       │ 錯誤定價/清算   │ 中           │
│ L2 停機          │ 無法操作        │ 低           │
│ 穩定幣脫鉤       │ 策略失效        │ 低但影響大   │
│ 治理攻擊         │ 參數被惡意修改  │ 低           │
│ 流動性枯竭       │ 無法退出        │ 中           │
└──────────────────┴────────────────┴──────────────┘
</code></pre>
<p><strong>真實案例——Yearn Finance Vault 損失（2021 年 2 月）</strong>：Yearn 的 DAI Vault 使用了一個策略，該策略在 Curve 和 Aave 之間套利。攻擊者利用閃電貸操縱 Curve 池的價格，導致策略在錯誤的價格下執行，造成約 1,100 萬美元損失。這個事件展示了多協議組合策略的風險放大效應。</p>
<h2 id="95-工程建議"><a class="header" href="#95-工程建議">9.5 工程建議</a></h2>
<p>作為 DeFi 協議的工程師或 Yield Strategy 的開發者，以下是設計穩健系統的實踐建議：</p>
<h3 id="對外協議設定風險分數"><a class="header" href="#對外協議設定風險分數">對外協議設定風險分數</a></h3>
<p>為每個依賴的外部協議建立風險評估框架。風險分數應考慮以下維度：</p>
<pre><code class="language-text">風險評分模型（1-10 分，10 分最安全）：

┌──────────────────────────────────────────────┐
│           外部協議風險評分卡                     │
│                                                │
│  維度              權重    Aave    新協議 X     │
│  ─────────────     ────    ────    ─────────   │
│  審計次數與品質     20%     9        4          │
│  運行時間(月)       15%     10       2          │
│  TVL 規模          10%     9        3          │
│  開源程度           10%     10       7          │
│  治理去中心化       15%     8        3          │
│  歷史安全紀錄       20%     8        5(未知)    │
│  Oracle 可靠性      10%     9        5          │
│  ─────────────     ────    ────    ─────────   │
│  加權總分           100%    8.85     3.8        │
│                                                │
│  風險等級:                                      │
│  8-10: 低風險 (可配置高比例資金)                  │
│  5-7:  中風險 (限制配置比例)                      │
│  1-4:  高風險 (極少配置或不配置)                   │
└──────────────────────────────────────────────┘
</code></pre>
<h3 id="依分數配置資金上限"><a class="header" href="#依分數配置資金上限">依分數配置資金上限</a></h3>
<p>根據風險分數設定每個外部協議的最大資金配置比例。這樣即使某個協議被攻破，損失也被限制在可承受範圍內。</p>
<pre><code class="language-text">資金配置規則：

總 Vault 資金: $10M

┌─────────────┬─────────┬───────────┬──────────────┐
│ 策略        │ 風險分數 │ 最大配置%  │ 最大配置金額  │
├─────────────┼─────────┼───────────┼──────────────┤
│ Aave 借貸   │ 8.85    │ 40%       │ $4M          │
│ Uniswap LP  │ 8.2     │ 30%       │ $3M          │
│ GMX 永續    │ 7.0     │ 20%       │ $2M          │
│ 新協議 X    │ 3.8     │ 5%        │ $500K        │
│ 現金儲備    │ -       │ 5%        │ $500K        │
└─────────────┴─────────┴───────────┴──────────────┘

公式: max_allocation = base_allocation × (risk_score / 10)^2
</code></pre>
<h3 id="任一依賴異常時觸發策略降檔"><a class="header" href="#任一依賴異常時觸發策略降檔">任一依賴異常時觸發策略降檔</a></h3>
<p>建立即時監控系統，當偵測到任何依賴協議出現異常時，自動觸發防禦機制：</p>
<pre><code class="language-text">策略降檔流程：

正常狀態 (Level 0)
     │
     │ 偵測到異常信號（Oracle 延遲 &gt; 30 分鐘、TVL 驟降 &gt; 20%、合約暫停等）
     v
警戒狀態 (Level 1)
  - 停止新增配置到異常協議
  - 提高監控頻率
  - 通知團隊
     │
     │ 異常持續 &gt; 1 小時 或 損失 &gt; 閾值
     v
撤退狀態 (Level 2)
  - 開始從異常協議撤出資金
  - 轉移到低風險策略（如純穩定幣存款）
  - 暫停 Vault 的新存款
     │
     │ 確認安全事件
     v
緊急狀態 (Level 3)
  - 全部資金撤回 Vault
  - 暫停所有策略
  - 啟動 War Room
  - 用戶可提款但不可存款
</code></pre>
<pre><code class="language-solidity">// 策略降檔虛擬碼
contract VaultGuardian {
    enum AlertLevel { NORMAL, CAUTION, RETREAT, EMERGENCY }
    AlertLevel public currentLevel;

    function checkHealth() external {
        for (uint i = 0; i &lt; strategies.length; i++) {
            IStrategy strategy = strategies[i];

            // 檢查 Oracle 健康
            if (strategy.oracleDelay() &gt; MAX_ORACLE_DELAY) {
                _escalate(i, AlertLevel.CAUTION);
            }

            // 檢查 TVL 變化
            uint256 currentTVL = strategy.tvl();
            uint256 previousTVL = lastKnownTVL[i];
            if (currentTVL &lt; previousTVL * 80 / 100) {  // TVL 下降 &gt; 20%
                _escalate(i, AlertLevel.RETREAT);
            }

            // 檢查合約是否被暫停
            if (strategy.isPaused()) {
                _escalate(i, AlertLevel.EMERGENCY);
            }
        }
    }

    function _escalate(uint256 strategyIndex, AlertLevel level) internal {
        if (level == AlertLevel.RETREAT) {
            strategies[strategyIndex].withdrawAll();
        }
        emit AlertEscalated(strategyIndex, level);
    }
}
</code></pre>
<h3 id="其他工程建議"><a class="header" href="#其他工程建議">其他工程建議</a></h3>
<ul>
<li><strong>策略回測</strong>：在部署新策略前，使用歷史資料（包括黑天鵝事件期間的資料）進行回測。重點關注最大回撤（max drawdown）和極端市場條件下的行為。</li>
<li><strong>漸進式部署</strong>：新策略先用小額資金（例如 TVL 的 1%）試運行至少 2 週，確認無異常後再逐步增加配置。</li>
<li><strong>退出路徑驗證</strong>：定期測試所有策略的緊急退出路徑，確保在極端情況下能在合理時間內（例如 2 個區塊內）撤回全部資金。</li>
<li><strong>Gas 成本監控</strong>：在 gas 費用暴漲時（例如超過 200 gwei），某些低收益策略的 gas 成本可能超過收益。建立 gas 成本監控，在不划算時自動暫停策略的 harvest/rebalance 操作。</li>
<li><strong>事件日誌完整性</strong>：所有資金流動都必須發出事件（event），確保鏈下監控系統能完整追蹤 Vault 的狀態。</li>
</ul>
<h2 id="白話總結-8"><a class="header" href="#白話總結-8">白話總結</a></h2>
<p>DeFi 可以想像成一個開放的金融工具箱。AMM 是自動收銀台——你不需要找人對手交易，丟錢進去機器就會按公式算好價格給你兌換。借貸協議是數位當鋪——你把值錢的東西抵押進去，就能借到錢，但如果抵押品跌價太多，當鋪會直接拍賣你的東西。永續合約是一種讓你用少量本金下大注的工具，贏了賺更多，輸了虧更快。穩定幣則是這個世界的「美元」，不同種類的穩定幣就像不同銀行發的支票，有些銀行大到不會倒（USDC/USDT），有些銀行用數學公式來保證支票能兌現（演算法穩定幣，但歷史上多次失敗）。</p>
<p>這些金融積木可以自由組合，產生更複雜的策略。例如你可以把 ETH 存到 Aave 借出 USDC，再把 USDC 投入 Uniswap 做流動性提供者，然後把 LP token 質押到 Yearn 的 Vault 自動管理。這種組合可以放大收益，但也放大了風險——如果其中任何一個環節出問題（Aave 被攻擊、USDC 脫鉤、Uniswap 池被操縱），你的整個策略可能一起崩盤。</p>
<p>交易路由在 DeFi 中非常重要。因為流動性分散在幾十個不同的 DEX 中，直接在一個 DEX 交易可能面臨很大的滑點。Aggregator 就像是比價網站，幫你在所有 DEX 中找到最好的價格，甚至把一筆大單拆成多筆小單分別在不同 DEX 執行。但要小心 MEV 攻擊——有人可能在你的交易前後插入交易來夾擊你，就像有人看到你要買某個商品，搶先買下來再加價賣給你。</p>
<p>作為工程師，最重要的原則是「永遠假設依賴的外部協議可能會出問題」。為每個外部依賴設定風險分數和資金上限，建立自動監控和降檔機制，確保即使最壞的情況發生，損失也在可控範圍內。DeFi 的歷史一再證明：收益越高的策略，背後的風險通常也越大，沒有「免費的午餐」。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-多簽金庫與治理結構"><a class="header" href="#10-多簽金庫與治理結構">10. 多簽、金庫與治理結構</a></h1>
<h2 id="101-多簽核心"><a class="header" href="#101-多簽核心">10.1 多簽核心</a></h2>
<p>多簽（M-of-N）是把單一簽名權分散成多個獨立持有人，降低單點失陷風險。在傳統金融中，大額轉帳需要多位主管簽核；區塊鏈上的多簽則是把這個流程寫死在合約邏輯裡，任何人都無法繞過。M-of-N 的意思是「N 把鑰匙中需要至少 M 把同意」，例如 3-of-5 代表五位簽名人中需要三位同意才能執行交易。</p>
<p>多簽的安全性取決於簽名人的獨立性與分散程度。如果五把鑰匙都放在同一間辦公室、由同一個 IT 管理員管理，那和單簽沒有本質區別。真正的多簽安全要求每位簽名人獨立保管自己的私鑰、使用不同品牌的硬體錢包、分布在不同的地理位置。</p>
<p>從技術實現來看，鏈上多簽主要有兩種模式：一種是像 Bitcoin 原生的 P2SH multisig，直接在腳本層實現；另一種是像 Ethereum 上的 Gnosis Safe（現稱 Safe），透過智能合約實現簽名收集與驗證。Safe 是目前 EVM 生態最主流的多簽方案，它支持模組化擴展、可升級、並且累計管理超過數百億美元的資產。</p>
<pre><code class="language-text">┌────────────────────────────────────────────────────┐
│              多簽運作模型（3-of-5）                  │
│                                                    │
│   Signer A ──┐                                     │
│   Signer B ──┤                                     │
│   Signer C ──┼──&gt; 合約驗證 ≥3 簽名 ──&gt; 執行交易    │
│   Signer D ──┤         ↑                           │
│   Signer E ──┘    nonce + chainId                  │
│                   防重放攻擊                        │
└────────────────────────────────────────────────────┘
</code></pre>
<p><strong>常見的 M-of-N 配置與適用場景：</strong></p>
<div class="table-wrapper"><table><thead><tr><th>配置</th><th>容錯能力</th><th>適用場景</th></tr></thead><tbody>
<tr><td>2-of-3</td><td>可失去 1 人</td><td>小型團隊日常操作</td></tr>
<tr><td>3-of-5</td><td>可失去 2 人</td><td>中型金庫、DAO treasury</td></tr>
<tr><td>4-of-7</td><td>可失去 3 人</td><td>大型協議根金庫</td></tr>
<tr><td>5-of-9</td><td>可失去 4 人</td><td>跨鏈橋 validator set</td></tr>
<tr><td>6-of-11</td><td>可失去 5 人</td><td>頂級 DeFi 協議</td></tr>
</tbody></table>
</div>
<p>選擇配置時要在安全性和可用性之間取得平衡：M 太高容易因為簽名人不在線而無法執行交易；M 太低則降低了攻擊者需要攻陷的目標數量。一般建議 M 至少為 N/2+1（過半數），且 N-M（容錯人數）不少於 2。</p>
<h2 id="102-典型金庫分層"><a class="header" href="#102-典型金庫分層">10.2 典型金庫分層</a></h2>
<p>金庫分層的核心思想是「不同安全等級的資金放在不同安全等級的保管方式裡」，就像銀行不會把所有現金都放在櫃台一樣。</p>
<p><strong>L0 Root Treasury：冷層</strong></p>
<p>Root Treasury 是組織的最高級別金庫，存放大部分長期持有的資產。典型配置為 3/5 或 4/7 多簽，簽名人使用離線硬體錢包，私鑰從未接觸過聯網設備。每筆交易需要 48-72 小時的 timelock，讓社群和監控系統有充足的時間檢查交易內容。Root Treasury 通常一個月才操作一兩次，主要用於向 L1 補充資金。</p>
<p>在實務中，Root Treasury 的簽名人應該分散在不同國家或至少不同城市，使用不同品牌的硬體錢包（例如一位用 Ledger、一位用 Trezor、一位用 GridPlus），並且透過帶外通訊（out-of-band communication）確認交易細節。</p>
<p><strong>L1 Ops Treasury：營運層</strong></p>
<p>Ops Treasury 是日常營運的主要資金來源，配置為 2/3 或 3/5 多簽，timelock 為 12-24 小時。這一層的簽名人是營運團隊的核心成員，他們需要較頻繁地簽署交易，例如合約部署、參數調整、獎勵發放等。L1 通常設有每日或每週的支出上限，超過上限的交易需要走 L0 流程。</p>
<p><strong>L2 Hot Wallet：熱層</strong></p>
<p>Hot Wallet 是面向用戶的最前線，用於小額、高頻的自動化操作，例如 gas 代付、小額空投、自動化做市等。通常是 1/1 簽名（由後端伺服器持有的 EOA），但嚴格限制單筆和每日的支出額度。Hot Wallet 的原則是「即使被盜也不會造成致命損失」。</p>
<pre><code class="language-text">                    ┌─────────────────────────┐
                    │   L0 Root Treasury      │
                    │   3/5 冷簽 + 48h lock   │
                    │   ~80% 資產              │
                    └──────────┬──────────────┘
                               │ 每月補充
                    ┌──────────▼──────────────┐
                    │   L1 Ops Treasury       │
                    │   2/3 溫簽 + 12h lock   │
                    │   ~15% 資產              │
                    └──────────┬──────────────┘
                               │ 每日補充
                    ┌──────────▼──────────────┐
                    │   L2 Hot Wallet         │
                    │   1/1 自動化 + 額度限制  │
                    │   ~5% 資產               │
                    └─────────────────────────┘
</code></pre>
<p><strong>案例研究：Ronin Bridge 事件（2022）</strong></p>
<p>Ronin Bridge 遭攻擊損失約 6.25 億美元，根本原因之一是 9 個 validator 中有 5 個由同一實體（Sky Mavis）控制或有權限存取，等同於把 5/9 多簽退化成了單點控制。攻擊者入侵 Sky Mavis 的基礎設施後，一次取得足夠的簽名權即可抽乾橋接資金。這個案例說明了「名義上的多簽」和「實質上的多簽」之間的巨大差異，也是為什麼金庫分層和真正的簽名人獨立性如此重要。</p>
<h2 id="103-權限分離"><a class="header" href="#103-權限分離">10.3 權限分離</a></h2>
<p>權限分離（Separation of Duties）是企業內控的基本原則，在區塊鏈上同樣適用。核心思想是「提出需求的人不應該是批准需求的人，批准的人也不應該是執行的人」。</p>
<p><strong>提案者（Proposer）</strong></p>
<p>提案者負責發起交易請求。在技術實現上，提案者構建交易的 calldata，指定目標合約、呼叫的函式、傳入的參數以及轉帳金額。提案者不需要是多簽的簽名人，他可以是開發團隊的工程師或自動化的 bot。重要的是提案必須包含充分的說明，解釋為什麼要執行這筆交易、預期的效果是什麼。</p>
<p><strong>審核者（Reviewer）</strong></p>
<p>審核者負責驗證提案的合理性。這包括：使用 Tenderly 或 Foundry 進行交易模擬、檢查 calldata 是否與聲稱的操作一致、確認目標地址不在黑名單中、評估交易的財務影響。審核者應該是與提案者不同的人，並且具備足夠的技術能力理解交易內容。</p>
<p><strong>執行者（Executor）</strong></p>
<p>執行者負責在鏈上提交最終交易。在有 timelock 的系統中，執行者在 timelock 到期後將交易從佇列中取出並上鏈。執行者可以是自動化系統，但前提是只有通過了 M-of-N 簽名和 timelock 等待的交易才能被執行。</p>
<p><strong>監督者（Auditor/Observer）</strong></p>
<p>監督者不參與交易的提出或執行，但擁有讀取所有交易記錄和審計日誌的權限。監督者負責事後審計，確保所有交易都遵循了既定流程。在某些治理模型中，監督者還擁有「否決權」，可以在 timelock 期間阻止可疑交易。</p>
<pre><code class="language-text">  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
  │ Proposer │───&gt;│ Reviewer │───&gt;│ Executor │    │ Auditor  │
  │ 提案發起 │    │ 模擬驗證 │    │ 上鏈執行 │    │ 事後審計 │
  └──────────┘    └──────────┘    └──────────┘    └──────────┘
       │               │               │               │
       │               │               │               │
       └───────────────┴───────────────┴───────────────┘
                        全部可追溯紀錄
                     (on-chain + off-chain)
</code></pre>
<p><strong>最佳實踐：</strong></p>
<ul>
<li>同一個人不應該同時擔任 Proposer 和 Reviewer</li>
<li>Executor 不應該有權限修改 timelock 參數</li>
<li>Auditor 的權限應該是唯讀的，不能發起或批准任何交易</li>
<li>所有角色的操作都應該有完整的 audit log</li>
</ul>
<h2 id="104-推薦控制項"><a class="header" href="#104-推薦控制項">10.4 推薦控制項</a></h2>
<p>每個控制項都是一道防線，它們組合起來形成多層防禦。以下逐一說明每個控制項的設計目的和實現方式。</p>
<p><strong>Timelock（例如 12h/24h/48h）</strong></p>
<p>Timelock 是最重要的安全控制項之一。它的作用是在交易被批准和實際執行之間插入一段強制等待期。這段等待期讓社群、安全團隊和自動化監控系統有時間審查即將執行的交易。如果發現問題，可以在 timelock 到期前取消交易。</p>
<pre><code class="language-solidity">// Timelock 合約的核心邏輯（簡化版）
mapping(bytes32 =&gt; uint256) public queuedTimestamp;

function queue(address target, bytes calldata data) external onlyMultisig {
    bytes32 txHash = keccak256(abi.encode(target, data, block.timestamp));
    queuedTimestamp[txHash] = block.timestamp;
    emit TransactionQueued(txHash, target, data);
}

function execute(address target, bytes calldata data, uint256 queueTime)
    external
{
    bytes32 txHash = keccak256(abi.encode(target, data, queueTime));
    require(queuedTimestamp[txHash] != 0, "Not queued");
    require(block.timestamp &gt;= queueTime + DELAY, "Timelock not expired");
    require(block.timestamp &lt;= queueTime + DELAY + GRACE_PERIOD, "Stale");

    delete queuedTimestamp[txHash];
    (bool ok, ) = target.call(data);
    require(ok, "Execution failed");
}
</code></pre>
<p><strong>Spend Limit（每日/每週上限）</strong></p>
<p>支出限額用於限制在特定時間窗口內可以轉出的資金總額。即使攻擊者取得了足夠的簽名權，他也無法在一次操作中抽乾所有資金。實務上，通常設定每日限額為金庫總額的 5-10%，超過此限額的交易需要走更高級別的審批流程。支出限額可以按幣種設定，也可以用 USD 等值計算。</p>
<p><strong>Function Allowlist（僅允許特定 selector）</strong></p>
<p>Function Allowlist 限制多簽合約只能呼叫預先批准的函式。例如，Ops Treasury 可能只被允許呼叫 <code>transfer()</code>、<code>approve()</code> 和 <code>setParameter()</code> 這三個函式，而 <code>upgradeTo()</code> 和 <code>setAdmin()</code> 等高風險函式只有 Root Treasury 才能呼叫。這是透過比對函式選擇器（function selector，即函式簽名的前 4 bytes keccak256 hash）來實現的。</p>
<p><strong>目的地址 Allowlist</strong></p>
<p>白名單制度限制資金只能轉往預先批准的地址。新增白名單地址本身也需要走多簽流程，並且有 timelock。這可以防止攻擊者即使取得簽名權也無法將資金轉往自己控制的地址。實務上建議使用 ENS 或內部標籤系統標記白名單地址的用途，避免「地址看起來都一樣」導致的混淆。</p>
<p><strong>緊急暫停（Pause Guardian）</strong></p>
<p>Pause Guardian 是一個特殊角色，擁有「暫停合約」的單一權限，但不擁有恢復（unpause）的權限。暫停權限通常只需要 1-of-N 即可觸發（因為是防禦性操作），而恢復則需要完整的多簽流程。這個設計讓團隊可以在發現攻擊時最快速度止血。暫停功能通常用 OpenZeppelin 的 <code>Pausable</code> 模組實現，在關鍵的資金操作函式上加上 <code>whenNotPaused</code> modifier。</p>
<pre><code class="language-text">┌──────────────────────────────────────────────────────┐
│              控制項防禦層級                            │
│                                                      │
│  交易發起 ──&gt; Function Allowlist ──&gt; 目的地 Allowlist │
│      │                                    │          │
│      v                                    v          │
│  Spend Limit 檢查 ──&gt; Timelock 等待 ──&gt; 執行         │
│      │                    │                          │
│      │                    v                          │
│      │           Pause Guardian 可隨時攔截           │
│      │                                               │
│      └── 超過限額 ──&gt; 拒絕/升級到更高層級            │
└──────────────────────────────────────────────────────┘
</code></pre>
<h2 id="105-多簽交易流程"><a class="header" href="#105-多簽交易流程">10.5 多簽交易流程</a></h2>
<p>完整的多簽交易流程不只是「收集簽名然後執行」，而是一個涵蓋提案、驗證、簽署、等待、執行、確認的完整生命週期。</p>
<pre><code class="language-text">Proposal Created
   │
   │  提案者構建 calldata 並提交描述
   v
Policy Check (limit, allowlist, risk score)
   │
   │  自動化系統檢查：
   │  ├── 金額是否超過 spend limit？
   │  ├── 目標函式是否在 allowlist？
   │  ├── 目標地址是否在 allowlist？
   │  └── 風險評分是否超標？
   v
Signatures Collected (M of N)
   │
   │  每位簽名人獨立驗證：
   │  ├── 使用 Tenderly/Foundry 模擬執行結果
   │  ├── 確認 calldata 與描述一致
   │  ├── 檢查 nonce 和 chainId
   │  └── 透過帶外通訊確認
   v
Timelock Queue
   │
   │  交易進入等待期（12h/24h/48h）
   │  ├── 監控系統持續監測
   │  ├── 社群可查看待執行交易
   │  └── Pause Guardian 可攔截
   v
Execute On-chain
   │
   │  Timelock 到期後提交上鏈
   │  ├── 再次驗證鏈上狀態
   │  └── gas 估算與提交
   v
Post-check + Accounting + Alert
   │
   ├── 確認交易成功（receipt status = 1）
   ├── 比對實際結果與預期模擬結果
   ├── 更新內部記帳系統
   ├── 觸發下游通知（Slack/Discord/Email）
   └── 記錄完整 audit trail
</code></pre>
<p><strong>交易模擬的重要性</strong></p>
<p>在簽署任何多簽交易之前，每位簽名人都應該獨立模擬交易的執行結果。使用 Tenderly 的 Simulation API 或 Foundry 的 <code>forge script --fork-url</code> 可以在不花費 gas 的情況下預覽交易的完整效果，包括 token 餘額變化、事件日誌、內部呼叫等。這可以有效防止「盲簽」——即不理解交易內容就簽署的危險行為。</p>
<pre><code class="language-bash"># 使用 Foundry 模擬多簽交易
cast call --rpc-url $RPC_URL \
  --from $SAFE_ADDRESS \
  $TARGET_CONTRACT \
  "transfer(address,uint256)" \
  $RECIPIENT $AMOUNT

# 使用 Tenderly 模擬
curl -X POST "https://api.tenderly.co/api/v1/simulate" \
  -H "X-Access-Key: $TENDERLY_KEY" \
  -d '{
    "network_id": "1",
    "from": "'$SAFE_ADDRESS'",
    "to": "'$TARGET_CONTRACT'",
    "input": "'$CALLDATA'"
  }'
</code></pre>
<p><strong>常見陷阱：</strong></p>
<ul>
<li>不要只看交易描述就簽署，一定要自己解碼並驗證 calldata</li>
<li>注意 nonce gap 問題：如果前面有一筆交易還沒執行，後面的交易都會卡住</li>
<li>EIP-712 結構化簽名可以讓簽名內容更易讀，優先使用</li>
<li>簽名有效期：設定簽名的過期時間，避免舊提案被惡意復活</li>
</ul>
<h2 id="106-治理模型"><a class="header" href="#106-治理模型">10.6 治理模型</a></h2>
<p>區塊鏈協議的治理模型決定了「誰有權做什麼改變」，不同的模型有不同的權衡。</p>
<p><strong>Multisig Governance（多簽治理）</strong></p>
<p>多簽治理是最簡單直接的模型。一組已知的個人或實體組成委員會，透過多簽控制協議的關鍵參數。優點是決策速度快、流程清晰，適合早期還在快速迭代的協議。缺點是中心化程度較高，社群參與感低，且存在委員會被攻擊者鎖定的風險。</p>
<p>代表案例：早期的 Compound、Aave 都是由多簽委員會管理合約升級和參數調整，隨著協議成熟後逐步過渡到 token 治理。</p>
<p><strong>Token Governance（代幣治理）</strong></p>
<p>Token 治理讓持幣人透過投票決定協議的未來方向。常見的實現是 Governor 合約（如 OpenZeppelin 的 Governor 或 Compound 的 GovernorBravo）。持幣人可以提案、投票、在 timelock 後執行通過的提案。</p>
<p>優點是去中心化程度高、社群參與感強。缺點包括：投票率通常很低（5-15%），容易被鯨魚操控，委託投票（delegation）可能產生新的中心化問題，治理攻擊（flash loan 借入大量 token 進行投票）也是實際存在的風險。</p>
<pre><code class="language-text">Token Governance 流程：

  提案 ──&gt; 投票期（3-7天）──&gt; 計票 ──&gt; Timelock（2天）──&gt; 執行
    │           │                │
    │       quorum 門檻         │
    │      (通常 4-10%)         │
    │                           │
    └── 提案需持有 ≥1%          └── 若未達 quorum ──&gt; 提案失敗
        總量的 token
</code></pre>
<p><strong>Hybrid Governance（混合治理）</strong></p>
<p>混合治理結合了前兩者的優點。日常營運參數（如利率調整、新增市場）由多簽委員會快速決定；重大事項（如合約升級、金庫使用、協議方向調整）需要經過代幣持有人投票。所有操作都加上 timelock。</p>
<p>這是目前大多數成熟 DeFi 協議採用的模型。例如 Uniswap 的治理委員會（Governance Committee）負責日常事務，但關鍵的協議改動必須通過 UNI token 投票。</p>
<p><strong>治理模型比較：</strong></p>
<div class="table-wrapper"><table><thead><tr><th>維度</th><th>Multisig</th><th>Token</th><th>Hybrid</th></tr></thead><tbody>
<tr><td>決策速度</td><td>快（小時級）</td><td>慢（週級）</td><td>中等</td></tr>
<tr><td>去中心化</td><td>低</td><td>高</td><td>中高</td></tr>
<tr><td>攻擊成本</td><td>攻陷 M 個簽名人</td><td>獲取大量 token</td><td>兩者兼備</td></tr>
<tr><td>適合階段</td><td>早期</td><td>成熟期</td><td>過渡期/成熟期</td></tr>
<tr><td>社群參與</td><td>低</td><td>高</td><td>中高</td></tr>
</tbody></table>
</div>
<h2 id="107-事故回應設計"><a class="header" href="#107-事故回應設計">10.7 事故回應設計</a></h2>
<p>即使有完善的預防措施，事故仍然可能發生。事故回應設計的目的是讓團隊在壓力下能快速、正確地行動，而不是在慌亂中犯更多錯誤。</p>
<p><strong>Break-glass Multisig（緊急組）</strong></p>
<p>Break-glass Multisig 是一個專門為緊急情況設計的多簽，其簽名門檻比日常多簽更低（例如 2-of-5 而非 3-of-5），但只能執行防禦性操作：暫停合約、啟動提款限制、切換到安全模式等。這個設計的原則是「在緊急情況下，速度比完整流程更重要」。</p>
<p>實務建議：Break-glass Multisig 的簽名人應該分布在不同時區，確保任何時間都至少有 M 位簽名人在線。每位簽名人的手機上應該安裝好簽署工具，並且定期演練整個流程。</p>
<p><strong>Pause 不等於升級，避免濫權</strong></p>
<p>暫停功能（Pause）應該只用於防禦性的緊急情況，不應該被濫用為「隨時停服維護」的工具。暫停是暫時性的，目的是止血；合約升級是永久性的，目的是修復。兩者的審批流程應該完全不同。暫停可以快速觸發，但升級必須走完整的治理流程（提案、審計、timelock、投票等）。</p>
<p>如果團隊頻繁使用暫停功能，這本身就是一個紅旗，說明系統存在更深層的問題需要根本性地解決。</p>
<p><strong>事故後必須公開 postmortem 與權限調整</strong></p>
<p>每次安全事故後，團隊都應該公開透明的事故報告（postmortem），內容至少包括：事故時間線、根本原因分析、影響範圍（受影響的資金和用戶數量）、採取的補救措施、以及防止再發的改進計畫。這不僅是對社群的責任，也是對自己團隊的重要學習機會。</p>
<pre><code class="language-text">事故回應時間線（理想情況）：

  T+0min    偵測到異常（自動化告警）
  T+5min    On-call 工程師確認事故
  T+10min   觸發 Pause Guardian（止血）
  T+15min   通知核心團隊和安全合作夥伴
  T+30min   初步影響評估
  T+1hr     對外發布初步聲明
  T+4hr     根本原因初步判定
  T+24hr    詳細事故報告草案
  T+72hr    公開 postmortem + 補償方案
  T+2wk     修復部署 + 第三方審計完成
</code></pre>
<h2 id="108-多簽常見失敗模式"><a class="header" href="#108-多簽常見失敗模式">10.8 多簽常見失敗模式</a></h2>
<p>理解失敗模式可以幫助團隊在設計階段就避免這些問題。以下是實際發生過的常見失敗：</p>
<p><strong>簽名人實際由同一組織控制（名義分散）</strong></p>
<p>這是最常見也最危險的失敗模式。表面上看有 5 位不同的簽名人，但實際上都是同一家公司的員工，私鑰由同一個 IT 部門管理，存放在同一組伺服器上。攻擊者只需要入侵一個組織就能取得所有簽名權。Ronin Bridge 事件就是這個問題的典型案例。</p>
<p><strong>硬體設備集中保管</strong></p>
<p>把所有硬體錢包放在同一個保險箱或同一間辦公室是另一個常見錯誤。火災、竊盜、政府扣押都可能同時影響所有設備。正確做法是將硬體設備分散保管，至少分布在三個不同的物理位置，並且設備之間保持地理隔離。</p>
<p><strong>簽名流程不看 calldata（盲簽）</strong></p>
<p>盲簽是指簽名人不理解或不驗證交易的具體內容就直接簽署。這在趕時間或簽名人技術能力不足的情況下特別容易發生。攻擊者可能提交一筆看起來正常但 calldata 被篡改的交易，例如把轉帳地址改成攻擊者的地址。</p>
<p>防範措施包括：使用支持 EIP-712 結構化簽名的介面讓交易內容可讀；強制每位簽名人在簽署前提交獨立的模擬結果；定期培訓簽名人如何解碼和驗證 calldata。</p>
<p><strong>無備援 signer，關鍵人離線導致停擺</strong></p>
<p>如果 5-of-7 多簽中有 3 個人在度假時失聯，那剩下 4 人中如果再有一人不在線就無法執行任何交易。實務上應該：(1) 確保每個時區至少有足夠的簽名人；(2) 定期更新簽名人的聯繫方式和可用時間；(3) 設計備援機制，例如在連續 30 天無法達到法定簽名數時，自動降低門檻（需謹慎使用）。</p>
<h2 id="109-企業實務模板"><a class="header" href="#109-企業實務模板">10.9 企業實務模板</a></h2>
<p>以下是經過實戰驗證的企業級多簽管理模板，適合管理超過 100 萬美元資產的團隊。</p>
<p><strong>交易分級：</strong></p>
<div class="table-wrapper"><table><thead><tr><th>等級</th><th>定義</th><th>多簽配置</th><th>Timelock</th><th>範例</th></tr></thead><tbody>
<tr><td>P0（緊急止血）</td><td>合約被攻擊或資金正在被盜</td><td>2/5 Break-glass</td><td>無</td><td>Pause 合約、凍結地址</td></tr>
<tr><td>P1（大額交易）</td><td>單筆 &gt; $100K 或影響核心參數</td><td>4/7 Root Treasury</td><td>48h</td><td>合約升級、大額撥款</td></tr>
<tr><td>P2（日常營運）</td><td>常規操作</td><td>2/3 Ops Treasury</td><td>12h</td><td>參數微調、小額轉帳</td></tr>
</tbody></table>
</div>
<ul>
<li>P0（緊急止血）: 快速路徑 + 事後審計。P0 的特點是「先行動再解釋」，但行動僅限於防禦性操作。事後必須在 24 小時內完成審計報告，說明為什麼需要使用緊急路徑。</li>
<li>P1（大額）: 4/7 + 48h timelock。P1 交易必須附帶完整的提案文件，包括目的說明、風險評估、模擬結果、和回滾方案。</li>
<li>P2（日常）: 2/3 + 12h timelock。P2 是日常營運的主力，但仍然需要基本的交易模擬和雙人覆核。</li>
</ul>
<p><strong>定期輪替：</strong></p>
<ul>
<li>每季輪替 signer 裝置：即使沒有安全事故，也應該定期更換硬體錢包並重新生成密鑰。舊設備應該安全銷毀（物理破壞存儲晶片）。輪替時機也是審查和更新簽名人名單的好機會。</li>
<li>每半年演練私鑰失陷與簽名人失聯：進行桌面推演（tabletop exercise），模擬一位簽名人的私鑰被盜或一位簽名人突然失聯的場景，驗證團隊是否能在規定時間內完成應急響應。演練結果應該記錄並用於改進流程。</li>
</ul>
<pre><code class="language-text">年度輪替與演練計畫：

  Q1: 裝置輪替 + 新簽名人 onboarding
  Q2: 桌面推演 - 私鑰失陷場景
  Q3: 裝置輪替 + 多簽升級評估
  Q4: 桌面推演 - 大規模攻擊場景 + 年度回顧
</code></pre>
<p><strong>onboarding 新簽名人的檢查清單：</strong></p>
<ol>
<li>使用全新的硬體錢包，從原廠密封包裝開始設定</li>
<li>在離線環境中生成私鑰和助記詞</li>
<li>助記詞使用金屬板備份，分散存放在至少兩個地理位置</li>
<li>在測試網執行至少 3 筆模擬簽署，確認流程熟悉</li>
<li>加入多簽的通訊群組和告警頻道</li>
<li>閱讀並簽署簽名人操作手冊（SOP）</li>
</ol>
<h2 id="白話總結-9"><a class="header" href="#白話總結-9">白話總結</a></h2>
<p>多簽不是「多幾個人按同意」而已，而是把公司內控流程變成可驗證、可追溯的上鏈簽核系統。想像一下銀行的保險庫：你不會把所有鑰匙交給同一個人，也不會把所有現金放在櫃台，更不會讓同一個人既提出提款申請又批准申請。區塊鏈上的多簽金庫就是把這些銀行的最佳實踐變成了智能合約的程式碼，不可繞過、不可篡改。</p>
<p>金庫分層就像是銀行的保險庫（L0）、營運帳戶（L1）、和收銀台（L2）三層結構。大部分的錢鎖在保險庫裡，只有需要的時候才提出來放到營運帳戶，收銀台只放當天需要的零用金。即使收銀台被搶劫，損失也是有限的。</p>
<p>權限分離確保了沒有任何單一個人可以從頭到尾控制整個流程。提案的人不能批准，批准的人不能執行，執行的人受到 timelock 和額度限制的約束。而監督者會在事後檢查所有操作是否合規。</p>
<p>治理模型的選擇取決於協議的成熟度和社群的參與度。早期快速迭代時用多簽治理比較實際，成熟後可以過渡到代幣治理讓社群參與決策。但不管用什麼模型，timelock 和透明度都是不可或缺的。</p>
<p>最後，多簽最怕的不是技術漏洞，而是流程上的偷懶：名義上分散但實際上集中、簽名時不看交易內容、硬體設備放在同一個地方、不做定期演練。歷史上最大的幾次安全事故，根本原因往往不是技術缺陷，而是治理和營運層面的疏忽。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-攻擊面事故型態與防禦"><a class="header" href="#11-攻擊面事故型態與防禦">11. 攻擊面、事故型態與防禦</a></h1>
<h2 id="111-攻擊面總覽"><a class="header" href="#111-攻擊面總覽">11.1 攻擊面總覽</a></h2>
<p>區塊鏈系統的攻擊面遠比大多數人想像的更廣。攻擊者不一定要找到合約漏洞——他們可能攻擊前端、竊取私鑰、操控預言機、或者利用供應鏈注入惡意程式碼。理解完整的攻擊面是建立有效防禦的第一步。</p>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────────┐
│                    攻擊面全景圖                              │
│                                                             │
│  ┌─────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐ │
│  │  用戶端  │   │  前端/    │   │ 後端/     │   │  鏈上    │ │
│  │         │──&gt;│  供應鏈   │──&gt;│ 基礎設施  │──&gt;│  合約    │ │
│  └─────────┘   └──────────┘   └──────────┘   └──────────┘ │
│   釣魚攻擊      NPM 投毒      RPC 劫持       重入攻擊      │
│   社交工程      DNS 劫持       節點中心化     閃電貸操控    │
│   假錢包        CDN 竄改       MEV 攻擊       治理攻擊      │
│                                                             │
│  ┌─────────┐   ┌──────────┐   ┌──────────┐                │
│  │  私鑰/   │   │  預言機/  │   │  跨鏈橋  │                │
│  │  簽名端  │   │  外部資料 │   │         │                │
│  └─────────┘   └──────────┘   └──────────┘                │
│   助記詞洩漏     價格操控       validator     │
│   硬體漏洞       延遲攻擊       compromise    │
│   MPC 碎片       假數據源       中繼器攻擊     │
└─────────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>私鑰與簽名端</strong></p>
<p>私鑰是區塊鏈系統中最核心的安全資產。一旦私鑰洩漏，攻擊者可以完全控制對應的帳戶和所有資產。私鑰洩漏的途徑包括：助記詞被截圖或備份到雲端、開發者在測試環境中使用生產私鑰、惡意軟體記錄鍵盤輸入、硬體錢包韌體漏洞等。2024 年的多起大型安全事故都與私鑰管理不善有關。</p>
<p>MPC（Multi-Party Computation）技術將私鑰分割成多個碎片，分散存放在不同的節點上，簽署時各碎片協作計算但私鑰從不完整出現。這比傳統的多簽提供了更好的隱私性（外部無法區分 MPC 簽名和普通簽名），但引入了新的攻擊面：碎片的安全性、MPC 協議實現的正確性、以及碎片輪替過程中的風險。</p>
<p><strong>合約程式邏輯</strong></p>
<p>智能合約的漏洞是最被廣泛研究的攻擊面。常見的漏洞類型包括：重入攻擊（Reentrancy）、整數溢位/下溢（在 Solidity 0.8+ 之前）、存取控制缺陷、價格操控、閃電貸攻擊、以及邏輯錯誤。值得注意的是，許多漏洞不是單一函式的 bug，而是多個合約互動時產生的意外行為——這種組合漏洞特別難被靜態分析工具發現。</p>
<p><strong>預言機與外部資料</strong></p>
<p>預言機（Oracle）是鏈下數據進入鏈上的橋樑，也是 DeFi 系統中最脆弱的環節之一。如果預言機回報了錯誤的價格，任何依賴該價格的合約都可能被利用。攻擊方式包括：直接操控底層 DEX 的流動性池（影響 TWAP 計算）、在低流動性時段放大價格偏差、利用預言機更新的延遲窗口進行套利。</p>
<p><strong>前端供應鏈</strong></p>
<p>前端攻擊是最容易被忽視但影響面最大的攻擊途徑。攻擊者不需要找到合約漏洞，只需要篡改用戶看到的介面，就能讓用戶簽署惡意交易。2022 年 BadgerDAO 事件中，攻擊者透過 Cloudflare API key 注入了惡意的前端腳本，讓用戶在不知情的情況下批准了對攻擊者地址的無限授權（unlimited approval）。損失超過 1.2 億美元。</p>
<p>常見的前端攻擊途徑包括：NPM 套件被注入惡意程式碼、DNS 劫持將用戶導向假網站、CDN 被入侵後替換了 JavaScript 檔案、開發者的 API key 洩漏。</p>
<p><strong>RPC/節點基礎設施</strong></p>
<p>如果應用程式依賴的 RPC 節點被攻擊者控制或篡改，攻擊者可以：回傳錯誤的鏈上狀態、延遲或隱藏交易、進行 eclipse attack（讓節點只看到攻擊者製造的假鏈）。使用單一 RPC 提供者（如只依賴 Infura 或 Alchemy 中的一個）也存在可用性風險——如果該服務中斷，整個應用就會停擺。</p>
<p><strong>跨鏈橋與治理權限</strong></p>
<p>跨鏈橋是區塊鏈生態中被攻擊最頻繁、損失最大的領域。從 2021 年到 2024 年，跨鏈橋攻擊累計損失超過 25 億美元。攻擊方式包括：validator/relayer 的私鑰被盜（Ronin Bridge）、驗證邏輯漏洞（Wormhole）、橋合約的存取控制缺陷（Nomad）。跨鏈橋的根本難題是：它需要在兩條不同的鏈之間建立信任，而這種信任往往依賴於少數 validator 的誠實性。</p>
<h2 id="112-典型事故分類"><a class="header" href="#112-典型事故分類">11.2 典型事故分類</a></h2>
<p>理解歷史事故的分類有助於團隊建立針對性的防禦策略。以下是五大類事故及其代表性案例。</p>
<p><strong>Key Compromise（私鑰失陷）</strong></p>
<p>私鑰失陷是損失金額最大的攻擊類型之一。攻擊者一旦取得管理員或多簽成員的私鑰，就可以直接控制合約或轉移資金。</p>
<div class="table-wrapper"><table><thead><tr><th>事件</th><th>年份</th><th>損失</th><th>根本原因</th></tr></thead><tbody>
<tr><td>Ronin Bridge</td><td>2022</td><td>~$625M</td><td>validator 私鑰被盜</td></tr>
<tr><td>Harmony Horizon</td><td>2022</td><td>~$100M</td><td>2-of-5 多簽被攻陷</td></tr>
<tr><td>Atomic Wallet</td><td>2023</td><td>~$100M</td><td>加密私鑰的密鑰管理漏洞</td></tr>
</tbody></table>
</div>
<p>防禦重點：使用硬體錢包、MPC、或多簽；私鑰離線生成和保管；定期輪替；最小權限原則。</p>
<p><strong>Contract Exploit（合約漏洞利用）</strong></p>
<p>合約漏洞是最「技術性」的攻擊類型。攻擊者發現合約邏輯中的缺陷，構造特定的交易序列來觸發意外行為。</p>
<pre><code class="language-text">常見合約漏洞及其攻擊模式：

  Reentrancy（重入攻擊）：
    攻擊合約 ──call──&gt; 受害合約（轉帳）──callback──&gt; 攻擊合約（再次call）
    根因：先轉帳再更新狀態
    防禦：Checks-Effects-Interactions 模式 + ReentrancyGuard

  Flash Loan Attack（閃電貸攻擊）：
    同一筆交易中：借入大量資金 ──&gt; 操控價格/投票 ──&gt; 獲利 ──&gt; 還款
    根因：依賴即時的現貨價格
    防禦：TWAP 預言機 + 延遲機制

  Access Control（存取控制缺陷）：
    任何人都可以呼叫 admin-only 函式
    根因：遺漏 onlyOwner/onlyAdmin modifier
    防禦：完整的角色定義 + 測試覆蓋
</code></pre>
<p><strong>Oracle Manipulation（預言機操控）</strong></p>
<p>預言機操控通常與閃電貸結合。攻擊者借入大量資金操控 DEX 流動性池的價格，讓預言機回報被扭曲的價格，然後利用這個假價格在受害協議中獲利。</p>
<p>典型攻擊流程：</p>
<ol>
<li>閃電貸借入大量 ETH</li>
<li>在 Uniswap 池中大量拋售 ETH，壓低 ETH/USDC 價格</li>
<li>在使用該池作為預言機的借貸協議中，以壓低後的價格抵押 ETH 借出大量 USDC</li>
<li>在 Uniswap 池中買回 ETH（價格恢復）</li>
<li>歸還閃電貸，淨賺差價</li>
</ol>
<p>防禦措施：使用 Chainlink 等去中心化預言機而非單一 DEX 價格；使用 TWAP（時間加權平均價格）而非即時價格；設定價格偏差閾值，超過一定範圍的價格變動需要額外確認。</p>
<p><strong>Governance Attack（治理攻擊）</strong></p>
<p>治理攻擊是指攻擊者透過合法的治理流程，通過惡意提案來控制協議。2022 年 Beanstalk 事件中，攻擊者使用閃電貸借入大量治理 token，在同一個區塊中提案並投票通過了一個惡意提案，將協議金庫中的資金轉出。</p>
<p>防禦措施：提案和投票之間設定時間間隔（防止閃電貸攻擊）；投票需要持有 token 超過一定時間（snapshot 機制）；設定 quorum 門檻和提案門檻；重大改動需要更長的 timelock。</p>
<p><strong>Bridge Validator Compromise（橋驗證器失陷）</strong></p>
<p>跨鏈橋 validator 的失陷是最嚴重的攻擊類型，因為橋通常管理著大量的鎖定資產。攻擊者只需要控制足夠數量的 validator（通常是 M-of-N 中的 M 個），就可以偽造跨鏈消息，在目標鏈上憑空鑄造資產或解鎖橋中的鎖定資產。</p>
<pre><code class="language-text">橋驗證器攻擊模型：

  源鏈                  驗證器集合              目標鏈
  ┌────┐               ┌────────┐             ┌────┐
  │用戶│──鎖定資產──&gt;   │V1 (OK) │             │    │
  │    │               │V2 (OK) │──偽造證明──&gt;│鑄造│
  │    │               │V3 (被控)│             │假幣│
  │    │               │V4 (被控)│             │    │
  │    │               │V5 (被控)│             │    │
  └────┘               └────────┘             └────┘
                        3-of-5 被攻陷
                        = 完全控制橋接資產
</code></pre>
<h2 id="113-防禦分層"><a class="header" href="#113-防禦分層">11.3 防禦分層</a></h2>
<p>有效的安全防禦不是單一措施，而是多層防線的組合。即使某一層被突破，後面的層級仍然可以減輕損失。這個概念借鑒自傳統安全領域的「深度防禦」（Defense in Depth）。</p>
<pre><code class="language-text">Layer 1: Prevent   -&gt; 最小權限、審計、MPC/Multisig
Layer 2: Detect    -&gt; 監控、異常告警、MEV/價格偏差監測
Layer 3: Respond   -&gt; Pause、限額、黑白名單、應急流程
Layer 4: Recover   -&gt; 財務對帳、法務流程、用戶補償策略
</code></pre>
<p><strong>Layer 1: Prevent（預防）</strong></p>
<p>預防層的目標是從根本上減少漏洞的數量和攻擊的可能性。</p>
<p>最小權限原則（Principle of Least Privilege）是預防層的基石。每個合約、每個角色、每個 API 端點都應該只擁有完成其功能所需的最少權限。管理員帳戶不應該有直接轉移用戶資金的權限；預言機更新合約不應該有暫停合約的權限。權限應該細粒度劃分，避免「超級管理員」的存在。</p>
<p>代碼審計是預防層的另一個關鍵環節。一次完整的審計應該包括：至少兩家獨立審計公司的審計、社群公開的審計競賽（audit contest，如 Code4rena、Sherlock）、以及內部持續性的安全審查。審計不是一次性的活動——每次合約升級、參數調整、或新功能上線都需要重新評估安全性。</p>
<pre><code class="language-solidity">// 最小權限的合約設計範例
contract Treasury {
    // 角色定義：每個角色只有特定權限
    bytes32 public constant PROPOSER_ROLE = keccak256("PROPOSER");
    bytes32 public constant EXECUTOR_ROLE = keccak256("EXECUTOR");
    bytes32 public constant GUARDIAN_ROLE = keccak256("GUARDIAN");

    // Guardian 只能暫停，不能轉帳
    function pause() external onlyRole(GUARDIAN_ROLE) {
        _pause();
    }

    // 只有 Executor 可以執行已批准的交易
    function execute(bytes32 txId)
        external
        onlyRole(EXECUTOR_ROLE)
        whenNotPaused
    {
        require(isApproved(txId), "Not approved");
        require(timelockExpired(txId), "Timelock active");
        _execute(txId);
    }
}
</code></pre>
<p><strong>Layer 2: Detect（偵測）</strong></p>
<p>偵測層的目標是在攻擊發生的早期階段就發出警報，縮短從攻擊開始到被發現之間的時間窗口。</p>
<p>即時監控應該覆蓋以下維度：</p>
<ul>
<li><strong>資金異動監控</strong>：監測合約餘額的大幅變化、異常的轉帳模式、大額授權（approve）</li>
<li><strong>價格偏差監控</strong>：監測預言機回報的價格與市場公允價格的偏差，超過閾值立即告警</li>
<li><strong>MEV 監控</strong>：追蹤 mempool 中的交易，偵測可能的搶跑（frontrunning）或三明治攻擊（sandwich attack）</li>
<li><strong>治理活動監控</strong>：監測異常的提案、大量 token 轉移到投票合約、以及快速投票等可疑行為</li>
</ul>
<p>推薦工具包括 Forta Network（分散式威脅偵測）、OpenZeppelin Defender（自動化安全監控）、以及自建的 event listener。</p>
<pre><code class="language-text">偵測系統架構：

  鏈上事件                     偵測引擎                    告警通道
  ┌──────────┐               ┌──────────┐              ┌──────────┐
  │ Transfer │──&gt;            │ 規則引擎  │──P0 告警──&gt;  │ PagerDuty│
  │ Approval │──&gt;  Event     │ (金額門檻 │              │ 電話叫醒 │
  │ Swap     │──&gt;  Stream ──&gt;│  頻率異常 │              └──────────┘
  │ Governance│──&gt;           │  模式匹配)│──P1 告警──&gt;  ┌──────────┐
  │ Admin    │──&gt;            └──────────┘              │ Slack    │
  └──────────┘                    │                    │ Telegram │
                                  │                    └──────────┘
                            ┌─────▼────┐
                            │ Dashboard│
                            │ Grafana  │
                            └──────────┘
</code></pre>
<p><strong>Layer 3: Respond（回應）</strong></p>
<p>當偵測層發出告警後，回應層的目標是在最短時間內阻止損失擴大。</p>
<p>Pause（暫停）是最快速的止血手段。暫停後，合約的核心功能（存款、提款、交換等）被凍結，攻擊者無法繼續抽取資金。但暫停也會影響正常用戶，因此只應在確認攻擊正在進行時使用。</p>
<p>限額機制（Rate Limiting）是一種更精細的回應方式。與完全暫停不同，限額機制允許小額交易繼續進行，但阻止大額提款。例如，設定每小時最多允許提取合約餘額的 10%。這在攻擊的早期階段特別有效，因為攻擊者通常試圖在最短時間內抽走最多資金。</p>
<p>黑名單（Blocklist）可以阻止特定地址與合約互動。在發現攻擊者地址後，可以立即將其加入黑名單。但黑名單的效力有限，因為攻擊者可以輕鬆創建新地址。</p>
<p><strong>Layer 4: Recover（恢復）</strong></p>
<p>恢復層處理事故後的善後工作，包括：精確的財務對帳（確定損失金額和受影響的用戶）、與法務團隊合作追蹤資金流向、制定用戶補償方案（直接補償、發行 IOU token、或分期償還等）、以及出具公開的事故報告。</p>
<p>值得注意的是，鏈上資金追蹤已經變得越來越成熟。Chainalysis、Elliptic、TRM Labs 等鏈上分析公司可以追蹤被盜資金通過混幣器（如 Tornado Cash）、跨鏈橋、以及中心化交易所的流向。一些重大攻擊事件中，攻擊者最終被追蹤到並被起訴或通過談判歸還了部分資金。</p>
<h2 id="114-合約安全測試矩陣"><a class="header" href="#114-合約安全測試矩陣">11.4 合約安全測試矩陣</a></h2>
<p>完整的合約安全測試應該涵蓋多種測試方法，每種方法發現不同類型的問題。沒有任何一種測試方法可以覆蓋所有潛在漏洞，因此必須組合使用。</p>
<p><strong>Unit Test（單元測試）</strong></p>
<p>單元測試驗證合約中每個函式在正常輸入和邊界條件下的行為。好的單元測試不只測試「正確的輸入產生正確的輸出」，更要測試「錯誤的輸入產生正確的錯誤」。例如，非管理員呼叫管理員函式應該 revert；餘額不足的轉帳應該 revert 並返回明確的錯誤訊息。</p>
<pre><code class="language-solidity">// Foundry 單元測試範例
function test_TransferRevertsOnInsufficientBalance() public {
    vm.prank(alice);
    vm.expectRevert("Insufficient balance");
    token.transfer(bob, 1000 ether);
}

function test_OnlyAdminCanPause() public {
    vm.prank(attacker);
    vm.expectRevert("AccessControl: not admin");
    vault.pause();
}
</code></pre>
<p><strong>Invariant Test（不變量測試）</strong></p>
<p>不變量測試（也稱為 property-based testing）定義合約應該永遠保持的性質，然後讓測試框架隨機產生大量的交易序列來嘗試違反這些不變量。這比手動編寫測試案例能發現更多的邊界情況。</p>
<p>常見的不變量包括：</p>
<ul>
<li>所有用戶餘額之和等於合約中的 token 總量</li>
<li>借貸協議的抵押率永遠大於最低要求</li>
<li>管理員地址永遠不是零地址</li>
<li>合約暫停狀態下不能執行資金操作</li>
</ul>
<pre><code class="language-solidity">// Foundry 不變量測試範例
function invariant_TotalSupplyMatchesBalances() public {
    uint256 totalFromBalances;
    for (uint256 i = 0; i &lt; actors.length; i++) {
        totalFromBalances += token.balanceOf(actors[i]);
    }
    assertEq(token.totalSupply(), totalFromBalances);
}

function invariant_VaultAlwaysSolvent() public {
    assertGe(
        underlying.balanceOf(address(vault)),
        vault.totalDeposits()
    );
}
</code></pre>
<p><strong>Fuzz Test（模糊測試）</strong></p>
<p>模糊測試自動產生隨機的輸入值，嘗試觸發意外行為。與不變量測試不同，模糊測試關注的是單個函式的行為，而非系統級的性質。Foundry 和 Echidna 都支持模糊測試。重點是確保模糊測試涵蓋足夠的輸入空間，包括極端值（0、最大值、邊界值）和特殊值。</p>
<pre><code class="language-solidity">// Foundry fuzz 測試
function testFuzz_DepositAndWithdraw(uint256 amount) public {
    // 限制輸入範圍，避免無意義的測試
    amount = bound(amount, 1, type(uint128).max);

    deal(address(token), alice, amount);
    vm.startPrank(alice);
    token.approve(address(vault), amount);
    vault.deposit(amount);

    assertEq(vault.balanceOf(alice), amount);

    vault.withdraw(amount);
    assertEq(token.balanceOf(alice), amount);
    vm.stopPrank();
}
</code></pre>
<p><strong>Symbolic Execution（符號執行）</strong></p>
<p>符號執行使用數學方法探索合約的所有可能執行路徑。與模糊測試的隨機探索不同，符號執行是系統性的，可以證明某些性質在所有可能的輸入下都成立（或找到反例）。工具包括 Halmos、HEVM、以及 Manticore。</p>
<p>符號執行的缺點是計算成本高，對於複雜的合約可能需要很長時間才能完成分析。實務上，通常只對最關鍵的安全函式使用符號執行。</p>
<p><strong>Mainnet Fork Simulation（主網分叉模擬）</strong></p>
<p>主網分叉模擬使用真實的主網狀態（餘額、合約、流動性）來測試交易的效果。這是最貼近真實環境的測試方式，可以發現只在真實狀態下才會出現的問題。</p>
<pre><code class="language-bash"># Foundry 主網分叉測試
forge test --fork-url $ETH_MAINNET_RPC \
  --fork-block-number 19000000 \
  -vvv

# 在分叉環境中模擬攻擊場景
forge script script/SimulateAttack.s.sol \
  --fork-url $ETH_MAINNET_RPC \
  --sender $ATTACKER_ADDRESS
</code></pre>
<p><strong>測試矩陣總覽：</strong></p>
<pre><code class="language-text">┌──────────────────┬──────────────┬──────────────┬───────────────┐
│ 測試類型          │ 發現的問題    │ 成本         │ 覆蓋度         │
├──────────────────┼──────────────┼──────────────┼───────────────┤
│ Unit Test        │ 功能錯誤      │ 低           │ 手動指定       │
│ Invariant Test   │ 系統級違規    │ 中           │ 自動探索       │
│ Fuzz Test        │ 邊界/溢位     │ 中           │ 隨機探索       │
│ Symbolic Exec    │ 邏輯漏洞      │ 高           │ 完整探索       │
│ Mainnet Fork     │ 整合/狀態問題 │ 中           │ 真實環境       │
└──────────────────┴──────────────┴──────────────┴───────────────┘
</code></pre>
<h2 id="115-營運安全"><a class="header" href="#115-營運安全">11.5 營運安全</a></h2>
<p>合約部署上線後，營運安全（Operational Security, OpSec）變成了持續性的挑戰。再好的合約代碼，如果營運流程有漏洞，一樣可能被攻擊。</p>
<p><strong>簽名設備不連網通用主機</strong></p>
<p>所有用於簽署高價值交易的設備（硬體錢包、air-gapped 電腦）都不應該與日常工作設備混用。理想的設定是一台專用的、從未安裝過任何非必要軟體的電腦，僅透過 USB 連接硬體錢包進行簽署。這台設備不連接 Wi-Fi，不插入任何外部儲存設備，不安裝瀏覽器。交易的 calldata 透過 QR code 或手動輸入的方式傳入。</p>
<p>這聽起來很不方便，但在管理數百萬美元資產的場景中，不便是可以接受的成本。每次使用完畢後，設備應該關機並安全保管。</p>
<p><strong>交易前模擬與結果比對</strong></p>
<p>在簽署任何交易之前，必須先在模擬環境中執行，並比對模擬結果與預期是否一致。模擬應該涵蓋：</p>
<ul>
<li>資金流向（哪些地址的餘額會增加/減少多少）</li>
<li>事件日誌（會觸發哪些 event）</li>
<li>狀態變更（哪些 storage slot 會被修改）</li>
<li>gas 消耗（異常的 gas 消耗可能暗示非預期的邏輯執行）</li>
</ul>
<pre><code class="language-bash"># 交易模擬檢查清單
# 1. 解碼 calldata
cast 4byte-decode $CALLDATA

# 2. 模擬執行
cast call --from $SENDER --to $TARGET --data $CALLDATA --rpc-url $RPC

# 3. 追蹤內部呼叫
cast run $TX_HASH --trace --rpc-url $RPC

# 4. 比對前後狀態
cast storage $CONTRACT $SLOT --rpc-url $RPC  # 執行前
# ... 執行交易 ...
cast storage $CONTRACT $SLOT --rpc-url $RPC  # 執行後
</code></pre>
<p><strong>變更窗口與雙人覆核</strong></p>
<p>所有高風險的鏈上操作（合約升級、參數調整、大額轉帳）都應該在預先排定的變更窗口內執行，並且需要至少兩位工程師在場進行交叉覆核。變更窗口的時間應該選擇團隊最清醒、最不容易犯錯的時段（避免半夜、週末、假期前夕）。</p>
<p>雙人覆核的具體做法：一位工程師準備交易並解釋內容，另一位工程師獨立驗證 calldata、模擬結果、和目標地址。兩人都確認無誤後才進行簽署。</p>
<p><strong>所有高風險操作強制審批單號</strong></p>
<p>每筆高風險操作都應該與一張 ticket（如 JIRA、Linear、GitHub Issue）關聯。ticket 中記錄：操作的目的、審批人、模擬結果、簽署人、執行時間、以及事後驗證結果。這個 audit trail 在事故調查和合規審計時至關重要。</p>
<p><strong>額外的營運安全最佳實踐：</strong></p>
<ul>
<li><strong>定期 secret rotation</strong>：定期輪替所有 API key、RPC 端點密碼、和服務帳戶憑證</li>
<li><strong>最小暴露原則</strong>：不在公開 repo 中暴露合約部署腳本、測試私鑰、或內部基礎設施資訊</li>
<li><strong>通訊安全</strong>：討論安全相關事項使用端對端加密的通訊工具（如 Signal），不在公開的 Discord/Telegram 群組中討論私鑰、金額、或交易細節</li>
<li><strong>員工安全意識培訓</strong>：定期進行釣魚模擬演練，確保團隊成員能識別和回報可疑訊息</li>
<li><strong>離職流程</strong>：員工離職時，必須在 24 小時內從所有多簽和權限群組中移除，並觸發密鑰輪替</li>
</ul>
<h2 id="116-案例分析攻擊時間線"><a class="header" href="#116-案例分析攻擊時間線">11.6 案例分析：攻擊時間線</a></h2>
<p>以下是一個典型的合約攻擊事件的時間線分析，展示了從偵測到回應的完整過程。</p>
<pre><code class="language-text">典型攻擊事件時間線：

  T-30 天    攻擊者開始研究目標協議的合約程式碼
  T-7 天     攻擊者在 testnet 上測試攻擊向量
  T-1 天     攻擊者準備閃電貸和攻擊合約
  T-1 小時   攻擊者部署攻擊合約到 mainnet
  T+0        攻擊交易上鏈（整個攻擊在一個區塊內完成）
  T+2 分鐘   自動化監控偵測到大額異常轉帳
  T+5 分鐘   安全工程師收到 P0 告警
  T+10 分鐘  確認攻擊正在進行
  T+12 分鐘  觸發 Pause Guardian 暫停合約
  T+30 分鐘  初步損失評估完成
  T+1 小時   對外公告事故
  T+4 小時   根本原因初步分析完成
  T+24 小時  詳細 postmortem 發布
  T+7 天     修復方案完成 + 審計
  T+14 天    修復部署 + 分階段恢復
  T+30 天    用戶補償方案執行完畢
</code></pre>
<p><strong>關鍵教訓：</strong></p>
<ul>
<li>T+0 到 T+12 分鐘的窗口決定了損失的大小。如果暫停速度更慢，損失會更大</li>
<li>攻擊者通常會在週末或假期發動攻擊，因為這時回應速度最慢</li>
<li>事後的透明度和溝通對於維護社群信任至關重要</li>
<li>每次事故都是改進安全流程的機會</li>
</ul>
<h2 id="白話總結-10"><a class="header" href="#白話總結-10">白話總結</a></h2>
<p>安全不是審一次 code 就結束，而是整個開發到營運流程都要可驗證、可追責。區塊鏈系統的攻擊面非常廣，不只是合約程式碼本身——前端被篡改、私鑰被盜、預言機被操控、跨鏈橋 validator 被攻陷，每一個環節都可能成為攻擊者的突破口。</p>
<p>歷史上最慘烈的安全事故往往不是因為某行程式碼寫錯了，而是因為整個系統的安全架構有根本性的缺陷。例如 Ronin Bridge 的問題不是合約有 bug，而是 9 個 validator 中有 5 個由同一個組織控制。BadgerDAO 的問題不是合約有漏洞，而是前端被注入了惡意腳本讓用戶簽署了惡意授權。</p>
<p>防禦的核心理念是「深度防禦」：預防、偵測、回應、恢復四層防線缺一不可。寫出安全的合約只是第一步（預防），你還需要即時監控偵測異常行為、在攻擊發生時能快速暫停止血、以及攻擊結束後能正確地追蹤資金和補償用戶。</p>
<p>測試也不能只做 unit test 就覺得夠了。不變量測試能發現系統級的邏輯漏洞，模糊測試能發現邊界條件的問題，主網分叉模擬能測試在真實狀態下的行為。這些測試方法需要組合使用，因為沒有任何一種方法能覆蓋所有的攻擊向量。</p>
<p>最後，營運安全是持續性的工作，不是做一次就完成的。定期的密鑰輪替、交易前模擬、雙人覆核、安全意識培訓、以及事故演練，都是確保系統長期安全運行的必要投入。安全是一場馬拉松，不是短跑。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-監控sre-與工程交付"><a class="header" href="#12-監控sre-與工程交付">12. 監控、SRE 與工程交付</a></h1>
<h2 id="121-可觀測性指標"><a class="header" href="#121-可觀測性指標">12.1 可觀測性指標</a></h2>
<p>可觀測性（Observability）在 Web3 的語境下，不只是「伺服器有沒有活著」，而是「鏈上狀態轉移是否正常、資產是否安全、交易是否如期完成」。傳統的 Web2 監控關注 CPU、記憶體、請求延遲；Web3 的監控則需要同時追蹤鏈上和鏈下兩個維度的指標。</p>
<p>可觀測性的三大支柱——Metrics（指標）、Logs（日誌）、Traces（追蹤）——在 Web3 中同樣適用，但需要針對區塊鏈的特性進行調整和擴展。</p>
<pre><code class="language-text">                    Web3 可觀測性架構
┌─────────────────────────────────────────────────────┐
│                                                     │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐          │
│  │ Metrics  │  │  Logs    │  │ Traces   │          │
│  │ 數值指標  │  │  事件日誌 │  │ 交易追蹤  │          │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘          │
│       │             │             │                 │
│       v             v             v                 │
│  ┌──────────────────────────────────────┐           │
│  │        Prometheus / Grafana          │           │
│  │    + ELK Stack / Loki               │           │
│  │    + Jaeger / 自建 tx tracer        │           │
│  └──────────────────────────────────────┘           │
│       │                                             │
│       v                                             │
│  ┌──────────────────────────────────────┐           │
│  │        告警引擎（Alertmanager）       │           │
│  │    P0: PagerDuty 電話               │           │
│  │    P1: Slack/Telegram               │           │
│  │    P2: Email/Dashboard              │           │
│  └──────────────────────────────────────┘           │
└─────────────────────────────────────────────────────┘
</code></pre>
<p>以下是 Web3 環境中必須監控的核心指標。</p>
<p><strong>鏈高度差（本地 vs 參考）</strong></p>
<p>鏈高度差（Block Height Lag）是衡量本地節點是否與網路同步的最基本指標。如果本地節點的區塊高度落後參考節點超過一定數量（例如 10 個區塊），說明節點可能正在同步、網路連線中斷、或磁碟 I/O 瓶頸。落後的節點會回傳過時的狀態，導致交易基於舊資訊構建，可能被 revert 或錯過時間敏感的操作。</p>
<p>建議同時從多個獨立的參考來源取得最新區塊高度（例如 Etherscan API、Alchemy、Infura），避免單一來源的誤報。差值超過 5 個區塊時觸發 P1 告警，超過 50 個區塊時觸發 P0 告警。</p>
<pre><code class="language-python"># Prometheus 指標匯出範例（Python）
from prometheus_client import Gauge

block_height_local = Gauge(
    'block_height_local',
    'Local node block height'
)
block_height_reference = Gauge(
    'block_height_reference',
    'Reference block height from external source'
)
block_height_lag = Gauge(
    'block_height_lag',
    'Difference between reference and local block height'
)

def update_block_metrics():
    local = get_local_block_number()
    reference = get_reference_block_number()
    block_height_local.set(local)
    block_height_reference.set(reference)
    block_height_lag.set(reference - local)
</code></pre>
<p><strong>RPC 成功率與延遲分位數</strong></p>
<p>RPC 端點是應用與區塊鏈互動的門戶，其可用性和效能直接影響整個系統的運作。需要監控的指標包括：</p>
<ul>
<li><strong>成功率</strong>：每分鐘/每五分鐘的 RPC 呼叫成功率。低於 99.5% 應觸發告警。</li>
<li><strong>延遲分位數</strong>：P50（中位數）、P90、P95、P99 的回應時間。P99 延遲超過 2 秒應觸發告警，因為這暗示尾部延遲可能影響時間敏感的操作。</li>
<li><strong>按方法分類</strong>：不同的 RPC 方法（<code>eth_call</code>、<code>eth_sendRawTransaction</code>、<code>eth_getBalance</code>）的效能差異很大，應該分別監控。</li>
<li><strong>按提供者分類</strong>：如果使用多個 RPC 提供者（Alchemy、Infura、QuickNode），分別追蹤每個提供者的效能，以便在某個提供者降級時快速切換。</li>
</ul>
<pre><code class="language-yaml"># Grafana 告警規則範例（PromQL）
groups:
  - name: rpc_alerts
    rules:
      - alert: RPCHighErrorRate
        expr: |
          rate(rpc_requests_total{status="error"}[5m])
          / rate(rpc_requests_total[5m]) &gt; 0.005
        for: 2m
        labels:
          severity: P1
        annotations:
          summary: "RPC error rate &gt; 0.5%"

      - alert: RPCHighLatency
        expr: |
          histogram_quantile(0.99,
            rate(rpc_duration_seconds_bucket[5m])
          ) &gt; 2.0
        for: 5m
        labels:
          severity: P1
        annotations:
          summary: "RPC P99 latency &gt; 2s"
</code></pre>
<p><strong>交易狀態轉換耗時</strong></p>
<p>交易從被提交到被確認的全程追蹤。一筆交易通常會經歷以下狀態：<code>Created -&gt; Signed -&gt; Submitted -&gt; Pending -&gt; Mined -&gt; Confirmed</code>。需要監控每個狀態之間的轉換時間，以及卡在某個狀態超時的交易數量。</p>
<p>交易卡在 <code>Pending</code> 狀態是最常見的問題，原因包括：gas price 設定過低、nonce 衝突（前面的交易還沒完成）、RPC 端點沒有正確廣播交易。自動化系統應該能偵測到卡住的交易，並根據策略進行加速（Replace-by-Fee）或取消。</p>
<pre><code class="language-text">交易生命週期追蹤：

  Created ──&gt; Signed ──&gt; Submitted ──&gt; Pending ──&gt; Mined ──&gt; Confirmed
    │           │           │            │           │          │
    t0          t1          t2           t3          t4         t5
    │           │           │            │           │          │
    │&lt;─簽名耗時─&gt;│&lt;─提交耗時─&gt;│&lt;──mempool──&gt;│&lt;─確認延遲─&gt;│
    │                                                          │
    └──────────────── 全程耗時（SLA 目標）─────────────────────┘

  監控重點：
  - t2 - t0 &gt; 30s  : 簽名或提交流程異常
  - t4 - t2 &gt; 5min : 交易可能卡住，考慮加速
  - t5 - t4 &gt; 30min: 確認數不足，可能存在 reorg 風險
</code></pre>
<p><strong>失敗率（revert/drop/replaced）</strong></p>
<p>交易失敗有多種型態，每種需要不同的處理方式：</p>
<ul>
<li><strong>Revert</strong>：交易被區塊鏈執行但失敗（例如 <code>require()</code> 條件不滿足）。雖然交易失敗了，但仍然消耗了 gas。高 revert 率暗示呼叫端的參數驗證或狀態檢查不充分。</li>
<li><strong>Drop</strong>：交易在 mempool 中被丟棄，通常是因為 gas price 過低或 mempool 擁塞。被丟棄的交易不消耗 gas，但會延遲業務流程。</li>
<li><strong>Replaced</strong>：交易被同一 nonce 的新交易取代（Replace-by-Fee）。這通常是自動化加速機制的正常行為，但如果 replacement 頻率過高，說明 gas 估算策略需要優化。</li>
</ul>
<p>建議追蹤每個類型的失敗率，分別設定告警閾值。Revert 率超過 1% 應觸發 P1 告警；非預期的 drop 或 replacement 應立即調查。</p>
<p><strong>錢包餘額與授權變化</strong></p>
<p>錢包餘額的監控是資金安全的最後一道防線。需要監控的項目包括：</p>
<ul>
<li><strong>原生幣餘額</strong>（ETH、MATIC 等）：Hot Wallet 的 gas 帳戶餘額低於閾值時需要自動補充</li>
<li><strong>ERC-20 Token 餘額</strong>：異常的餘額變化（非預期的大額轉出）需要立即告警</li>
<li><strong>授權額度變化</strong>（ERC-20 approval）：監測 <code>Approval</code> 事件，特別是授權給未知地址或授權額度為 <code>type(uint256).max</code> 的操作</li>
<li><strong>NFT 持有變化</strong>：監測 ERC-721/1155 的轉移事件</li>
</ul>
<pre><code class="language-python"># 錢包餘額監控腳本範例
import time
from web3 import Web3

WATCHED_WALLETS = {
    "hot_wallet": "0x...",
    "ops_treasury": "0x...",
    "root_treasury": "0x...",
}

THRESHOLDS = {
    "hot_wallet": {
        "eth_min": Web3.to_wei(1, "ether"),
        "max_change_pct": 20,  # 單次變動超過 20% 告警
    },
    "ops_treasury": {
        "eth_min": Web3.to_wei(10, "ether"),
        "max_change_pct": 10,
    },
    "root_treasury": {
        "eth_min": Web3.to_wei(100, "ether"),
        "max_change_pct": 5,
    },
}

def check_balances(w3):
    for name, address in WATCHED_WALLETS.items():
        balance = w3.eth.get_balance(address)
        threshold = THRESHOLDS[name]

        if balance &lt; threshold["eth_min"]:
            alert(f"P1: {name} balance low: {balance}")

        change_pct = calculate_change_pct(name, balance)
        if abs(change_pct) &gt; threshold["max_change_pct"]:
            alert(f"P0: {name} balance changed {change_pct}%")
</code></pre>
<h2 id="122-告警分級"><a class="header" href="#122-告警分級">12.2 告警分級</a></h2>
<p>告警分級的核心原則是「不同嚴重程度的事件需要不同的回應速度和回應方式」。過度告警（alert fatigue）是 SRE 最大的敵人——如果每個告警都是 P0，那就等於沒有告警分級。</p>
<p><strong>P0: 立即回應（5 分鐘內）</strong></p>
<p>P0 是最高嚴重等級的告警，代表「正在發生或即將發生資金損失」。P0 告警應該觸發電話叫醒（PagerDuty）和所有核心團隊成員的通知。收到 P0 告警的 on-call 工程師必須在 5 分鐘內確認並開始處理。</p>
<p>P0 場景包括：</p>
<ul>
<li>資金異常：合約餘額在短時間內大幅下降、異常大額轉出</li>
<li>私鑰疑似外洩：多簽簽名人報告未授權的簽名活動</li>
<li>跨鏈異常大額：橋接交易金額異常或橋接合約餘額急劇變化</li>
<li>合約被暫停但非預期：有人觸發了暫停但不是計畫內的操作</li>
</ul>
<pre><code class="language-text">P0 告警回應流程：

  告警觸發 ──&gt; PagerDuty 電話 ──&gt; 5min 內確認
       │
       v
  確認事故 ──&gt; 判斷是否需要暫停
       │                │
       │ 是              │ 否
       v                v
  觸發 Pause ──&gt;  繼續調查
       │
       v
  通知核心團隊 + 安全合作夥伴
       │
       v
  持續更新狀態（每 30 分鐘）
</code></pre>
<p><strong>P1: 緊急回應（30 分鐘內）</strong></p>
<p>P1 告警代表「系統功能受損但尚未造成資金損失」。P1 告警透過 Slack/Telegram 通知，on-call 工程師需要在 30 分鐘內開始處理。</p>
<p>P1 場景包括：</p>
<ul>
<li>交易卡 pending：批量交易長時間未被確認，影響業務流程</li>
<li>節點脫節：本地節點與網路的區塊高度差持續擴大</li>
<li>預言機偏差：預言機回報的價格與市場價格的偏差超過閾值（例如 2%）</li>
<li>RPC 可用性下降：主要 RPC 端點的成功率降至 95% 以下</li>
</ul>
<p><strong>P2: 常規回應（工作時間內處理）</strong></p>
<p>P2 告警代表「需要關注但不緊急的問題」。P2 告警記錄到 dashboard 和 email，在下一個工作日內處理。</p>
<p>P2 場景包括：</p>
<ul>
<li>延遲上升：RPC 延遲 P99 升高但仍在可接受範圍內</li>
<li>索引落後：The Graph 子圖或自建索引器落後數個區塊</li>
<li>gas price 持續偏高：可能影響營運成本</li>
<li>即將到期的憑證或域名</li>
</ul>
<p><strong>告警分級決策矩陣：</strong></p>
<div class="table-wrapper"><table><thead><tr><th>判斷維度</th><th>P0</th><th>P1</th><th>P2</th></tr></thead><tbody>
<tr><td>資金風險</td><td>正在損失或即將損失</td><td>潛在風險但可控</td><td>無直接風險</td></tr>
<tr><td>影響範圍</td><td>全部用戶</td><td>部分功能</td><td>效能/體驗</td></tr>
<tr><td>回應時間</td><td>5 分鐘</td><td>30 分鐘</td><td>工作時間</td></tr>
<tr><td>通知方式</td><td>電話 + 全員</td><td>Slack + on-call</td><td>Email + Dashboard</td></tr>
<tr><td>升級規則</td><td>15min 無回應自動升級到管理層</td><td>2hr 無回應升級到 P0</td><td>24hr 無人處理升級到 P1</td></tr>
</tbody></table>
</div>
<p><strong>防止告警疲勞的最佳實踐：</strong></p>
<ul>
<li>每月檢視告警數據，刪除從未觸發或觸發但無需行動的告警</li>
<li>對頻繁觸發的低嚴重度告警進行根因修復，而非調高閾值</li>
<li>設定告警靜默規則（silencing）：已知的計畫性維護期間靜默相關告警</li>
<li>每個告警必須附帶 Runbook 連結，告訴收到告警的人下一步該做什麼</li>
</ul>
<h2 id="123-發版流程"><a class="header" href="#123-發版流程">12.3 發版流程</a></h2>
<p>區塊鏈上的合約部署不像傳統軟體可以隨時回滾。一旦合約上鏈，它的程式碼就是永久性的（除非使用 proxy pattern 進行升級）。因此，發版流程必須格外嚴謹。</p>
<p><strong>1. 測試網部署與回歸</strong></p>
<p>所有新版本必須先在測試網（Sepolia、Goerli、Mumbai 等）上完整部署並進行回歸測試。測試網部署不只是「合約能不能部署成功」，而是要完整地測試整個工作流程：部署、初始化、參數設定、權限配置、和關鍵操作的端對端流程。</p>
<p>測試網環境應該盡可能模擬主網的配置，包括多簽設定、timelock 參數、和預言機整合。使用自動化腳本（如 Foundry 的 <code>forge script</code>）進行部署，確保部署流程可重複、可審計。</p>
<pre><code class="language-bash"># Foundry 部署腳本範例
forge script script/Deploy.s.sol:DeployScript \
  --rpc-url $SEPOLIA_RPC \
  --broadcast \
  --verify \
  --etherscan-api-key $ETHERSCAN_KEY \
  -vvvv

# 部署後自動化驗證
forge script script/Verify.s.sol:VerifyScript \
  --rpc-url $SEPOLIA_RPC \
  --sig "run(address)" $DEPLOYED_ADDRESS
</code></pre>
<p><strong>2. Mainnet Fork 模擬</strong></p>
<p>在真正部署到主網之前，使用主網分叉在本地模擬部署的完整效果。這可以發現只在真實主網狀態下才會出現的問題，例如：與已部署合約的互動、真實的流動性環境、gas 消耗估算等。</p>
<pre><code class="language-bash"># 主網分叉模擬部署
forge script script/Deploy.s.sol:DeployScript \
  --fork-url $ETH_MAINNET_RPC \
  --fork-block-number $(cast block-number --rpc-url $ETH_MAINNET_RPC) \
  -vvvv

# 在分叉環境中執行整合測試
forge test --fork-url $ETH_MAINNET_RPC -vvv --match-contract Integration
</code></pre>
<p><strong>3. 審批與變更窗口</strong></p>
<p>每次主網部署都需要正式的審批流程。審批文件應該包含：變更說明、影響範圍、回滾方案、測試結果（包含測試網和主網分叉的結果）、審計報告（如適用）。</p>
<p>變更窗口應該選擇在團隊精力最好的工作日白天進行，避免週五下午（避免週末出問題時人力不足）。部署前需要確認 on-call 工程師已準備就緒，監控 dashboard 已打開。</p>
<p><strong>4. 小流量灰度</strong></p>
<p>對於可灰度發布的系統（例如後端服務、索引器），先以小流量（5-10%）運行新版本。觀察關鍵指標（成功率、延遲、error rate）是否正常後，再逐步擴大到全量。</p>
<p>對於合約升級，「灰度」的概念體現在：先在一個小型的測試市場或低 TVL 的池中進行升級，觀察一段時間後再升級核心市場。</p>
<p><strong>5. 全量啟用</strong></p>
<p>灰度驗證通過後，將新版本推廣到所有流量。全量啟用後，需要保持高度關注至少 24 小時。</p>
<p><strong>6. 觀察期與回滾預案</strong></p>
<p>全量啟用後進入觀察期（通常 24-72 小時）。觀察期內，任何異常指標都應該立即觸發調查。對於合約升級，觀察期需要更長（1-2 週），因為某些問題可能在特定市場條件下才會顯現。</p>
<p>回滾預案必須在部署前就準備好，包括：proxy pattern 的回滾腳本、參數回調的 multisig 交易、以及服務降級方案。</p>
<pre><code class="language-text">發版流程全景：

  ┌────────────┐     ┌──────────────┐     ┌───────────────┐
  │ 1.測試網    │────&gt;│ 2.主網分叉    │────&gt;│ 3.審批+變更窗口│
  │ 部署+回歸   │     │ 模擬部署      │     │ 正式審批文件   │
  └────────────┘     └──────────────┘     └───────┬───────┘
                                                   │
  ┌────────────┐     ┌──────────────┐     ┌───────▼───────┐
  │ 6.觀察期    │&lt;────│ 5.全量啟用    │&lt;────│ 4.小流量灰度  │
  │ +回滾預案   │     │              │     │ 5-10% 流量    │
  └────────────┘     └──────────────┘     └───────────────┘

  每個階段的 Gate（門檻）：
  1-&gt;2: 測試網所有測試通過
  2-&gt;3: 主網分叉模擬無異常
  3-&gt;4: 審批通過 + on-call 就緒
  4-&gt;5: 灰度指標正常 ≥ 4 小時
  5-&gt;6: 全量後指標正常 ≥ 1 小時
</code></pre>
<h2 id="124-runbook-基本模板"><a class="header" href="#124-runbook-基本模板">12.4 Runbook 基本模板</a></h2>
<p>Runbook 是事故回應的標準操作程序（SOP），它的存在是為了讓任何收到告警的工程師——即使不是最熟悉該系統的人——都能快速地執行正確的止血動作。好的 Runbook 不需要工程師思考「接下來該做什麼」，而是直接告訴他「執行這些步驟」。</p>
<p><strong>觸發條件</strong></p>
<p>明確定義什麼情況下應該使用這份 Runbook。觸發條件應該與告警規則完全對應，讓收到告警的人可以立即找到對應的 Runbook。避免模糊的觸發條件（如「系統異常時」），而應該使用具體的指標和閾值（如「合約 ETH 餘額在 5 分鐘內下降超過 10%」）。</p>
<p><strong>立即止血動作</strong></p>
<p>止血動作是 Runbook 最重要的部分。它應該是一系列可以直接複製貼上執行的指令，不需要工程師自己判斷或構造。在壓力之下，人的判斷力會下降，所以預先準備好的指令比臨場決策更可靠。</p>
<pre><code class="language-bash"># Runbook 範例：合約餘額異常下降
# 觸發條件：合約 ETH 餘額在 5 分鐘內下降超過 10%

## 步驟 1：確認異常（1 分鐘）
# 查看合約當前餘額
cast balance $CONTRACT_ADDRESS --rpc-url $RPC_URL

# 查看最近的轉出交易
cast logs --from-block $RECENT_BLOCK \
  --address $CONTRACT_ADDRESS \
  "Transfer(address,address,uint256)" \
  --rpc-url $RPC_URL

## 步驟 2：止血（2 分鐘）
# 如果確認為非授權轉出，立即暫停合約
# 使用 Pause Guardian 多簽（需要 1-of-N 簽名）
cast send $CONTRACT_ADDRESS "pause()" \
  --private-key $GUARDIAN_KEY \
  --rpc-url $RPC_URL

## 步驟 3：通知（5 分鐘）
# 在 #security-incidents Slack 頻道通知核心團隊
# 聯繫安全合作夥伴
# 記錄事故開始時間和初步觀察
</code></pre>
<p><strong>升級路徑</strong></p>
<p>定義什麼情況下需要升級事故等級，以及如何升級。</p>
<div class="table-wrapper"><table><thead><tr><th>升級條件</th><th>動作</th></tr></thead><tbody>
<tr><td>5 分鐘無法確認事故性質</td><td>叫醒第二位 on-call</td></tr>
<tr><td>確認為安全攻擊</td><td>升級到 P0 + 通知全部核心團隊</td></tr>
<tr><td>損失超過 $100K</td><td>通知管理層 + 法務</td></tr>
<tr><td>損失超過 $1M</td><td>啟動外部安全公司協助</td></tr>
</tbody></table>
</div>
<p><strong>回復步驟</strong></p>
<p>事故結束後的恢復流程，包括如何安全地解除暫停、如何驗證系統恢復正常、以及如何進行事後審計。回復步驟比止血更需要謹慎——在攻擊者可能仍在監視系統的情況下，貿然解除暫停可能導致第二波攻擊。</p>
<p><strong>對外溝通與法遵</strong></p>
<p>定義在不同嚴重等級下，對外溝通的時間要求和內容模板。例如：P0 事故需要在 1 小時內發布初步聲明；確認損失後需要在 24 小時內提供詳細報告。溝通內容需要法務審核，避免在事實尚未完全確認的情況下做出承諾。</p>
<pre><code class="language-text">Runbook 模板結構：

  ┌─────────────────────────────────────────────┐
  │ Runbook: [告警名稱]                          │
  │ 最後更新: YYYY-MM-DD                         │
  │ 負責團隊: [團隊名稱]                         │
  ├─────────────────────────────────────────────┤
  │ 1. 觸發條件                                  │
  │    - 告警名稱和對應的 Grafana dashboard 連結  │
  │    - 具體的指標閾值                           │
  ├─────────────────────────────────────────────┤
  │ 2. 止血動作（可複製貼上的指令）               │
  │    - 步驟 1: 確認（≤1min）                   │
  │    - 步驟 2: 止血（≤5min）                   │
  │    - 步驟 3: 通知（≤10min）                  │
  ├─────────────────────────────────────────────┤
  │ 3. 升級路徑                                  │
  │    - 條件 -&gt; 動作                            │
  ├─────────────────────────────────────────────┤
  │ 4. 回復步驟                                  │
  │    - 前提條件（確認攻擊已停止）               │
  │    - 恢復指令                                │
  │    - 驗證步驟                                │
  ├─────────────────────────────────────────────┤
  │ 5. 溝通模板                                  │
  │    - 內部通知模板                             │
  │    - 對外聲明模板                             │
  │    - 法務聯繫人                               │
  └─────────────────────────────────────────────┘
</code></pre>
<p><strong>Runbook 維護的最佳實踐：</strong></p>
<ul>
<li>每次事故後更新相關的 Runbook</li>
<li>每季進行 Runbook 演練（dry run），確認指令仍然有效</li>
<li>Runbook 不要太長，一份 Runbook 控制在 2 頁以內</li>
<li>所有 Runbook 存放在統一的位置（如 Notion、Confluence、或 Git repo），並確保 on-call 工程師能快速存取</li>
</ul>
<h2 id="125-事件追蹤資料"><a class="header" href="#125-事件追蹤資料">12.5 事件追蹤資料</a></h2>
<p>完整的事件追蹤資料（Audit Trail）是事故分析和合規審計的基礎。區塊鏈天生提供了不可篡改的交易記錄，但這不代表不需要額外的追蹤——鏈上記錄缺乏足夠的上下文資訊（例如「為什麼」執行這筆交易、「誰」批准的、模擬結果是什麼），這些都需要鏈下的追蹤系統補充。</p>
<p><strong>tx hash / block number</strong></p>
<p>每筆鏈上交易的 tx hash 和所在的 block number 是最基礎的追蹤資料。tx hash 是全域唯一的，可以用來在區塊鏈瀏覽器（如 Etherscan）上查詢交易的完整細節。block number 提供了時間維度的資訊，也用於定位特定時間點的鏈上狀態。</p>
<p>建議在內部系統中建立交易索引，將 tx hash 與業務操作（如「補充 Hot Wallet」、「執行清算」）關聯起來。這在事故調查時可以快速定位相關交易。</p>
<p><strong>signer id / policy id</strong></p>
<p>記錄每筆交易的簽署人身份和適用的政策。在多簽系統中，需要記錄哪些簽名人參與了簽署、使用了哪一組多簽、以及交易是基於哪個政策規則被批准的（例如「日常營運 2/3」或「緊急止血 2/5」）。</p>
<p>這些資訊對於事後審計至關重要：如果發現一筆可疑交易，可以立即追溯到具體的簽署人和審批流程。</p>
<p><strong>simulation result hash</strong></p>
<p>在交易簽署前，應該記錄模擬結果的 hash。模擬結果包括：預期的狀態變更、預期的事件日誌、預期的 gas 消耗。將模擬結果 hash 化後存儲，可以在事後驗證「簽署時看到的模擬結果」和「實際執行結果」是否一致。如果不一致，說明交易簽署時的鏈上狀態與實際執行時不同，可能存在 MEV 攻擊或 frontrunning。</p>
<p><strong>before/after balance snapshot</strong></p>
<p>每筆關鍵交易前後的餘額快照。不只是合約本身的餘額，還包括所有相關地址（用戶、金庫、手續費收取地址等）的餘額。這為財務對帳提供了可驗證的數據來源。</p>
<pre><code class="language-text">完整的事件追蹤記錄結構：

  ┌──────────────────────────────────────────────────┐
  │ Event Record                                      │
  ├──────────────────────────────────────────────────┤
  │ tx_hash:      0xabc...def                         │
  │ block_number: 19,000,123                          │
  │ timestamp:    2024-03-15T10:30:00Z                │
  │ chain_id:     1 (Ethereum Mainnet)                │
  ├──────────────────────────────────────────────────┤
  │ signer_ids:   [signer_A, signer_B, signer_C]     │
  │ policy_id:    ops_treasury_2of3                   │
  │ approval_ticket: JIRA-1234                        │
  ├──────────────────────────────────────────────────┤
  │ simulation_hash:  0x123...789                     │
  │ simulation_tool:  Tenderly v2.1                   │
  │ simulation_block: 19,000,120                      │
  ├──────────────────────────────────────────────────┤
  │ before_balance:                                   │
  │   contract:  1,000.00 USDC                        │
  │   recipient:     0.00 USDC                        │
  │ after_balance:                                    │
  │   contract:    900.00 USDC                        │
  │   recipient:   100.00 USDC                        │
  ├──────────────────────────────────────────────────┤
  │ actual_vs_simulated: MATCH ✓                      │
  │ notes: "Monthly ops budget transfer to team"      │
  └──────────────────────────────────────────────────┘
</code></pre>
<p><strong>追蹤資料的儲存與查詢</strong></p>
<p>追蹤資料應該存放在不可篡改或至少有完整審計日誌的儲存系統中。可以使用：</p>
<ul>
<li><strong>IPFS/Arweave</strong>：將關鍵的追蹤記錄上傳到去中心化儲存，確保不可篡改</li>
<li><strong>Append-only Database</strong>：使用只允許新增不允許修改或刪除的資料庫（如 Amazon QLDB）</li>
<li><strong>Git Repository</strong>：將追蹤記錄提交到專用的 Git repo，利用 Git 的版本歷史作為審計軌跡</li>
</ul>
<p>查詢方面，建議建立以下索引：</p>
<ul>
<li>按時間範圍查詢所有交易</li>
<li>按簽署人查詢其參與的所有交易</li>
<li>按合約/地址查詢相關的所有操作</li>
<li>按政策/規則查詢適用該政策的所有交易</li>
</ul>
<h2 id="126-基礎設施即程式碼"><a class="header" href="#126-基礎設施即程式碼">12.6 基礎設施即程式碼</a></h2>
<p>Web3 基礎設施的管理應該遵循 Infrastructure as Code（IaC）的原則，使用 Terraform、Pulumi 或 Ansible 等工具管理節點、RPC 端點、和監控基礎設施。手動配置的環境難以重現、難以審計、也難以在緊急情況下快速擴展。</p>
<pre><code class="language-text">Web3 基礎設施架構：

  ┌──────────────────────────────────────────────────┐
  │                    Load Balancer                   │
  │                 (Nginx / CloudFlare)               │
  └─────────────┬──────────────┬───────────────────────┘
                │              │
  ┌─────────────▼──┐  ┌───────▼─────────┐
  │  RPC 節點叢集   │  │  後端服務叢集     │
  │  ┌────┐ ┌────┐ │  │  ┌────┐ ┌────┐  │
  │  │Geth│ │Geth│ │  │  │ API│ │ API│  │
  │  │ #1 │ │ #2 │ │  │  │ #1 │ │ #2 │  │
  │  └────┘ └────┘ │  │  └────┘ └────┘  │
  └────────────────┘  └─────────────────┘
         │                     │
         v                     v
  ┌──────────────┐    ┌──────────────┐
  │ 備援 RPC     │    │  資料庫       │
  │ (Alchemy/    │    │ (PostgreSQL  │
  │  Infura)     │    │  + Redis)    │
  └──────────────┘    └──────────────┘
</code></pre>
<p><strong>節點管理最佳實踐：</strong></p>
<ul>
<li>至少運行兩個獨立的全節點，互為備援</li>
<li>同時接入第三方 RPC 服務（Alchemy、Infura）作為 fallback</li>
<li>監控節點的磁碟使用率——全節點的儲存需求持續增長，需要定期擴容或啟用 pruning</li>
<li>設定自動重啟和健康檢查腳本</li>
</ul>
<p><strong>CI/CD 管道與合約部署：</strong></p>
<p>合約部署不應該是手動操作，而是透過 CI/CD 管道自動化。管道應該包含：編譯、測試、靜態分析、部署到測試網、自動化驗證。只有所有步驟都通過後，才允許人工批准並部署到主網。</p>
<pre><code class="language-yaml"># GitHub Actions 合約 CI/CD 範例
name: Contract CI/CD
on:
  push:
    branches: [main]
  pull_request:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: foundry-rs/foundry-toolchain@v1

      - name: Build
        run: forge build --sizes

      - name: Unit Tests
        run: forge test -vvv

      - name: Invariant Tests
        run: forge test --match-contract Invariant -vvv

      - name: Slither Analysis
        uses: crytic/slither-action@v0.3.0

      - name: Gas Report
        run: forge test --gas-report

  deploy-testnet:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Sepolia
        run: |
          forge script script/Deploy.s.sol \
            --rpc-url $SEPOLIA_RPC \
            --broadcast \
            --verify

      - name: Post-deploy Verification
        run: |
          forge script script/Verify.s.sol \
            --rpc-url $SEPOLIA_RPC
</code></pre>
<h2 id="白話總結-11"><a class="header" href="#白話總結-11">白話總結</a></h2>
<p>Web3 SRE 的核心不是「伺服器活著」，而是「資產與狀態轉移可控、可追蹤、可回應」。在傳統的 Web2 世界裡，最壞的情況是服務中斷用戶暫時無法使用；但在 Web3 中，最壞的情況是資金被盜且無法逆轉。這個根本差異決定了 Web3 監控和運維的一切設計決策。</p>
<p>可觀測性的重點不是監控越多越好，而是監控對的東西。區塊鏈高度差告訴你節點是否跟上了；RPC 延遲告訴你系統是否能及時回應；交易失敗率告訴你業務流程是否正常；錢包餘額變化則是資金安全的最直接信號。這四類指標構成了 Web3 可觀測性的基礎。</p>
<p>告警分級是為了確保真正緊急的事情能得到立即回應，而不是讓工程師被大量無關緊要的告警淹沒。P0 是「打電話叫醒人」的等級，只用於資金正在流失的場景；P1 是「發 Slack 訊息」的等級，用於系統功能受損但還沒到資金損失的程度；P2 是「記到 dashboard」的等級，工作時間處理就好。</p>
<p>發版流程在 Web3 中特別重要，因為合約一旦上鏈就是永久的。每次部署都要經過測試網驗證、主網分叉模擬、正式審批、灰度發布、觀察期這完整的流程。這聽起來很慢，但比起部署了有問題的合約損失數百萬美元，多花幾天做驗證是非常划算的。</p>
<p>Runbook 的價值在於讓團隊在壓力最大的時候不需要思考下一步該做什麼，而是按照預先寫好的步驟執行。好的 Runbook 應該具體到可以直接複製貼上指令，不需要工程師臨場判斷。每次事故後更新 Runbook、每季演練一次，才能確保 Runbook 在真正需要時是有效的。</p>
<p>完整的事件追蹤記錄讓每一筆操作都有跡可循：誰發起的、誰批准的、模擬結果是什麼、實際執行結果是什麼。這些資料不只在事故調查時有用，在合規審計、財務對帳、和團隊覆盤時都是不可或缺的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-參考架構藍圖"><a class="header" href="#13-參考架構藍圖">13. 參考架構藍圖</a></h1>
<p>本章提供三種常見區塊鏈系統的參考架構：消費級 DApp、機構級資產系統、以及 DAO 治理架構。每一種架構對應不同的工程優先級與風險模型，實務中應根據團隊規模、法遵要求、以及目標用戶群體來選擇或混合使用。</p>
<p>架構選擇的核心決策往往不是技術問題，而是優先級的取捨。消費級 DApp 追求使用者體驗與成本效率，機構級系統強調安全可控與合規，DAO 則需要在去中心化治理與執行效率之間找到平衡。理解這三者的差異，有助於在設計初期就避免走錯方向。</p>
<hr />
<h2 id="131-消費級-dapp"><a class="header" href="#131-消費級-dapp">13.1 消費級 DApp</a></h2>
<pre><code class="language-text">┌───────────────────────────────────────────────────────┐
│                   Frontend (Web/Mobile)                │
│        React/Next.js + WalletConnect/RainbowKit       │
└─────────────────────┬─────────────────────────────────┘
                      │ REST/GraphQL
                      v
┌───────────────────────────────────────────────────────┐
│              Backend API (Node.js / Go / Rust)        │
│         ┌─────────────┬──────────────┐                │
│         │ Auth/Session │  Business    │                │
│         │   Service    │  Logic       │                │
│         └──────┬──────┴──────┬───────┘                │
│                │             │                        │
│         ┌──────v──────┐ ┌───v──────────┐              │
│         │  Cache/DB   │ │  Event Index │              │
│         │ Redis/PG    │ │  (Subgraph)  │              │
│         └─────────────┘ └──────────────┘              │
└─────────────────────┬─────────────────────────────────┘
                      │
                      v
┌───────────────────────────────────────────────────────┐
│                   Tx Service Layer                     │
│    ┌────────────┬──────────────┬────────────┐         │
│    │ Simulation │  Risk Rules  │  Gas Mgmt  │         │
│    │ (Tenderly) │  (limits,    │  (oracle,  │         │
│    │            │   blacklist) │   buffer)  │         │
│    └────────────┴──────────────┴────────────┘         │
└─────────────────────┬─────────────────────────────────┘
                      │
                      v
┌───────────────────────────────────────────────────────┐
│           Wallet Adapter (EOA / AA / Social Login)    │
│      MetaMask | WalletConnect | ERC-4337 Bundler      │
└─────────────────────┬─────────────────────────────────┘
                      │
                      v
┌───────────────────────────────────────────────────────┐
│              RPC Pool (Load Balanced)                  │
│        ┌──────────────┬──────────────────┐            │
│        │   L2 (Main)  │  L1 (Settlement) │            │
│        │  Arbitrum /   │  Ethereum        │            │
│        │  Optimism /   │  Mainnet         │            │
│        │  Base         │                  │            │
│        └──────────────┴──────────────────┘            │
└───────────────────────────────────────────────────────┘
</code></pre>
<h3 id="架構說明"><a class="header" href="#架構說明">架構說明</a></h3>
<p>消費級 DApp 的核心目標是讓普通用戶能以最低門檻使用區塊鏈應用。這意味著前端體驗必須接近 Web2 水準，交易成本必須控制在用戶可接受的範圍內，且錢包連接流程要盡量順暢。</p>
<p>在前端層，現代 DApp 通常使用 React 或 Next.js 搭配 WalletConnect 或 RainbowKit 等錢包整合套件。前端不應直接構造交易，而是透過 Backend API 來處理交易邏輯。這樣做的好處是可以在後端加入模擬、風控、以及 gas 管理邏輯，避免用戶因交易失敗而浪費 gas fee。</p>
<p>Transaction Service Layer 是這個架構中最關鍵的中間層。它負責三件事：首先是交易模擬（使用 Tenderly 或 fork 模式在本地模擬交易結果），確保交易不會失敗；其次是風控規則（檢查交易金額、目標地址是否在黑名單中）；最後是 gas 管理（從 gas oracle 取得當前費率，加上適當 buffer，並管理 nonce 序列）。</p>
<h3 id="特性"><a class="header" href="#特性">特性</a></h3>
<ul>
<li><strong>成本優先，主要跑 L2</strong>：L2 的交易費用通常只有 L1 的 1/10 到 1/100，對於頻繁小額交易的 DApp 來說，這是決定性的成本優勢。選擇哪條 L2 取決於生態（Arbitrum 的 DeFi 生態最完整）、工具鏈支援、以及社群活躍度。</li>
<li><strong>小額交易可用 Account Abstraction 改善 UX</strong>：ERC-4337 允許用戶用 social login 創建智能合約錢包，支持 session key（免重複簽名）、gas sponsorship（項目方代付 gas）、以及 batch transaction（多筆交易打包）。這大幅降低了新用戶的進入門檻。</li>
<li><strong>後台做 nonce/gas/重試策略</strong>：Nonce 管理是 DApp 後端最容易出問題的地方。當多筆交易並發送出時，nonce 衝突會導致交易失敗。最佳實踐是在後端維護一個 nonce pool，使用 Redis 做原子遞增，並在交易失敗時自動重試。Gas 估算則需要考慮網路擁塞的波動，通常會在 estimated gas 上加 20-30% buffer。</li>
</ul>
<h3 id="實際案例"><a class="header" href="#實際案例">實際案例</a></h3>
<p>以一個 NFT 市場為例，用戶在前端瀏覽 NFT、下單購買時，後端會：</p>
<ol>
<li>驗證用戶身份與餘額</li>
<li>模擬購買交易（確認合約可正常執行）</li>
<li>估算 gas 費用並加上 buffer</li>
<li>分配 nonce 並送出交易</li>
<li>監聽交易狀態，失敗時自動以更高 gas price 重試（最多 3 次）</li>
</ol>
<h3 id="常見陷阱"><a class="header" href="#常見陷阱">常見陷阱</a></h3>
<ul>
<li><strong>RPC 單點故障</strong>：只用一個 RPC provider 是最常見的錯誤。應建立 RPC pool，至少包含 2-3 個 provider（如 Alchemy + Infura + 自建節點），並實作自動 failover。</li>
<li><strong>前端直接構造交易</strong>：這會將風控邏輯暴露在客戶端，任何人都可以繞過檢查直接呼叫合約。交易構造應在後端完成。</li>
<li><strong>忽略交易模擬</strong>：不做模擬就直接送出交易，會導致大量 gas 浪費在必定失敗的交易上。</li>
</ul>
<hr />
<h2 id="132-機構級資產系統"><a class="header" href="#132-機構級資產系統">13.2 機構級資產系統</a></h2>
<pre><code class="language-text">┌───────────────────────────────────────────────────────────────┐
│                     Client Portal                              │
│            (Web Dashboard / API Integration)                   │
│         Multi-tenant | Role-based Access Control               │
└──────────────────────────┬────────────────────────────────────┘
                           │ mTLS / API Key
                           v
┌───────────────────────────────────────────────────────────────┐
│                   Workflow Engine (Approval)                    │
│     ┌─────────────────────────────────────────┐                │
│     │  Request → Review → Approve → Execute   │                │
│     │      │         │        │        │       │                │
│     │  Maker-1   Checker-1  Approver  System   │                │
│     │  (initiate) (verify) (sign-off) (submit) │                │
│     └─────────────────────────────────────────┘                │
│     4-eyes principle | Configurable approval chains            │
└──────────────────────────┬────────────────────────────────────┘
                           │
              ┌────────────┴─────────────┐
              v                          v
┌─────────────────────────┐  ┌──────────────────────────┐
│   Treasury Service      │  │    Accounting Core       │
│  - Hot/Warm/Cold split  │  │  - Double-entry ledger   │
│  - Rebalancing rules    │  │  - NAV calculation       │
│  - Liquidity thresholds │  │  - Reconciliation engine │
└────────────┬────────────┘  └──────────────────────────┘
             │
             v
┌───────────────────────────────────────────────────────────────┐
│              MPC / Multisig Cluster + HSM                      │
│     ┌───────────┐  ┌───────────┐  ┌───────────┐               │
│     │  MPC Node │  │  MPC Node │  │  MPC Node │               │
│     │  (Shard1) │  │  (Shard2) │  │  (Shard3) │               │
│     └─────┬─────┘  └─────┬─────┘  └─────┬─────┘               │
│           └───────────┬───┘───────────────┘                    │
│                       v                                        │
│              ┌────────────────┐                                │
│              │  HSM (FIPS 140)│                                │
│              │  Key Storage   │                                │
│              └────────────────┘                                │
└──────────────────────────┬────────────────────────────────────┘
                           │
                           v
┌───────────────────────────────────────────────────────────────┐
│                    Policy Engine                               │
│    ┌──────────┬────────────┬─────────────┬─────────────┐       │
│    │  Limit   │  Timelock  │  Allowlist  │  Velocity   │       │
│    │  Check   │  Enforce   │  Verify     │  Control    │       │
│    └──────────┴────────────┴─────────────┴─────────────┘       │
└──────────────────────────┬────────────────────────────────────┘
                           │
                           v
┌───────────────────────────────────────────────────────────────┐
│              Execution Gateway -&gt; Multi-chain Nodes            │
│        ┌──────────┬──────────┬──────────┬──────────┐           │
│        │ Ethereum │ Bitcoin  │ Solana   │ Others   │           │
│        │  Node    │  Node    │  Node    │  Nodes   │           │
│        └──────────┴──────────┴──────────┴──────────┘           │
└──────────────────────────┬────────────────────────────────────┘
                           │
                           v
┌───────────────────────────────────────────────────────────────┐
│              Monitoring / SIEM + Incident Center               │
│    - 全鏈路交易追蹤  - 異常行為偵測  - 自動降級機制          │
│    - 合規報告生成    - 事件回應流程  - 災難復原演練          │
└───────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="架構說明-1"><a class="header" href="#架構說明-1">架構說明</a></h3>
<p>機構級資產系統（如 custodial wallet、fund management platform、exchange hot wallet 系統）的設計哲學與消費級 DApp 完全不同。消費級追求「快速、便宜、好用」，機構級追求「安全、可控、可稽核」。任何一筆交易的發起，都必須經過嚴格的審批流程（maker-checker principle），確保沒有單一個人能獨自控制大額資金。</p>
<p>Workflow Engine 是機構架構的核心差異化元件。每一筆交易（特別是出金）都必須經過 4-eyes principle（至少兩人審核）。典型的流程是：交易發起者（maker）提交請求 -&gt; 審核者（checker）驗證交易細節 -&gt; 核准者（approver）最終簽核 -&gt; 系統自動執行。對於超過特定金額門檻的交易，可能需要更多層級的審核，甚至需要 C-level 的簽核。</p>
<p>Treasury Service 負責資金的冷熱分層管理。機構通常將資產分為三層：Hot Wallet（線上、自動化、小額）占 5-10% 的總資產，用於日常營運；Warm Wallet（半線上、需人工觸發）占 20-30%，用於中等規模的調度；Cold Wallet（完全離線、物理保管）占 60-75%，用於長期儲存。系統需要自動監控 Hot Wallet 的餘額，當低於設定門檻時自動觸發從 Warm Wallet 的補充流程。</p>
<h3 id="特性-1"><a class="header" href="#特性-1">特性</a></h3>
<ul>
<li>
<p><strong>安全優先，多簽 + MPC + 冷熱分層</strong>：MPC（Multi-Party Computation）與 Multisig 是互補的安全機制。MPC 將私鑰分片分散到多個獨立的計算節點，任何單一節點都無法獨自簽名。搭配 HSM（Hardware Security Module，通過 FIPS 140-2 認證的硬體安全模組）來保護密鑰分片，可以達到銀行級別的安全標準。現代機構級系統（如 Fireblocks、Copper）多採用 MPC-TSS（Threshold Signature Scheme），因為它在鏈上只產生一個標準簽名，與普通 EOA 交易無異，既節省 gas 又保護隱私。</p>
</li>
<li>
<p><strong>完整稽核追蹤與法遵資料</strong>：每一個操作（包括查看餘額、發起交易、審核交易、修改配置）都必須有完整的 audit trail。Accounting Core 需要實作 double-entry bookkeeping（複式記帳），確保鏈上資產變動能與內部帳本精確對帳。對於受監管的機構（如持牌交易所），還需要定期產出合規報告，包括 AML/KYT 報告、資產儲備證明（Proof of Reserves）等。</p>
</li>
<li>
<p><strong>強調災難復原演練</strong>：機構系統必須有完整的 DR（Disaster Recovery）計畫，並且定期演練。這包括：MPC 節點全部失效時如何從備份恢復、HSM 故障時的替代簽名流程、以及主要雲端服務商中斷時的 failover 策略。業界建議每季至少做一次完整的 DR 演練，並記錄恢復所需時間（RTO）和可容忍的資料損失量（RPO）。</p>
</li>
</ul>
<h3 id="實際案例交易所出金流程"><a class="header" href="#實際案例交易所出金流程">實際案例：交易所出金流程</a></h3>
<pre><code class="language-text">1. 用戶提交提幣請求（前端/API）
   │
2. 風控引擎檢查：
   ├── AML/KYT 掃描目標地址
   ├── 24h 累計出金額度檢查
   ├── 用戶行為異常偵測
   └── 目標地址白名單比對
   │
3. 小額（&lt; $1,000）：自動審核 → Hot Wallet 直接出金
   中額（$1K-$50K）：1 人審核 → Hot/Warm Wallet 出金
   大額（&gt; $50K）：2 人審核 + Manager 簽核 → Warm/Cold Wallet 出金
   │
4. MPC 協同簽名 → 交易廣播
   │
5. 交易確認後更新內部帳本 + 通知用戶
</code></pre>
<h3 id="常見陷阱-1"><a class="header" href="#常見陷阱-1">常見陷阱</a></h3>
<ul>
<li><strong>Hot Wallet 資金比例過高</strong>：歷史上多起交易所被駭事件（Mt.Gox、Bitfinex）都與 Hot Wallet 存放過多資產有關。嚴格控制 Hot Wallet 比例（不超過總資產 10%）是基本底線。</li>
<li><strong>MPC 節點部署在同一個雲端供應商</strong>：如果三個 MPC 節點都部署在 AWS，當 AWS 發生區域性故障時，整個簽名系統就癱瘓了。應分散部署在不同雲端供應商或地理區域。</li>
<li><strong>缺乏鏈上鏈下對帳機制</strong>：不定期比對鏈上餘額與內部帳本，可能導致帳目不一致長期未被發現。建議每小時做一次自動對帳。</li>
</ul>
<hr />
<h2 id="133-dao-治理架構"><a class="header" href="#133-dao-治理架構">13.3 DAO 治理架構</a></h2>
<pre><code class="language-text">┌───────────────────────────────────────────────────────────────┐
│                    Community / Token Holders                    │
│              (Gov Token holders + Delegators)                  │
└──────────────────────────┬────────────────────────────────────┘
                           │ Vote / Delegate
                           v
┌───────────────────────────────────────────────────────────────┐
│                   Governance Framework                          │
│    ┌───────────────────────────────────────────────────┐       │
│    │  Gov Token (ERC-20 Votes / veToken Model)        │       │
│    │     │                                             │       │
│    │     ├── Direct Vote (1 token = 1 vote)            │       │
│    │     ├── Delegated Vote (delegate to experts)      │       │
│    │     └── veToken Lock (longer lock = more weight)  │       │
│    └───────────────────────────────────────────────────┘       │
└──────────────────────────┬────────────────────────────────────┘
                           │
                           v
┌───────────────────────────────────────────────────────────────┐
│                   Proposal Lifecycle                            │
│                                                                │
│  Draft → Discussion → Temperature Check → Formal Vote         │
│    │         │              │                  │               │
│    │     Forum/Discord   Snapshot Poll    On-chain Vote        │
│    │     (off-chain)     (off-chain)     (Governor contract)   │
│    │                                          │               │
│    │                                    ┌─────v──────┐        │
│    │                                    │  Timelock   │        │
│    │                                    │  (48-72h)   │        │
│    │                                    └─────┬──────┘        │
│    │                                          v               │
│    │                                    ┌────────────┐        │
│    │                                    │  Execution │        │
│    │                                    └────────────┘        │
└───────────────────────────────────────────────────────────────┘
                           │
                           v
┌───────────────────────────────────────────────────────────────┐
│                   Treasury Management                          │
│    ┌───────────────────────────────────────────────────┐       │
│    │  Multisig (Gnosis Safe) as transitional control  │       │
│    │  - Core team holds initial keys                   │       │
│    │  - Gradually add community signers               │       │
│    │  - Eventually migrate to full on-chain governance│       │
│    └───────────────────────────────────────────────────┘       │
└───────────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="架構說明-2"><a class="header" href="#架構說明-2">架構說明</a></h3>
<p>DAO（Decentralized Autonomous Organization）治理架構的目標是讓社群能以去中心化的方式管理協議的升級、資金分配、以及參數調整。與前兩種架構不同，DAO 的「用戶」同時也是「管理者」，這帶來了獨特的設計挑戰。</p>
<p>治理代幣（Governance Token）是 DAO 的基礎。常見的模型有兩種：簡單投票模型（1 token = 1 vote，如 Compound Governor）和 veToken 模型（鎖定代幣越久，投票權重越大，如 Curve 的 veCRV）。veToken 模型的優勢是激勵長期持有者參與治理，減少短期投機者對決策的影響。但其缺點是增加了系統複雜度，且可能導致投票權力集中在早期大戶手中。</p>
<p>委託投票（Delegation）是提高治理參與度的關鍵機制。大多數 token holder 沒有時間或專業知識來評估每一個提案，透過將投票權委託給專業的 delegates（類似議員角色），可以在保持去中心化的同時提高決策品質。Arbitrum、Optimism、Uniswap 等知名協議都有活躍的 delegate 生態。</p>
<h3 id="特性-2"><a class="header" href="#特性-2">特性</a></h3>
<ul>
<li>
<p><strong>Gov Token + Delegate</strong>：投票權委託機制允許小額持有者將投票權委託給信任的代表，避免投票參與率過低導致少數人控制決策。設計要點包括：委託是可隨時撤銷的、delegate 的投票記錄應公開透明、以及需要防止「投票買賣」（bribery attack）。</p>
</li>
<li>
<p><strong>Proposal + Timelock + Execution</strong>：提案流程通常分為多個階段。首先在論壇（如 Discourse）進行非正式討論，然後使用 Snapshot 進行 gas-free 的溫度檢查投票，最後才提交鏈上正式投票。通過的提案會進入 Timelock 合約（通常 48-72 小時），給予社群時間審查即將執行的變更，如果發現問題可以通過緊急取消機制阻止執行。</p>
</li>
<li>
<p><strong>Treasury Multisig 作為過渡控制</strong>：多數 DAO 在初期會使用 Gnosis Safe（現稱 Safe）多簽來管理國庫資金。核心團隊持有初始的簽名者角色，隨著社群成熟，逐步增加社群成員作為簽名者，最終目標是完全遷移到鏈上治理控制國庫。</p>
</li>
<li>
<p><strong>漸進去中心化路線圖</strong>：完全去中心化不是一蹴而就的。典型的路線圖是：Phase 1（核心團隊控制，multisig 管理）-&gt; Phase 2（部分鏈上治理，社群 delegate 參與）-&gt; Phase 3（完全鏈上治理，timelock 執行，核心團隊退出 multisig）。a16z 提出的 "Progressive Decentralization" 框架是業界常用的參考模型。</p>
</li>
</ul>
<h3 id="常見陷阱-2"><a class="header" href="#常見陷阱-2">常見陷阱</a></h3>
<ul>
<li><strong>治理攻擊（Governance Attack）</strong>：攻擊者通過閃電貸或短期借入大量治理代幣，提交並通過惡意提案，盜取國庫資金。防禦方式包括：投票前鎖倉要求、提案提交門檻、以及 Timelock 延遲。</li>
<li><strong>投票冷感（Voter Apathy）</strong>：大部分 token holder 不參與投票，導致少數人可以低票通過提案。解決方式包括：降低參與門檻（gasless voting via Snapshot）、delegation 機制、以及投票獎勵。</li>
<li><strong>提案品質低下</strong>：缺乏提案審查機制，導致大量低品質或有害提案浪費社群精力。建議設立提案門檻（如持有一定數量的治理代幣才能提案）並建立結構化的提案模板。</li>
</ul>
<h3 id="三種架構的比較"><a class="header" href="#三種架構的比較">三種架構的比較</a></h3>
<pre><code class="language-text">┌──────────────┬──────────────┬──────────────┬──────────────┐
│   維度       │  消費級 DApp │  機構級系統   │    DAO       │
├──────────────┼──────────────┼──────────────┼──────────────┤
│  首要目標    │  UX + 成本   │  安全 + 合規  │  共識 + 透明 │
│  決策速度    │  即時         │  小時~天      │  天~週       │
│  團隊規模    │  3-10 人     │  20-100 人    │  社群驅動    │
│  密鑰管理    │  用戶自持/AA │  MPC+HSM     │  Multisig    │
│  升級方式    │  Proxy       │  審批流程     │  提案投票    │
│  監管需求    │  低           │  高           │  中（演進中）│
│  風險模型    │  用戶自負     │  機構承擔     │  社群共擔    │
└──────────────┴──────────────┴──────────────┴──────────────┘
</code></pre>
<hr />
<h2 id="白話總結-12"><a class="header" href="#白話總結-12">白話總結</a></h2>
<p>這一章列出三種區塊鏈系統的典型架構藍圖，它們的工程重點完全不同，不可以混用。消費級 DApp 的核心是讓用戶用得順手、交易成本低，所以大部分跑在 L2，後端負責 gas 管理和交易重試，前端注重錢包連接體驗。機構級系統的核心是「不能出事」，所以層層審批、多簽加 MPC、冷熱錢包分離、每一筆交易都有完整稽核記錄，寧可慢也不能錯。DAO 治理架構的核心是讓社群共同決策，透過投票、提案、Timelock 等機制來確保透明度和公平性，但代價是決策速度慢且容易出現投票冷感。</p>
<p>選擇哪種架構取決於你的用戶是誰、你的團隊有多大、以及你面臨的監管環境。小團隊做消費端產品，用第一種就夠了；如果你管理的是機構資金或交易所資產，必須用第二種；如果你在建立一個社群驅動的協議，第三種是你的目標架構，但建議從 Multisig 開始、漸進去中心化。實務中，很多項目會混合使用這三種架構的元素，比如一個 DeFi 協議可能前端是消費級的架構，但國庫管理用機構級的安全標準，治理則用 DAO 模式。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-上線與稽核檢查清單"><a class="header" href="#14-上線與稽核檢查清單">14. 上線與稽核檢查清單</a></h1>
<p>上線前的檢查清單是防止事故的最後一道防線。區塊鏈系統與傳統軟體最大的不同在於：合約部署後難以修改、資金損失不可逆轉、且攻擊者 24/7 全球在線。每一個檢查項背後，都對應著真實發生過的安全事故或營運災難。</p>
<p>本章將檢查清單分為五個面向：合約上線前、錢包與多簽、跨鏈與橋接、監控與營運、法遵與治理。建議團隊在每次上線前，由至少兩個獨立的人分別走完整份清單，並將結果記錄在案。不要把這份清單當成形式主義的 checkbox，而是要理解每個項目背後的「為什麼」。</p>
<hr />
<h2 id="141-合約上線前"><a class="header" href="#141-合約上線前">14.1 合約上線前</a></h2>
<h3 id="----權限矩陣完成並審核"><a class="header" href="#----權限矩陣完成並審核">- [ ] 權限矩陣完成並審核</a></h3>
<p>權限矩陣（Access Control Matrix）定義了每個角色可以呼叫哪些合約函數。這是合約安全的基礎。常見的權限角色包括 Owner、Admin、Operator、Pauser 等，每個角色應有明確定義的職責範圍。</p>
<p>在 Solidity 中，推薦使用 OpenZeppelin 的 AccessControl 合約而非簡單的 Ownable 模式，因為 AccessControl 支持多角色、角色繼承、以及角色管理的去中心化。權限矩陣應以文件形式記錄，並由至少兩個獨立的審核者驗證。</p>
<pre><code class="language-text">權限矩陣範例：
┌──────────────┬──────────┬──────────┬──────────┬──────────┐
│  函數        │  Owner   │  Admin   │ Operator │  Public  │
├──────────────┼──────────┼──────────┼──────────┼──────────┤
│ upgradeTo()  │    V     │          │          │          │
│ pause()      │    V     │    V     │          │          │
│ setFee()     │    V     │    V     │          │          │
│ execute()    │    V     │    V     │    V     │          │
│ deposit()    │    V     │    V     │    V     │    V     │
└──────────────┴──────────┴──────────┴──────────┴──────────┘
</code></pre>
<p><strong>常見陷阱</strong>：很多團隊在開發階段為了方便，將所有權限集中在一個 EOA 上，上線時忘記轉移。上線前必須確認所有管理權限已轉移到 multisig 或 timelock 合約。</p>
<h3 id="----升級路徑與-rollback-設計明確"><a class="header" href="#----升級路徑與-rollback-設計明確">- [ ] 升級路徑與 rollback 設計明確</a></h3>
<p>如果使用 Proxy Pattern（如 UUPS 或 Transparent Proxy），必須明確定義升級流程：誰有權升級、升級前需要哪些審批、升級後如何驗證新合約行為正確、以及如果升級出問題如何 rollback。</p>
<p>升級流程建議包含以下步驟：(1) 在測試網完整測試新的 implementation；(2) 使用 mainnet fork 模擬升級過程；(3) 經過多簽或治理投票審批；(4) 升級後在鏈上驗證關鍵狀態變數未被破壞；(5) 保留舊 implementation 的合約地址，以備 rollback。</p>
<p><strong>關鍵注意事項</strong>：storage layout 的相容性是升級最容易出錯的地方。新版 implementation 不能改變已有 storage 變數的順序或類型，只能在末尾追加新變數。使用 OpenZeppelin 的 <code>@openzeppelin/upgrades</code> 工具可以自動檢測 storage 衝突。</p>
<h3 id="----fuzzinvariantmainnet-fork-測試通過"><a class="header" href="#----fuzzinvariantmainnet-fork-測試通過">- [ ] fuzz/invariant/mainnet-fork 測試通過</a></h3>
<p>單元測試只能覆蓋開發者想得到的場景，fuzz testing 和 invariant testing 能發現開發者沒想到的邊界情況。使用 Foundry 的 <code>forge test --fuzz-runs 10000</code> 可以對函數輸入進行大量隨機測試，而 invariant testing 則持續驗證合約的核心不變量（如 "總供應量永遠等於所有帳戶餘額之和"）。</p>
<p>Mainnet fork testing 是上線前的最後一道驗證。它使用真實的主網狀態（包括真實的代幣餘額、真實的 DEX 流動性池）來模擬交易，能發現只在主網環境才會出現的問題（如預言機價格異常、MEV 影響等）。</p>
<pre><code class="language-bash"># Foundry mainnet fork test 範例
forge test --fork-url $ETH_RPC_URL --fork-block-number 18000000
</code></pre>
<h3 id="----重大函數有事件紀錄"><a class="header" href="#----重大函數有事件紀錄">- [ ] 重大函數有事件紀錄</a></h3>
<p>所有改變合約狀態的重大函數（特別是涉及資金轉移、權限變更、參數調整的函數）都必須 emit event。Event 是鏈上的永久紀錄，也是監控系統和前端 indexer 的資料來源。</p>
<p>沒有 event 的狀態變更就像沒有 log 的伺服器操作，出了問題無法追溯。建議為每個 admin function 都定義對應的 event，並在 event 中包含足夠的上下文資訊（如 old value、new value、caller address）。</p>
<h3 id="----pause-與-emergency-流程演練"><a class="header" href="#----pause-與-emergency-流程演練">- [ ] Pause 與 emergency 流程演練</a></h3>
<p>Pause 機制（通常使用 OpenZeppelin 的 Pausable）允許在緊急情況下暫停合約的關鍵功能。但光有 pause 功能是不夠的，團隊必須實際演練整個緊急應對流程：誰有權觸發 pause？pause 的 multisig 門檻是多少？pause 後如何通知用戶？恢復正常的條件和流程是什麼？</p>
<p><strong>最佳實踐</strong>：設置一個 emergency multisig（例如 2-of-3），其門檻低於一般操作的 multisig（例如 3-of-5），確保緊急情況下能快速反應。同時，每季度做一次「消防演練」，模擬安全事件並計時完成整個應對流程。</p>
<hr />
<h2 id="142-錢包與多簽"><a class="header" href="#142-錢包與多簽">14.2 錢包與多簽</a></h2>
<h3 id="----signer-身分與設備獨立"><a class="header" href="#----signer-身分與設備獨立">- [ ] signer 身分與設備獨立</a></h3>
<p>每一個多簽的簽名者（signer）必須使用獨立的設備和獨立的私鑰。如果兩個 signer 使用同一台電腦、或者私鑰都存在同一個 cloud backup 中，那多簽的安全性就形同虛設。</p>
<p>建議每個 signer 使用獨立的硬體錢包（如 Ledger 或 Trezor），並將恢復種子短語（seed phrase）以物理形式保管在不同地點。對於關鍵的多簽（如國庫管理），signer 應分布在不同的地理位置，避免單一地點的物理安全事件影響所有 signer。</p>
<h3 id="----簽名前模擬與可視化解碼"><a class="header" href="#----簽名前模擬與可視化解碼">- [ ] 簽名前模擬與可視化解碼</a></h3>
<p>在任何 signer 點擊「確認簽名」之前，必須能看到這筆交易的完整解碼資訊：呼叫了哪個合約的哪個函數、參數是什麼、預期的效果是什麼。盲簽（blind signing）是導致資金損失的主要原因之一。</p>
<p>使用 Tenderly 或 Safe 的交易模擬功能，可以在簽名前預覽交易的完整執行結果，包括資金流向、狀態變更等。對於 multisig 交易，建議每個 signer 都獨立驗證模擬結果，而非只依賴第一個 signer 的確認。</p>
<h3 id="----高風險交易有-timelock"><a class="header" href="#----高風險交易有-timelock">- [ ] 高風險交易有 timelock</a></h3>
<p>任何涉及大額資金轉移、權限變更、或合約升級的交易，都應該通過 timelock 合約執行。Timelock 提供了一個時間窗口（通常 24-72 小時），讓社群或安全團隊有機會審查即將執行的操作，並在發現問題時取消。</p>
<p>Timelock 的設計要點：(1) 緊急操作可以有較短的 timelock（如 6 小時）但需要更高的多簽門檻；(2) 常規操作使用標準 timelock（如 48 小時）；(3) 重大變更（如合約升級）使用更長的 timelock（如 7 天）。</p>
<h3 id="----地址白名單與限額已啟用"><a class="header" href="#----地址白名單與限額已啟用">- [ ] 地址白名單與限額已啟用</a></h3>
<p>對於機構錢包和協議國庫，應限制資金只能轉移到預先批准的地址（whitelist）。同時設置單筆和累計限額（如單筆不超過 $100K，24 小時不超過 $500K），超出限額需要更高級別的審批。</p>
<p>白名單的管理本身也需要安全控制：新增白名單地址應經過多簽審批 + timelock，避免攻擊者在控制單一 signer 後立即新增惡意地址並轉出資金。</p>
<h3 id="----signer-輪替與遺失應對已演練"><a class="header" href="#----signer-輪替與遺失應對已演練">- [ ] signer 輪替與遺失應對已演練</a></h3>
<p>隨著團隊成員變動，多簽的 signer 需要定期輪替。必須有明確的流程來：(1) 安全地移除離職成員的 signer 權限；(2) 新增新成員為 signer；(3) 應對 signer 硬體錢包遺失或損壞的情況。</p>
<p>建議每半年做一次 signer 輪替演練，確保流程順暢。同時，應在安全的離線環境中保存多簽錢包的完整配置資訊（包括合約地址、所有 signer 地址、門檻設定），以便在極端情況下重建。</p>
<hr />
<h2 id="143-跨鏈與橋接"><a class="header" href="#143-跨鏈與橋接">14.3 跨鏈與橋接</a></h2>
<h3 id="----最終性門檻按鏈別設置"><a class="header" href="#----最終性門檻按鏈別設置">- [ ] 最終性門檻按鏈別設置</a></h3>
<p>不同的區塊鏈有不同的最終性保證。Ethereum 在 2 個 epoch（約 12.8 分鐘）後達到最終性；Bitcoin 傳統上需要 6 個確認（約 60 分鐘）；而某些 L2 的最終性取決於 L1 的 settlement。跨鏈系統必須根據每條鏈的特性設置適當的確認數門檻。</p>
<p>設置過低的確認數會讓系統暴露在 reorg 攻擊的風險中（攻擊者在來源鏈重組區塊，但目標鏈已釋放資金）。設置過高則影響用戶體驗。建議根據交易金額動態調整：小額交易可以接受較低的確認數，大額交易則需要等待完整最終性。</p>
<pre><code class="language-text">建議確認數門檻：
┌──────────────┬──────────┬──────────┬──────────┐
│  鏈          │ 小額     │ 中額     │ 大額     │
├──────────────┼──────────┼──────────┼──────────┤
│ Ethereum     │ 12 blocks│ 32 blocks│ 2 epochs │
│ Bitcoin      │ 2 conf   │ 4 conf   │ 6 conf   │
│ Polygon PoS  │ 128 blks │ 256 blks │ 512 blks │
│ Arbitrum     │ L1 final │ L1 final │ L1 final │
└──────────────┴──────────┴──────────┴──────────┘
</code></pre>
<h3 id="----單筆單日跨鏈限額"><a class="header" href="#----單筆單日跨鏈限額">- [ ] 單筆/單日跨鏈限額</a></h3>
<p>跨鏈橋是區塊鏈歷史上損失最慘重的攻擊面。Ronin Bridge（$625M）、Wormhole（$320M）、Nomad（$190M）等事件都說明，橋接合約的資金池是攻擊者的首要目標。設置合理的限額是降低最大損失的關鍵措施。</p>
<p>限額應包括：(1) 單筆交易上限；(2) 單一地址 24 小時累計上限；(3) 全系統 24 小時累計上限。當接近限額時自動觸發告警，超過限額時自動暫停跨鏈功能。限額的具體數值應根據橋接資金池的總量來設定，建議單日限額不超過資金池的 10-20%。</p>
<h3 id="----bridge-依賴風險評級"><a class="header" href="#----bridge-依賴風險評級">- [ ] bridge 依賴風險評級</a></h3>
<p>如果你的系統依賴第三方跨鏈橋，必須對每個依賴的橋進行風險評級。評級維度包括：(1) 安全模型（信任假設是什麼？需要信任幾個 validator？）；(2) 歷史紀錄（是否曾被攻擊？恢復速度如何？）；(3) 代碼審計（是否經過多家知名審計公司審計？）；(4) TVL 與保險（資金池有多大？是否有保險覆蓋？）。</p>
<p><strong>最佳實踐</strong>：不要只依賴單一跨鏈橋。為關鍵路徑準備至少一個備選橋，並建立自動切換機制。同時，密切關注所依賴橋的安全公告和社群討論。</p>
<h3 id="----異常事件可自動降級或停用"><a class="header" href="#----異常事件可自動降級或停用">- [ ] 異常事件可自動降級或停用</a></h3>
<p>跨鏈系統需要有自動化的異常偵測和降級機制。例如：當偵測到來源鏈的 reorg 深度異常增大時，自動提高確認數門檻；當短時間內出現異常大量的跨鏈請求時，自動啟動限流；當橋接合約的餘額出現非預期的變動時，自動暫停跨鏈功能。</p>
<p>這些自動化機制需要與監控告警系統整合，在觸發降級的同時通知 on-call 工程師。降級後的恢復必須經過人工確認，不能自動恢復，以避免攻擊者利用恢復機制。</p>
<hr />
<h2 id="144-監控與營運"><a class="header" href="#144-監控與營運">14.4 監控與營運</a></h2>
<h3 id="----交易狀態全鏈路追蹤"><a class="header" href="#----交易狀態全鏈路追蹤">- [ ] 交易狀態全鏈路追蹤</a></h3>
<p>從用戶發起交易到鏈上確認，整個鏈路的每一步都需要可追蹤。這包括：交易接收（timestamp、來源 IP）、交易構造（參數、gas 估算）、交易提交（txHash、nonce）、交易確認（block number、status）、以及後處理（事件解析、帳本更新）。</p>
<p>建議為每筆交易分配一個內部 trace ID，在所有相關的 log 中包含這個 ID，以便在出問題時能快速串連完整鏈路。可以使用 OpenTelemetry 等分散式追蹤框架來實現。</p>
<pre><code class="language-text">交易追蹤鏈路：
Request → API → TxService → Simulation → Sign → Broadcast → Mempool → Confirm → Index → Notify
   │        │        │          │         │        │          │         │        │       │
   └────────┴────────┴──────────┴─────────┴────────┴──────────┴─────────┴────────┴───────┘
                               trace_id: 全鏈路貫穿
</code></pre>
<h3 id="----p0p1p2-告警規則生效"><a class="header" href="#----p0p1p2-告警規則生效">- [ ] P0/P1/P2 告警規則生效</a></h3>
<p>告警必須分級，避免所有告警都以最高優先級發送導致 alert fatigue。建議分為三級：</p>
<ul>
<li><strong>P0（立即回應，5 分鐘內）</strong>：合約被暫停、異常大額轉帳、私鑰可能洩漏、橋接合約餘額異常減少。P0 告警應同時通過電話、簡訊、Slack 通知 on-call 工程師。</li>
<li><strong>P1（盡快處理，1 小時內）</strong>：交易持續失敗、gas price 異常飆升、RPC 節點故障、monitoring 系統本身故障。P1 告警通過 Slack 和 PagerDuty 通知。</li>
<li><strong>P2（工作時間處理）</strong>：非關鍵交易延遲、日誌空間不足、backup 失敗。P2 告警通過 Slack channel 通知。</li>
</ul>
<p>每條告警規則都需要定期測試（建議每月一次），確保告警通道暢通且告警條件正確。</p>
<h3 id="----siem-留存完整審計資料"><a class="header" href="#----siem-留存完整審計資料">- [ ] SIEM 留存完整審計資料</a></h3>
<p>所有安全相關的事件（登入、權限變更、交易審批、配置修改）都必須送入 SIEM（Security Information and Event Management）系統，並至少保留 1 年。這不僅是合規要求，也是事故調查的必要資料。</p>
<p>SIEM 資料的完整性需要保護：使用 append-only 的儲存方式，確保日誌不能被竄改或刪除。對於敏感操作（如 admin 函數呼叫），建議同時在鏈上和鏈下都留存紀錄。</p>
<h3 id="----runbook-與-on-call-排班落地"><a class="header" href="#----runbook-與-on-call-排班落地">- [ ] Runbook 與 on-call 排班落地</a></h3>
<p>每一個 P0/P1 告警都必須有對應的 Runbook（操作手冊），詳細描述：(1) 如何確認問題；(2) 如何定位根因；(3) 如何執行修復或降級；(4) 修復後如何驗證。Runbook 應以可執行的步驟形式撰寫，而非抽象的指引。</p>
<p>On-call 排班應確保 7x24 覆蓋，每個時段至少有一個具備完整系統知識的工程師值班。on-call 工程師必須有足夠的權限來執行 Runbook 中的操作（包括 pause 合約、切換 RPC、重啟服務等），不需要等待其他人的授權。</p>
<hr />
<h2 id="145-法遵與治理"><a class="header" href="#145-法遵與治理">14.5 法遵與治理</a></h2>
<h3 id="----管理權限公開披露"><a class="header" href="#----管理權限公開披露">- [ ] 管理權限公開披露</a></h3>
<p>對於公開的協議，所有管理權限（admin keys、owner address、multisig 配置）都應公開披露。用戶有權知道誰有能力修改合約參數、暫停合約、或升級合約。隱藏管理權限是信任的紅旗。</p>
<p>披露的內容應包括：每個管理角色的地址、多簽的門檻和簽名者清單、timelock 的延遲時間、以及每個角色可以執行的操作範圍。建議在項目的官方文檔和合約的 NatSpec 中都記載這些資訊。</p>
<h3 id="----重大變更公告期與投票期"><a class="header" href="#----重大變更公告期與投票期">- [ ] 重大變更公告期與投票期</a></h3>
<p>任何影響用戶資金安全或使用體驗的變更（如費率調整、參數修改、合約升級），都應有足夠的公告期。對於 DAO 治理的協議，公告期通常由 timelock 保證；對於中心化管理的協議，建議至少提前 72 小時公告。</p>
<p>公告應透過多個管道發布（官方網站、社群媒體、Discord/Telegram、郵件通知），確保不同類型的用戶都能接收到。對於可能造成用戶損失的變更（如清算參數調整），應提供具體的影響評估和用戶應對建議。</p>
<h3 id="----災難處置與補償政策明確"><a class="header" href="#----災難處置與補償政策明確">- [ ] 災難處置與補償政策明確</a></h3>
<p>在事故發生前就應制定清晰的災難處置和補償政策。包括：(1) 什麼情況會觸發緊急處置？(2) 處置流程是什麼？(3) 用戶損失如何計算？(4) 補償的資金來源是什麼（保險、國庫、團隊儲備）？(5) 補償的時間表和方式是什麼？</p>
<p>沒有預先制定的補償政策，事故發生後的臨時決策往往會引發更大的信任危機。參考 2023 年 Euler Finance 被駭後的處理方式：他們在 24 小時內公布了完整的事故報告和補償方案，最終透過與攻擊者談判成功追回大部分資金。</p>
<hr />
<h2 id="146-上線前最終-gono-go-檢查"><a class="header" href="#146-上線前最終-gono-go-檢查">14.6 上線前最終 Go/No-Go 檢查</a></h2>
<p>在完成以上所有單項檢查後，建議進行一次正式的 Go/No-Go 會議，參與者應包括：工程負責人、安全負責人、營運負責人。會議中逐項確認以下事項：</p>
<pre><code class="language-text">Go/No-Go 決策清單：
┌────────────────────────────────────────────────────┐
│ 1. 所有審計發現已修復或有明確的風險接受決策       │
│ 2. 監控與告警系統已上線且經過驗證                 │
│ 3. On-call 排班已確認且值班人員已完成 Runbook 演練│
│ 4. Pause/Emergency 流程已演練且計時結果可接受     │
│ 5. 部署腳本已在 staging 環境驗證                  │
│ 6. 上線後的 smoke test 清單已準備                 │
│ 7. rollback 計畫已制定（含合約和前端）            │
│ 8. 溝通計畫已準備（公告、社群通知、客服準備）    │
└────────────────────────────────────────────────────┘
</code></pre>
<hr />
<h2 id="白話總結-13"><a class="header" href="#白話總結-13">白話總結</a></h2>
<p>上線前的 checklist 不是形式主義，每一個核對項都對應一種真實發生過的安全事故或營運災難。合約上線前要確保權限設計正確、升級路徑清晰、測試涵蓋充分（包括 fuzz 和 mainnet fork），並且實際演練過緊急暫停流程。錢包和多簽的安全關鍵在於：每個 signer 獨立、簽名前能看懂交易內容、高風險操作有時間鎖、以及定期演練 signer 輪替和遺失應對。跨鏈橋是歷史上損失最大的攻擊面，必須設置合理的確認數門檻和限額，並對依賴的第三方橋進行風險評級。</p>
<p>監控與營運方面，核心是全鏈路追蹤和分級告警，確保出問題時能快速發現、快速定位、快速修復。法遵方面，管理權限要公開透明、重大變更要有公告期、災難補償政策要事先制定。記住：你在安靜時期建立的流程和演練的肌肉記憶，決定了你在危機時刻能否有效反應。把這份清單當成飛行員起飛前的 preflight checklist 來對待，每次上線都認真走一遍，不要因為「上次沒出事」就跳過任何項目。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-術語與快速索引"><a class="header" href="#15-術語與快速索引">15. 術語與快速索引</a></h1>
<p>本章收錄區塊鏈系統工程中最常見的術語，每個術語附帶簡要解釋和工程上的重要提醒。遇到不熟悉的詞彙時，先在這裡查找定義，再回到對應的主章節看完整上下文。術語按照類別分組，方便快速定位。</p>
<hr />
<h2 id="核心帳戶與交易模型"><a class="header" href="#核心帳戶與交易模型">核心帳戶與交易模型</a></h2>
<ul>
<li>
<p><strong>EOA (Externally Owned Account)</strong>：外部私鑰帳戶，由一對公私鑰控制的基本帳戶類型。EOA 是 Ethereum 上最原始的帳戶形式，用戶直接持有私鑰來簽名和發起交易。EOA 的缺點是沒有內建的多簽、社交恢復或 gas 代付等功能。</p>
</li>
<li>
<p><strong>UTXO (Unspent Transaction Output)</strong>：未花費輸出模型，Bitcoin 等鏈使用的交易模型。每筆交易消耗舊的 UTXO 並產生新的 UTXO，餘額是所有屬於你的 UTXO 的加總。這種模型天然支持並行驗證和資金流向追蹤。</p>
</li>
<li>
<p><strong>EUTXO (Extended UTXO)</strong>：帶資料與腳本條件的 UTXO 擴展模型，由 Cardano 首創。在每個 UTXO 上附加 Datum（資料）和 Validator Script（驗證邏輯），使 UTXO 能承載更複雜的合約狀態，但開發難度顯著高於 Account 模型。</p>
</li>
<li>
<p><strong>AA (Account Abstraction)</strong>：可程式化帳戶，透過 ERC-4337 標準在 Ethereum 上實現。允許用智能合約作為帳戶，支援 gas 代付、批量交易、session key、社交恢復等進階功能，大幅改善使用者體驗。</p>
</li>
<li>
<p><strong>Nonce</strong>：交易序號，用於確保同一帳戶發出的交易按順序執行且不被重播。在 Account 模型中，nonce 是 per-account 的遞增序號；在高並發場景下，nonce 管理是工程上的主要挑戰之一。</p>
</li>
<li>
<p><strong>Gas / Gas Price / Gas Limit</strong>：Gas 是 EVM 計算量的單位，Gas Price 是每單位 Gas 的費用，Gas Limit 是交易願意支付的最大 Gas 量。EIP-1559 引入了 base fee + priority fee 的雙層結構，使 gas 價格預測更可靠。</p>
</li>
</ul>
<hr />
<h2 id="密鑰與安全"><a class="header" href="#密鑰與安全">密鑰與安全</a></h2>
<ul>
<li>
<p><strong>MPC (Multi-Party Computation)</strong>：多方計算簽名，將私鑰分割成多個 shard，分散到不同的計算節點。簽名時各節點協同計算，產生一個標準簽名，但任何單一節點都不擁有完整私鑰。機構級錢包（如 Fireblocks）的核心技術。</p>
</li>
<li>
<p><strong>Multisig</strong>：M-of-N 門檻多簽，需要 N 個簽名者中的 M 個共同簽名才能執行交易。在 Ethereum 上通常用智能合約實現（如 Gnosis Safe），在 Bitcoin 上可以用 Script 或 Taproot 實現。多簽是 DAO 國庫和機構錢包的標準安全措施。</p>
</li>
<li>
<p><strong>HSM (Hardware Security Module)</strong>：硬體安全模組，通過 FIPS 140-2/3 認證的專用硬體設備，用於安全地生成、儲存和使用密鑰。HSM 確保私鑰永遠不會以明文形式離開硬體，即使伺服器被入侵也無法提取密鑰。</p>
</li>
<li>
<p><strong>TSS (Threshold Signature Scheme)</strong>：門檻簽名方案，MPC 的一種具體實現。與鏈上 multisig 不同，TSS 在鏈下完成多方協同簽名，鏈上只看到一個普通簽名，節省 gas 且保護隱私。</p>
</li>
<li>
<p><strong>Seed Phrase / Mnemonic</strong>：助記詞，由 12 或 24 個英文單詞組成的私鑰備份方式（BIP-39 標準）。從助記詞可以確定性地推導出完整的密鑰樹。助記詞的安全保管是個人資產安全的基礎。</p>
</li>
<li>
<p><strong>Social Recovery</strong>：社交恢復機制，用戶預設一組信任的 guardians，當私鑰遺失時，guardians 可以共同授權恢復帳戶控制權。AA 錢包（如 Argent）的常見功能。</p>
</li>
</ul>
<hr />
<h2 id="共識與最終性"><a class="header" href="#共識與最終性">共識與最終性</a></h2>
<ul>
<li>
<p><strong>Finality</strong>：最終性，指交易被確認後不可逆轉的保證程度。不同鏈的最終性機制差異很大：Bitcoin 是概率性最終性（隨確認數增加，被推翻的概率指數下降）；Ethereum PoS 有 2 epoch 的確定性最終性；Tendermint-based 鏈通常有即時最終性。</p>
</li>
<li>
<p><strong>Reorg (Chain Reorganization)</strong>：區塊重組，當網路中出現更長/更重的替代鏈時，節點會切換到新鏈，導致已確認的交易被撤銷。Reorg 是跨鏈橋和交易確認系統必須處理的核心風險。</p>
</li>
<li>
<p><strong>Sequencer</strong>：L2 排序器，負責收集使用者交易、排序、執行、並將結果批次提交到 L1。目前大多數 L2（Arbitrum、Optimism、Base）使用中心化的 sequencer，這是一個信任假設和單點故障風險。去中心化 sequencer 是 L2 發展的重要方向。</p>
</li>
<li>
<p><strong>Validator</strong>：驗證者，在 PoS 共識中負責提議和驗證新區塊的節點。Validator 需要質押代幣作為保證金，違規行為會被 slashing（沒收質押）。</p>
</li>
<li>
<p><strong>Slashing</strong>：懲罰機制，當 validator 出現雙重簽名、長時間離線等違規行為時，系統會沒收其部分或全部質押代幣。Slashing 是 PoS 系統維護安全性的經濟激勵機制。</p>
</li>
<li>
<p><strong>Fork (Hard Fork / Soft Fork)</strong>：分叉，區塊鏈協議升級的方式。Hard fork 是不向後相容的升級（舊節點不認新規則），可能導致鏈分裂（如 ETH/ETC）；Soft fork 是向後相容的升級（舊節點仍可驗證新區塊）。</p>
</li>
</ul>
<hr />
<h2 id="layer-2-與擴容"><a class="header" href="#layer-2-與擴容">Layer 2 與擴容</a></h2>
<ul>
<li>
<p><strong>DA (Data Availability)</strong>：資料可用性，確保任何人都能取得驗證交易所需的完整資料。L2 將交易資料發布到 L1（或專用 DA 層如 Celestia、EigenDA），確保即使 sequencer 離線，用戶仍可從 DA 資料重建狀態並提領資金。</p>
</li>
<li>
<p><strong>Rollup (Optimistic / ZK)</strong>：L2 擴容方案的主流架構。Optimistic Rollup 先假設交易正確，挑戰期內可提出 fraud proof；ZK Rollup 用零知識證明數學上保證交易正確。Optimistic 開發門檻較低但提領時間較長（7 天），ZK 安全性更強但計算成本較高。</p>
</li>
<li>
<p><strong>Fraud Proof</strong>：欺詐證明，Optimistic Rollup 的安全機制。如果 sequencer 提交了錯誤的狀態，任何人都可以在挑戰期內提交 fraud proof 來推翻錯誤並獲得獎勵。</p>
</li>
<li>
<p><strong>Validity Proof (ZK Proof)</strong>：有效性證明，ZK Rollup 的安全機制。每批交易都附帶一個數學證明，驗證所有交易的執行結果是正確的。L1 合約只需驗證這個簡短的證明，而不需重新執行所有交易。</p>
</li>
<li>
<p><strong>Blob (EIP-4844)</strong>：Binary Large Object，Ethereum Dencun 升級引入的新交易類型，專門用於 L2 發布 DA 資料。Blob 資料的存儲成本遠低於 calldata，大幅降低了 L2 的運營成本。</p>
</li>
</ul>
<hr />
<h2 id="defi-與經濟模型"><a class="header" href="#defi-與經濟模型">DeFi 與經濟模型</a></h2>
<ul>
<li>
<p><strong>MEV (Maximal Extractable Value)</strong>：可提取價值，指區塊生產者或 sequencer 可以通過重排、插入或排除交易來獲取的額外利潤。常見的 MEV 形式包括三明治攻擊（sandwich attack）、套利（arbitrage）和清算搶跑（liquidation frontrunning）。MEV 是 DeFi 用戶面臨的隱性成本。</p>
</li>
<li>
<p><strong>TVL (Total Value Locked)</strong>：總鎖倉價值，衡量一個 DeFi 協議或區塊鏈生態中鎖定的資產總值。TVL 是評估協議規模和市場信心的常用指標，但也可能被操縱（如通過循環借貸虛增）。</p>
</li>
<li>
<p><strong>Oracle</strong>：預言機，將鏈外資料（如價格、天氣、體育結果）安全地餵入鏈上合約。Chainlink 是最主流的去中心化預言機網路。預言機的可靠性直接影響依賴它的所有合約的安全性。</p>
</li>
<li>
<p><strong>Liquidation</strong>：清算，當借貸協議中借款人的抵押品價值降到清算門檻以下時，系統允許清算人買走抵押品來償還債務。清算機制的正確性是借貸協議的安全基礎。</p>
</li>
<li>
<p><strong>Flash Loan</strong>：閃電貸，在一個交易內完成借款和還款，無需抵押品。閃電貸本身是中性工具，但常被用於治理攻擊和價格操縱。</p>
</li>
<li>
<p><strong>AMM (Automated Market Maker)</strong>：自動做市商，使用數學公式（如 x*y=k）而非訂單簿來提供流動性和定價。Uniswap、Curve 是最知名的 AMM 協議。</p>
</li>
<li>
<p><strong>Impermanent Loss</strong>：無常損失，AMM 流動性提供者在代幣價格變動時相對於單純持有代幣的損失。價格偏離越大，無常損失越大。</p>
</li>
</ul>
<hr />
<h2 id="合約開發"><a class="header" href="#合約開發">合約開發</a></h2>
<ul>
<li>
<p><strong>Proxy Pattern</strong>：代理模式，透過將合約邏輯和存儲分離，實現合約的可升級性。主流模式包括 Transparent Proxy（OpenZeppelin）和 UUPS。使用 proxy 時必須特別注意 storage layout 的相容性。</p>
</li>
<li>
<p><strong>Reentrancy</strong>：重入攻擊，合約在外部呼叫完成前被再次呼叫，導致狀態不一致。2016 年 The DAO 事件（損失 $60M）就是重入攻擊。防禦方式包括 checks-effects-interactions 模式和 OpenZeppelin 的 ReentrancyGuard。</p>
</li>
<li>
<p><strong>Timelock</strong>：時間鎖合約，執行敏感操作前強制等待一段時間。Timelock 給予社群審查即將執行的變更的機會，是 DAO 治理和合約升級的標準安全措施。</p>
</li>
<li>
<p><strong>ERC-20 / ERC-721 / ERC-1155</strong>：Ethereum 代幣標準。ERC-20 是同質化代幣（如 USDC、LINK），ERC-721 是非同質化代幣（NFT），ERC-1155 是多代幣標準（一個合約可同時管理多種同質化和非同質化代幣）。</p>
</li>
<li>
<p><strong>ABI (Application Binary Interface)</strong>：應用二進制介面，定義了如何與合約函數交互的編碼規範。前端和後端透過 ABI 來構造和解碼合約呼叫。</p>
</li>
<li>
<p><strong>NatSpec</strong>：Natural Language Specification，Solidity 的文檔註解標準。用 <code>@notice</code>、<code>@param</code>、<code>@return</code> 等標籤為合約函數撰寫人類可讀的說明。</p>
</li>
</ul>
<hr />
<h2 id="監控與營運"><a class="header" href="#監控與營運">監控與營運</a></h2>
<ul>
<li>
<p><strong>SIEM (Security Information and Event Management)</strong>：安全資訊與事件管理系統，集中收集、分析和留存安全事件日誌。在區塊鏈系統中，SIEM 應同時涵蓋鏈上事件（合約 event）和鏈下事件（API 存取、配置變更）。</p>
</li>
<li>
<p><strong>RPC (Remote Procedure Call)</strong>：遠程過程呼叫，與區塊鏈節點交互的標準介面。常用的 RPC provider 包括 Alchemy、Infura、QuickNode。生產環境應使用多個 RPC provider 做 load balancing 和 failover。</p>
</li>
<li>
<p><strong>Subgraph / Indexer</strong>：鏈上資料索引服務，將合約 event 和交易資料轉換為可查詢的結構化資料庫。The Graph 是最常用的去中心化索引協議，Ponder 和 Envio 是較新的替代方案。</p>
</li>
<li>
<p><strong>Runbook</strong>：操作手冊，記錄常見問題和緊急事件的標準操作流程。每個 P0/P1 告警都應有對應的 Runbook，描述確認問題、定位根因、執行修復的具體步驟。</p>
</li>
</ul>
<hr />
<h2 id="跨鏈與橋接"><a class="header" href="#跨鏈與橋接">跨鏈與橋接</a></h2>
<ul>
<li>
<p><strong>Bridge</strong>：跨鏈橋，在不同區塊鏈之間轉移資產和訊息的基礎設施。常見的安全模型包括：信任 committee（如 Wormhole guardians）、optimistic（如 Across）、ZK 證明（如 zkBridge）。跨鏈橋是歷史上損失最大的攻擊面。</p>
</li>
<li>
<p><strong>Wrapped Token</strong>：包裝代幣，將一條鏈上的原生資產在另一條鏈上以 1:1 的 ERC-20 代幣形式表示。例如 WBTC（Wrapped Bitcoin on Ethereum）。Wrapped token 的安全性取決於背後的託管/橋接機制。</p>
</li>
<li>
<p><strong>Canonical Bridge vs Third-Party Bridge</strong>：官方橋與第三方橋。L2 通常有官方橋（安全性繼承 L1，但速度慢），第三方橋（如 Stargate、Across）提供更快的體驗但引入額外信任假設。</p>
</li>
</ul>
<hr />
<h2 id="合規與監管"><a class="header" href="#合規與監管">合規與監管</a></h2>
<ul>
<li>
<p><strong>AML (Anti-Money Laundering)</strong>：反洗錢，要求金融機構識別和報告可疑交易的法規框架。在加密貨幣領域，AML 合規通常透過鏈上分析工具（如 Chainalysis、Elliptic）來實現。</p>
</li>
<li>
<p><strong>KYT (Know Your Transaction)</strong>：認識你的交易，透過分析鏈上交易歷史和資金來源來評估交易風險。KYT 是 AML 合規的具體技術實現。</p>
</li>
<li>
<p><strong>Proof of Reserves (PoR)</strong>：儲備證明，交易所或託管機構公開證明其持有的鏈上資產足以覆蓋用戶存款。通常透過 Merkle tree 或 ZK proof 實現，FTX 事件後成為業界標準要求。</p>
</li>
<li>
<p><strong>Travel Rule</strong>：旅行規則，要求虛擬資產服務提供商（VASP）在超過一定金額的交易中，傳遞發送方和接收方的身份資訊。來自 FATF 的建議，各國正逐步立法實施。</p>
</li>
</ul>
<hr />
<h2 id="快速定位"><a class="header" href="#快速定位">快速定位</a></h2>
<div class="table-wrapper"><table><thead><tr><th>想了解的主題</th><th>參考章節</th></tr></thead><tbody>
<tr><td>交易流程與生命週期</td><td>第 6 章</td></tr>
<tr><td>合約執行與 EVM 機制</td><td>第 7 章</td></tr>
<tr><td>跨鏈風險與橋接安全</td><td>第 8 章</td></tr>
<tr><td>多簽完整設計與實作</td><td>第 10 章</td></tr>
<tr><td>安全事故與防禦策略</td><td>第 11 章</td></tr>
<tr><td>參考架構藍圖</td><td>第 13 章</td></tr>
<tr><td>上線前總檢查清單</td><td>第 14 章</td></tr>
<tr><td>UTXO 模型深入解析</td><td>第 16 章</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="白話總結-14"><a class="header" href="#白話總結-14">白話總結</a></h2>
<p>這一章是整本手冊的字典和索引。區塊鏈工程涉及大量的專業術語，有些源自密碼學（如 MPC、TSS），有些源自分散式系統（如 Finality、Reorg），有些源自金融（如 AML、Liquidation），有些則是區塊鏈特有的概念（如 MEV、Gas）。初學者在閱讀其他章節時，遇到不認識的詞彙可以先回來這裡查找定義和簡要說明，了解基本概念後再回到主章節看完整的技術脈絡。</p>
<p>術語列表也按照類別分組（帳戶模型、密鑰安全、共識機制、L2 擴容、DeFi、合約開發、監控營運、跨鏈橋接、合規監管），方便你在研究某個特定領域時快速找到所有相關術語。「快速定位」表格則告訴你每個主題在手冊中的對應章節，當你需要深入了解某個概念時，可以直接跳轉到對應的章節閱讀。建議在開始閱讀整本手冊之前，先快速瀏覽一遍這份術語表，對整體知識地圖有個概念，後續閱讀會更順暢。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16-utxo--eutxo-全面深潛"><a class="header" href="#16-utxo--eutxo-全面深潛">16. UTXO / EUTXO 全面深潛</a></h1>
<p>本章深入探討 UTXO（Unspent Transaction Output）模型的工程實務，包括交易結構、常見鏈的比較、EUTXO 擴展、與 Account 模型的工程差異、以及實際開發中常遇到的問題和解決方案。UTXO 模型是 Bitcoin 和許多區塊鏈的基礎，理解它的運作方式和工程限制，對於設計安全的資產管理系統至關重要。</p>
<hr />
<h2 id="161-utxo-是什麼"><a class="header" href="#161-utxo-是什麼">16.1 UTXO 是什麼</a></h2>
<p>UTXO（Unspent Transaction Output）是「尚未被花費的輸出」。
交易不是改餘額，而是「消耗舊輸出 + 產生新輸出」。</p>
<p>要理解 UTXO，最直覺的方式是把它想成實體現金。你的「餘額」不是銀行帳戶裡的一個數字，而是你皮夾裡所有紙鈔面額的加總。當你要付款時，你拿出幾張紙鈔，商家找零給你新的紙鈔。UTXO 就是這些「紙鈔」，每一張都有明確的面額和來源。</p>
<p>在 Account 模型（如 Ethereum）中，轉帳是修改兩個帳戶的餘額數字：A 的餘額減少、B 的餘額增加。但在 UTXO 模型中，沒有「帳戶餘額」這個概念。所謂的「餘額」是透過掃描整個 UTXO 集合，找出所有鎖定在你的地址上的 UTXO，將它們的金額加總得出的。</p>
<p>UTXO 模型的核心不變量是：<strong>每筆交易的輸入金額總和必須大於或等於輸出金額總和，差額就是礦工手續費</strong>。這個簡單的守恆定律是 Bitcoin 安全性的數學基礎之一。</p>
<pre><code class="language-text">UTXO 的生命週期：

  Coinbase Tx         Normal Tx           Normal Tx
  (挖礦產生)          (花費 + 找零)        (被花費)
      │                   │                   │
      v                   v                   v
  ┌────────┐         ┌────────┐         ┌────────┐
  │ UTXO A │──花費──&gt;│ UTXO B │──花費──&gt;│ UTXO D │──花費──&gt; ...
  │ 50 BTC │         │ 30 BTC │         │ 10 BTC │
  └────────┘         └────────┘         └────────┘
                     │ UTXO C │
                     │ 19.99  │ (找零)
                     └────────┘
                     fee=0.01 BTC
</code></pre>
<hr />
<h2 id="162-utxo-交易結構"><a class="header" href="#162-utxo-交易結構">16.2 UTXO 交易結構</a></h2>
<pre><code class="language-text">┌─────────────────────────────────────────────────────────┐
│                    Transaction                           │
├─────────────────────────────────────────────────────────┤
│  Version: 2                                              │
│  Locktime: 0 (or specific block height/timestamp)       │
│                                                          │
│  Inputs (引用舊 UTXO):                                  │
│  ┌───────────────────────────────────────────────┐      │
│  │ Input 0:                                       │      │
│  │   prev_txid: 0xabcd...1234                     │      │
│  │   output_index: 0                              │      │
│  │   scriptSig/witness: &lt;signature&gt; &lt;pubkey&gt;      │      │
│  │   sequence: 0xfffffffe                         │      │
│  ├───────────────────────────────────────────────┤      │
│  │ Input 1:                                       │      │
│  │   prev_txid: 0xef01...5678                     │      │
│  │   output_index: 2                              │      │
│  │   scriptSig/witness: &lt;signature&gt; &lt;pubkey&gt;      │      │
│  │   sequence: 0xfffffffe                         │      │
│  └───────────────────────────────────────────────┘      │
│                                                          │
│  Validation:                                             │
│  ┌───────────────────────────────────────────────┐      │
│  │ 1. 簽名驗證 (scriptSig matches scriptPubKey)  │      │
│  │ 2. 腳本條件 (timelock, multisig, etc.)        │      │
│  │ 3. 金額守恆 (sum(inputs) &gt;= sum(outputs))     │      │
│  │ 4. 雙花檢查 (UTXO 未被花費)                   │      │
│  └───────────────────────────────────────────────┘      │
│                                                          │
│  Outputs (新 UTXO 集合):                                │
│  ┌───────────────────────────────────────────────┐      │
│  │ Output 0 (recipient):                          │      │
│  │   value: 1.5 BTC                              │      │
│  │   scriptPubKey: OP_0 &lt;20-byte-hash&gt;           │      │
│  ├───────────────────────────────────────────────┤      │
│  │ Output 1 (change):                             │      │
│  │   value: 0.4999 BTC                           │      │
│  │   scriptPubKey: OP_0 &lt;20-byte-hash&gt;           │      │
│  └───────────────────────────────────────────────┘      │
│                                                          │
│  fee = sum(inputs) - sum(outputs) = 0.0001 BTC          │
└─────────────────────────────────────────────────────────┘
</code></pre>
<h3 id="交易結構詳解"><a class="header" href="#交易結構詳解">交易結構詳解</a></h3>
<p>每筆 UTXO 交易由四個核心部分組成：version（版本號）、inputs（輸入）、outputs（輸出）、locktime（鎖定時間）。</p>
<p><strong>Inputs</strong> 引用之前交易產生的 UTXO，透過 <code>prev_txid</code>（前序交易 ID）和 <code>output_index</code>（輸出索引）來精確指向一個特定的 UTXO。每個 input 還包含一個 <code>scriptSig</code>（或 SegWit 的 witness 資料），用來「解鎖」被引用的 UTXO。解鎖的方式取決於 UTXO 的鎖定腳本：最簡單的是提供一個有效的數位簽名和對應的公鑰。</p>
<p><strong>Outputs</strong> 定義新的 UTXO。每個 output 包含一個金額（<code>value</code>）和一個鎖定腳本（<code>scriptPubKey</code>），規定了什麼條件下這個 UTXO 可以被花費。常見的鎖定腳本類型包括 P2PKH（Pay to Public Key Hash）、P2WPKH（Pay to Witness Public Key Hash，SegWit）、P2TR（Pay to Taproot）。</p>
<p><strong>Fee</strong> 不是一個顯式欄位，而是 inputs 總金額減去 outputs 總金額的差值。這個差值被視為礦工費，激勵礦工將交易打包入區塊。</p>
<h3 id="交易驗證的-pseudocode"><a class="header" href="#交易驗證的-pseudocode">交易驗證的 pseudocode</a></h3>
<pre><code class="language-python">def validate_transaction(tx, utxo_set):
    total_input = 0
    total_output = 0

    # 驗證每個 input
    for inp in tx.inputs:
        # 1. 查找被引用的 UTXO
        utxo = utxo_set.get(inp.prev_txid, inp.output_index)
        if utxo is None:
            return False  # UTXO 不存在或已被花費

        # 2. 驗證解鎖腳本
        if not verify_script(inp.scriptSig, utxo.scriptPubKey, tx):
            return False  # 簽名/腳本驗證失敗

        total_input += utxo.value

    # 驗證每個 output
    for out in tx.outputs:
        if out.value &lt; 0:
            return False  # 金額不能為負
        if out.value &lt; DUST_THRESHOLD:
            return False  # 低於 dust 門檻
        total_output += out.value

    # 3. 金額守恆
    if total_input &lt; total_output:
        return False  # 輸出不能大於輸入

    fee = total_input - total_output
    if fee &lt; MIN_RELAY_FEE:
        return False  # 手續費太低

    return True
</code></pre>
<hr />
<h2 id="163-常見-utxo-鏈全表"><a class="header" href="#163-常見-utxo-鏈全表">16.3 常見 UTXO 鏈全表</a></h2>
<div class="table-wrapper"><table><thead><tr><th>類別</th><th>鏈</th><th>共識/模型</th><th>重點</th></tr></thead><tbody>
<tr><td>PoW UTXO 主流</td><td>Bitcoin</td><td>PoW + UTXO</td><td>安全錨、最成熟</td></tr>
<tr><td>PoW UTXO 支付</td><td>Litecoin, Dogecoin, BCH, Dash</td><td>PoW + UTXO</td><td>支付導向、費用較低</td></tr>
<tr><td>隱私 UTXO</td><td>Zcash, Monero</td><td>PoW + Shielded/RingCT</td><td>隱私強、合規成本高</td></tr>
<tr><td>擴展 UTXO</td><td>Cardano(EUTXO), CKB(Cell)</td><td>PoS/PoW + UTXO 變體</td><td>合約能力提升</td></tr>
<tr><td>高吞吐 UTXO 路線</td><td>Kaspa</td><td>PoW + DAG/UTXO</td><td>追求低延遲高吞吐</td></tr>
</tbody></table>
</div>
<h3 id="各類-utxo-鏈的工程差異"><a class="header" href="#各類-utxo-鏈的工程差異">各類 UTXO 鏈的工程差異</a></h3>
<p><strong>Bitcoin</strong> 是 UTXO 模型的原型，也是最成熟的實現。其腳本語言（Bitcoin Script）是刻意設計為非圖靈完備的，限制了合約的複雜度但大幅降低了攻擊面。2021 年啟用的 Taproot 升級（BIP-340/341/342）帶來了 Schnorr 簽名和 MAST（Merkelized Abstract Syntax Trees），使得複雜的腳本條件可以更高效、更隱私地實現。Ordinals 和 BRC-20 則展示了在 UTXO 模型上構建更豐富應用的可能性，雖然這些做法在社群中存在爭議。</p>
<p><strong>隱私 UTXO 鏈</strong> 在工程上面臨獨特的挑戰。Zcash 的 shielded transaction 使用零知識證明（zk-SNARKs）來隱藏交易金額和地址，但生成證明的計算成本較高。Monero 的 RingCT 使用環簽名來混淆交易來源，所有交易預設都是隱私的。對於需要對接這些鏈的工程師，主要挑戰在於 AML/KYT 合規：因為交易資訊被加密，傳統的鏈上分析工具效用有限。</p>
<p><strong>Cardano 的 EUTXO</strong> 和 <strong>Nervos CKB 的 Cell Model</strong> 代表了 UTXO 模型的進化方向。它們在保留 UTXO 並行驗證優勢的同時，引入了更豐富的狀態管理能力。但這也帶來了新的工程挑戰，例如 UTXO contention（多筆交易同時嘗試消費同一個 UTXO），在高頻交互的 DeFi 場景中尤為明顯。</p>
<p><strong>Kaspa</strong> 代表了 UTXO + DAG（有向無環圖）的探索方向。傳統區塊鏈是線性的（每個區塊指向前一個區塊），Kaspa 允許多個區塊同時產生並最終排序，結合 UTXO 的天然並行性，理論上可以實現更高的吞吐量和更低的確認延遲。</p>
<hr />
<h2 id="164-eutxoextended-utxo"><a class="header" href="#164-eutxoextended-utxo">16.4 EUTXO（Extended UTXO）</a></h2>
<p>EUTXO 在每個輸出上加入：</p>
<ul>
<li><strong>Datum（資料）</strong>：附加在 UTXO 上的任意資料，用於承載合約狀態</li>
<li><strong>Redeemer（花費參數）</strong>：花費 UTXO 時提供的額外參數，用於觸發特定的邏輯分支</li>
<li><strong>Validator Script（驗證邏輯）</strong>：決定 UTXO 是否可以被花費的腳本程式</li>
</ul>
<p>這讓 UTXO 可承載更複雜狀態機，但開發難度會提高。</p>
<h3 id="eutxo-的運作方式"><a class="header" href="#eutxo-的運作方式">EUTXO 的運作方式</a></h3>
<pre><code class="language-text">EUTXO 交易結構：

┌───────────────────────────────────────────────────────┐
│  Input:                                                │
│    UTXO ref: txid#0                                    │
│    Redeemer: { action: "swap", amount: 100 }           │
│                                                        │
│  Referenced UTXO (被花費的 EUTXO):                     │
│  ┌──────────────────────────────────────┐              │
│  │  Value: 1000 ADA + 500 TokenA        │              │
│  │  Datum: { pool_state: ...,           │              │
│  │           reserve_a: 500,            │              │
│  │           reserve_b: 1000 }          │              │
│  │  Validator: DEX_validator.plutus      │              │
│  └──────────────────────────────────────┘              │
│                                                        │
│  Validator Execution:                                  │
│    validator(datum, redeemer, script_context) -&gt; Bool   │
│    - 驗證 swap 比例符合 AMM 公式                       │
│    - 驗證輸出 UTXO 的 datum 正確更新                   │
│    - 驗證手續費被正確扣除                              │
│                                                        │
│  Output (新 EUTXO):                                    │
│  ┌──────────────────────────────────────┐              │
│  │  Value: 1000 ADA + 400 TokenA        │              │
│  │  Datum: { pool_state: ...,           │              │
│  │           reserve_a: 400,            │              │
│  │           reserve_b: 1100 }          │              │
│  │  Validator: DEX_validator.plutus      │              │
│  └──────────────────────────────────────┘              │
│  ┌──────────────────────────────────────┐              │
│  │  Value: 100 TokenA (user receives)   │              │
│  └──────────────────────────────────────┘              │
└───────────────────────────────────────────────────────┘
</code></pre>
<h3 id="eutxo-的工程挑戰"><a class="header" href="#eutxo-的工程挑戰">EUTXO 的工程挑戰</a></h3>
<p>EUTXO 模型的最大工程挑戰是 <strong>UTXO Contention</strong>。在 Account 模型中，多個用戶可以「同時」與同一個合約互動（雖然實際上交易會被序列化）。但在 EUTXO 模型中，每個 UTXO 只能被一筆交易消費，如果多筆交易嘗試消費同一個 UTXO（例如同一個 DEX 的流動性池），只有一筆會成功，其他都會失敗。</p>
<p>解決 contention 的常見策略：</p>
<ol>
<li><strong>UTXO 分片（Output Splitting）</strong>：將一個大的狀態 UTXO 分散到多個小 UTXO 上，讓不同交易可以並行處理不同的分片。</li>
<li><strong>Batching</strong>：收集多個用戶的操作，打包成一筆交易一次處理。</li>
<li><strong>Off-chain Protocol</strong>：將頻繁互動移到鏈下（如 Hydra），只在需要結算時回到鏈上。</li>
</ol>
<pre><code class="language-text">UTXO Contention 問題與解決方案：

問題：
  User A ──花費──&gt; Pool UTXO &lt;──花費── User B
                     ^
                     │
                User C ──花費──

  三個用戶同時要 swap，但 Pool UTXO 只有一個
  → 只有一筆交易成功，其他兩筆失敗

解決 - UTXO 分片：
  User A ──&gt; Pool UTXO Shard 1
  User B ──&gt; Pool UTXO Shard 2
  User C ──&gt; Pool UTXO Shard 3
  → 三筆交易可以並行處理
  → 定期合併分片狀態
</code></pre>
<hr />
<h2 id="165-utxo-vs-account-的工程差異"><a class="header" href="#165-utxo-vs-account-的工程差異">16.5 UTXO vs Account 的工程差異</a></h2>
<h3 id="狀態建模"><a class="header" href="#狀態建模">狀態建模</a></h3>
<ul>
<li>
<p><strong>UTXO</strong>: 顯式輸入輸出，天然「來源 -&gt; 去向」可追蹤。每筆交易的資金流向是透明的，可以從任意一個 UTXO 一路回溯到 coinbase 交易。這使得 UTXO 模型天然適合金流追蹤和稽核。但「查詢某地址餘額」需要掃描所有 UTXO，效率較低。</p>
</li>
<li>
<p><strong>Account</strong>: 隱式狀態更新，合約邏輯彈性大。每個地址有一個餘額數字，轉帳就是修改數字，查詢餘額只需讀取一個變數。但要追蹤資金流向，需要解析所有歷史交易的 internal transactions，複雜度高。</p>
</li>
</ul>
<pre><code class="language-text">相同交易在兩種模型下的表現：

Account Model:                    UTXO Model:
┌──────────┐                     ┌──────────┐
│ Alice     │                     │ UTXO-1   │
│ bal: 10   │─ send 3 ─&gt;         │ 10 BTC   │──花費──&gt;
│ bal: 7    │                     │ (Alice)  │
└──────────┘                     └──────────┘
┌──────────┐                     ┌──────────┐  ┌──────────┐
│ Bob       │                     │ UTXO-2   │  │ UTXO-3   │
│ bal: 5    │                     │ 3 BTC    │  │ 7 BTC    │
│ bal: 8    │                     │ (Bob)    │  │ (Alice)  │
└──────────┘                     └──────────┘  └──────────┘
                                              (找零回 Alice)
</code></pre>
<h3 id="並行度"><a class="header" href="#並行度">並行度</a></h3>
<ul>
<li>
<p><strong>UTXO</strong>: 不同 UTXO 可平行驗證。因為每筆交易明確宣告它要消費哪些 UTXO 和產生哪些新 UTXO，驗證節點可以同時驗證不涉及相同 UTXO 的多筆交易。這是 UTXO 模型在吞吐量方面的理論優勢。</p>
</li>
<li>
<p><strong>Account</strong>: 同帳戶 nonce 序列化，容易排隊。同一個帳戶的交易必須按 nonce 順序執行，不同帳戶的交易理論上可以並行，但在 EVM 中，如果交易涉及共享狀態（如同一個合約的 storage slot），仍然需要序列化。</p>
</li>
</ul>
<h3 id="費用估算"><a class="header" href="#費用估算">費用估算</a></h3>
<ul>
<li>
<p><strong>UTXO</strong>: 受輸入輸出數量與見證大小影響。交易的「大小」（以 vbytes 計算）直接決定手續費。輸入越多（需要越多簽名資料），交易越大，費用越高。SegWit 和 Taproot 透過優化見證資料的權重來降低費用。</p>
</li>
<li>
<p><strong>Account</strong>: 受 opcode 執行與 storage 變更影響。EVM 的 gas 消耗取決於執行了哪些 opcode、以及修改了多少 storage slot。Gas estimation 需要實際模擬交易執行。</p>
</li>
</ul>
<h3 id="費用估算的-pseudocode"><a class="header" href="#費用估算的-pseudocode">費用估算的 pseudocode</a></h3>
<pre><code class="language-python"># UTXO 費用估算
def estimate_utxo_fee(num_inputs, num_outputs, fee_rate_sat_per_vbyte):
    # SegWit P2WPKH 交易大小估算
    base_size = 10  # version + locktime + overhead
    input_size = num_inputs * 68  # per input (non-witness)
    output_size = num_outputs * 31  # per output
    witness_size = num_inputs * 107  # per input witness

    # vbytes = base_weight + witness_weight / 4
    weight = (base_size + input_size + output_size) * 4 + witness_size
    vbytes = weight / 4

    return int(vbytes * fee_rate_sat_per_vbyte)

# Account 費用估算
def estimate_account_fee(gas_used, base_fee, priority_fee):
    # EIP-1559 費用模型
    max_fee = base_fee + priority_fee
    return gas_used * max_fee
</code></pre>
<h3 id="開發心智"><a class="header" href="#開發心智">開發心智</a></h3>
<ul>
<li>
<p><strong>UTXO</strong>: TX graph 思維（像資料流）。開發者需要思考的是「我有哪些 UTXO 可以花費？花費後會產生哪些新的 UTXO？」。這像是一個數據管道（data pipeline），每筆交易是一個轉換節點。這種思維方式對於習慣命令式編程的開發者來說需要適應期。</p>
</li>
<li>
<p><strong>Account</strong>: 合約狀態機思維（像物件模型）。開發者操作的是合約的狀態變數（storage），每個函數呼叫修改狀態。這像是操作一個物件（object），呼叫方法改變屬性。對於大多數開發者來說更直覺。</p>
</li>
</ul>
<hr />
<h2 id="166-utxo-常見工程問題"><a class="header" href="#166-utxo-常見工程問題">16.6 UTXO 常見工程問題</a></h2>
<h3 id="dust-utxo"><a class="header" href="#dust-utxo">Dust UTXO</a></h3>
<p>太小的輸出（如 0.00000001 BTC）造成管理成本高於其本身價值。Bitcoin Core 預設的 dust threshold 是 546 satoshis（P2PKH）或 294 satoshis（P2WPKH）。低於此門檻的 output 會被節點視為 non-standard 而拒絕中繼。</p>
<p>Dust 的工程影響：(1) 膨脹 UTXO 集合，增加節點記憶體消耗；(2) 花費 dust UTXO 的手續費可能超過其面額，成為「經濟上無法花費」的資產；(3) Dust attack 是一種隱私攻擊手法，攻擊者向大量地址發送極小額度的 UTXO，然後追蹤這些 UTXO 何時被花費，以分析地址之間的關聯。</p>
<h3 id="utxo-fragmentation"><a class="header" href="#utxo-fragmentation">UTXO Fragmentation</a></h3>
<p>輸出過碎，手續費升高。當錢包頻繁收到小額付款時，UTXO 會變得碎片化。發送一筆較大的付款時，可能需要合併數十甚至數百個小 UTXO 作為輸入，導致交易體積膨脹、手續費飆升。</p>
<p>解決方案是定期做 UTXO consolidation：在手續費較低的時段（如週末凌晨），將多個小 UTXO 合併成少數大 UTXO。這就像把一堆零錢拿去銀行換成大鈔。</p>
<pre><code class="language-python"># UTXO 合併策略 pseudocode
def consolidate_utxos(wallet, fee_rate_threshold):
    current_fee_rate = get_current_fee_rate()
    if current_fee_rate &gt; fee_rate_threshold:
        return  # 費率太高，等待低費率時段

    small_utxos = [u for u in wallet.utxos if u.value &lt; CONSOLIDATION_THRESHOLD]
    if len(small_utxos) &lt; MIN_CONSOLIDATION_COUNT:
        return  # 碎片不夠多，不值得合併

    # 分批合併，每批不超過 100 個 input
    for batch in chunks(small_utxos, 100):
        total = sum(u.value for u in batch)
        fee = estimate_fee(len(batch), 1, current_fee_rate)
        if total - fee &gt; DUST_THRESHOLD:
            create_consolidation_tx(batch, wallet.change_address, fee)
</code></pre>
<h3 id="coin-selection"><a class="header" href="#coin-selection">Coin Selection</a></h3>
<p>怎麼選輸入最省費用是一個經典的最佳化問題。選擇不同的 UTXO 組合，會產生不同大小的交易和不同金額的找零，直接影響手續費和隱私。詳見 16.7 節。</p>
<h3 id="change-management"><a class="header" href="#change-management">Change Management</a></h3>
<p>找零地址管理錯誤造成追蹤困難。在 BIP-44 的 HD wallet 架構中，找零地址使用單獨的派生路徑（m/44'/0'/0'/1/n），與接收地址（m/44'/0'/0'/0/n）分開管理。如果找零地址管理出錯（例如找零被發送到未備份的地址），可能導致資金「消失」。</p>
<p><strong>最佳實踐</strong>：(1) 永遠使用 HD wallet 的標準派生路徑；(2) 在發送交易前驗證找零地址確實屬於自己的錢包；(3) 定期掃描 gap limit（預設 20 個未使用地址）以外的地址，避免遺漏。</p>
<h3 id="fee-bumping"><a class="header" href="#fee-bumping">Fee Bumping</a></h3>
<p>交易卡住時要 RBF/CPFP。當交易送出後因手續費太低而長時間未被確認時，需要使用加速策略。詳見 16.8 節。</p>
<hr />
<h2 id="167-coin-selection-策略"><a class="header" href="#167-coin-selection-策略">16.7 Coin Selection 策略</a></h2>
<p>Coin Selection 是 UTXO 錢包的核心演算法之一，決定了交易的手續費、隱私程度、和 UTXO 碎片化程度。</p>
<h3 id="largest-first"><a class="header" href="#largest-first">Largest First</a></h3>
<p>省輸入數，可能找零過大。每次從最大面額的 UTXO 開始選取，直到累計金額足夠。優點是交易體積最小（輸入數最少），手續費最低。缺點是如果支付小額時使用了大面額 UTXO，會產生大額找零，且大 UTXO 可能是你不想動用的儲蓄。</p>
<h3 id="branch-and-bound"><a class="header" href="#branch-and-bound">Branch and Bound</a></h3>
<p>嘗試精準匹配，是 Bitcoin Core 自 v0.17 起的預設策略。演算法嘗試找到一組 UTXO，其金額加總恰好等於目標金額加上手續費，從而避免產生找零 output。避免找零不僅節省一個 output 的大小（減少手續費），還減少了一個新的 UTXO 進入碎片池。但精準匹配不一定總能找到，找不到時會退回其他策略。</p>
<pre><code class="language-text">Branch and Bound 範例：
目標金額: 0.5 BTC + 0.0001 fee = 0.5001 BTC

可用 UTXO: [0.3, 0.2001, 0.15, 0.1, 0.05]

搜尋過程：
  0.3 + 0.2001 = 0.5001  精準匹配！
  → 不需要找零 output
  → 交易只有 2 inputs + 1 output
</code></pre>
<h3 id="knapsack"><a class="header" href="#knapsack">Knapsack</a></h3>
<p>近似最佳化，是經典的背包問題變形。在無法找到精準匹配時，使用隨機化的 knapsack 演算法選擇接近目標金額的 UTXO 組合，在手續費和找零大小之間取得平衡。</p>
<h3 id="privacy-aware"><a class="header" href="#privacy-aware">Privacy-aware</a></h3>
<p>避免地址關聯洩漏。從隱私角度考慮的 coin selection 會避免將不同來源（不同地址、不同交易）的 UTXO 混合在同一筆交易中，因為這會暴露「這些地址屬於同一個人」的資訊。更進階的做法如 CoinJoin，會將多個用戶的交易混合在一起，打斷可追蹤的鏈。</p>
<h3 id="coin-selection-策略比較"><a class="header" href="#coin-selection-策略比較">Coin Selection 策略比較</a></h3>
<pre><code class="language-text">┌──────────────┬──────────┬──────────┬──────────┬──────────┐
│  策略        │ 手續費   │ 隱私性   │ 碎片化   │ 複雜度   │
├──────────────┼──────────┼──────────┼──────────┼──────────┤
│ Largest First│  最低    │   差     │   高     │  O(n)    │
│ Branch&amp;Bound │  低      │   中     │   最低   │  O(2^n)  │
│ Knapsack     │  中      │   中     │   中     │  O(n)    │
│ Privacy-aware│  高      │   最好   │   中     │  O(n^2)  │
│ Random       │  中      │   好     │   中     │  O(n)    │
└──────────────┴──────────┴──────────┴──────────┴──────────┘
</code></pre>
<hr />
<h2 id="168-交易加速策略"><a class="header" href="#168-交易加速策略">16.8 交易加速策略</a></h2>
<p>當 UTXO 交易送出後因手續費太低而卡在 mempool 中時，有兩種主要的加速策略。</p>
<h3 id="rbfreplace-by-fee"><a class="header" href="#rbfreplace-by-fee">RBF（Replace-By-Fee）</a></h3>
<p>同輸入替換更高手續費的交易。RBF 允許發送者在交易未確認時，使用相同的輸入（inputs）構造一筆新交易，支付更高的手續費來替換原交易。</p>
<p><strong>使用條件</strong>：(1) 原交易必須設置 <code>nSequence &lt; 0xfffffffe</code>（BIP-125 signaling）來表明它是可替換的；(2) 替換交易的手續費必須高於原交易；(3) 替換交易必須包含原交易的所有輸入。</p>
<pre><code class="language-text">RBF 流程：

原交易（卡住）：                    替換交易：
┌────────────────────┐             ┌────────────────────┐
│ Input: UTXO-A      │             │ Input: UTXO-A      │
│ Output: Bob 1 BTC  │    替換     │ Output: Bob 1 BTC  │
│ Output: Alice 0.49 │   ──────&gt;   │ Output: Alice 0.47 │
│ Fee: 0.01 BTC      │             │ Fee: 0.03 BTC      │
│ (太低，未確認)      │             │ (提高手續費)        │
└────────────────────┘             └────────────────────┘
</code></pre>
<p><strong>注意事項</strong>：RBF 只對發送者有效。如果你是接收者（Bob），你無法用 RBF 來加速別人發給你的交易。此外，RBF 可能被用於「雙花」：先用低費率交易付款，等對方發貨後用 RBF 替換成付給自己的交易。因此，未確認交易不應被視為已完成的付款。</p>
<h3 id="cpfpchild-pays-for-parent"><a class="header" href="#cpfpchild-pays-for-parent">CPFP（Child-Pays-For-Parent）</a></h3>
<p>子交易抬高父交易打包誘因。CPFP 是由接收者發起的加速策略：接收者花費（未確認的）收到的 output，構造一筆新交易並支付較高的手續費。因為新交易（child）依賴於舊交易（parent），礦工要打包 child 就必須同時打包 parent，所以會按照兩筆交易的「總手續費 / 總大小」來評估打包優先級。</p>
<pre><code class="language-text">CPFP 流程：

父交易（卡住）：                    子交易（加速）：
┌────────────────────┐             ┌────────────────────┐
│ Input: UTXO-A      │             │ Input: 父交易的     │
│ Output: Bob 1 BTC  │──────&gt;──────│   Output (Bob 1BTC)│
│ Fee: 100 sat       │             │ Output: Bob 0.9 BTC│
│ (太低)              │             │ Fee: 10000 sat     │
└────────────────────┘             │ (高手續費)          │
                                   └────────────────────┘

礦工計算：
  Package fee rate = (100 + 10000) / (250 + 150) vbytes
                   = 10100 / 400
                   = 25.25 sat/vbyte ✓ 足以被打包
</code></pre>
<p><strong>工程實踐</strong>：建議在交易服務中同時實作 RBF 和 CPFP 的自動化策略。監控已送出但未確認的交易，如果超過預期確認時間（例如 30 分鐘），自動觸發加速。對於發送方，優先使用 RBF（更經濟）；對於接收方，使用 CPFP。</p>
<hr />
<h2 id="169-utxo-金流稽核"><a class="header" href="#169-utxo-金流稽核">16.9 UTXO 金流稽核</a></h2>
<p>UTXO 模型的天然透明性使其特別適合金流追蹤和稽核。</p>
<h3 id="基本原理"><a class="header" href="#基本原理">基本原理</a></h3>
<ul>
<li>
<p><strong>每一筆輸入可回溯來源 UTXO</strong>：從任意一個 UTXO 開始，沿著 <code>prev_txid</code> 鏈一路回溯，最終一定可以追蹤到 coinbase 交易（礦工獎勵）。這個特性使得 UTXO 的「出身」（provenance）是完全透明的。</p>
</li>
<li>
<p><strong>可建立 UTXO age / provenance 風險模型</strong>：通過分析 UTXO 的年齡（自產生以來經過的區塊數）和來源交易鏈的風險標記，可以為每個 UTXO 計算風險分數。例如：來自已知混幣服務（mixer）的 UTXO 會被標記為高風險；來自知名交易所的 UTXO 通常被視為低風險。</p>
</li>
<li>
<p><strong>建議建立地址分群與風險標記（內部可見）</strong>：使用 clustering 演算法（如 common-input-ownership heuristic）將可能屬於同一實體的地址分組，並標記風險等級。這些標記僅供內部風控使用，不應公開。</p>
</li>
</ul>
<h3 id="utxo-稽核圖transaction-graph"><a class="header" href="#utxo-稽核圖transaction-graph">UTXO 稽核圖（Transaction Graph）</a></h3>
<pre><code class="language-text">稽核追蹤範例：

Coinbase (Block 100)
  │
  └──&gt; UTXO-1 (50 BTC, Miner)
         │
         ├──&gt; UTXO-2 (30 BTC, Exchange A) ──&gt; UTXO-4 (29 BTC, User X)
         │                                      │
         │                                      └──&gt; UTXO-6 (28.9 BTC, ???)
         │                                           ⚠ 流入未知地址，風險升高
         │
         └──&gt; UTXO-3 (19.99 BTC, Exchange A)
                │
                └──&gt; UTXO-5 (10 BTC, Known Cold Wallet) ✓ 低風險
</code></pre>
<h3 id="稽核工具與實踐"><a class="header" href="#稽核工具與實踐">稽核工具與實踐</a></h3>
<p>對於需要進行 UTXO 金流稽核的團隊，常用的工具包括：</p>
<ul>
<li><strong>Chainalysis / Elliptic</strong>：商業級鏈上分析平台，提供地址風險評分和交易圖譜</li>
<li><strong>OXT.me</strong>：開源的 Bitcoin 交易分析工具</li>
<li><strong>自建 UTXO indexer</strong>：對於有特殊需求的團隊，可以基於 Bitcoin Core 的 <code>-txindex</code> 功能或 Electrum Server 來建立自己的 UTXO 索引</li>
</ul>
<hr />
<h2 id="1610-utxo-多簽"><a class="header" href="#1610-utxo-多簽">16.10 UTXO 多簽</a></h2>
<h3 id="常見腳本路線"><a class="header" href="#常見腳本路線">常見腳本路線</a></h3>
<ul>
<li>
<p><strong>Bitcoin Script 多簽（historical）</strong>：最早的多簽實現，使用 <code>OP_CHECKMULTISIG</code> opcode。缺點是所有公鑰都暴露在腳本中，且有一個 off-by-one bug（dummy element）。</p>
</li>
<li>
<p><strong>P2WSH / Taproot policy（現代實務）</strong>：P2WSH（Pay to Witness Script Hash）將多簽腳本放在 witness 中，節省交易大小。Taproot（P2TR）進一步優化：在大家都同意的情況下，可以用 key path spending 生成一個普通的 Schnorr 簽名，在鏈上完全看不出是多簽交易；只有在需要回退機制時才使用 script path 揭示多簽腳本。</p>
</li>
<li>
<p><strong>Threshold 方案（MuSig2 類聚合簽名）</strong>：MuSig2 允許多個簽名者協作產生一個標準的 Schnorr 簽名，在鏈上與普通的單簽名交易完全相同。這提供了最好的隱私保護和最低的交易費用，但實現複雜度較高，且需要多輪通信。</p>
</li>
</ul>
<pre><code class="language-text">三種多簽方案在鏈上的表現：

Legacy OP_CHECKMULTISIG:
  scriptPubKey: 2 &lt;PubKey1&gt; &lt;PubKey2&gt; &lt;PubKey3&gt; 3 OP_CHECKMULTISIG
  → 鏈上可見：多簽、3個公鑰、2-of-3 門檻
  → 費用：高（暴露所有公鑰）

Taproot Key Path (所有人同意時):
  output: &lt;aggregated_public_key&gt;
  witness: &lt;aggregated_signature&gt;
  → 鏈上可見：普通交易
  → 費用：最低（與單簽名相同）

Taproot Script Path (回退機制):
  output: &lt;internal_key&gt; + &lt;merkle_root&gt;
  witness: &lt;sig1&gt; &lt;sig2&gt; &lt;multisig_script&gt; &lt;merkle_proof&gt;
  → 鏈上可見：Taproot 腳本花費
  → 費用：中等
</code></pre>
<h3 id="重點控制項"><a class="header" href="#重點控制項">重點控制項</a></h3>
<ul>
<li>
<p><strong>門檻策略 M-of-N</strong>：M（簽名門檻）和 N（總簽名者數）的選擇取決於安全需求和可用性。常見配置：2-of-3（小型團隊、日常操作）、3-of-5（機構國庫、中等金額）、4-of-7（大型 DAO 國庫、重大變更）。M 太低會降低安全性，M 太高會降低可用性（需要太多人同時在線簽名）。</p>
</li>
<li>
<p><strong>輸出模板白名單</strong>：限制多簽錢包只能向預先批准的地址轉帳。這可以透過 Bitcoin Script 的 <code>OP_CHECKTEMPLATEVERIFY</code>（BIP-119，尚未啟用）或鏈下的 policy engine 來實現。在 policy engine 模式下，簽名者在簽名前會驗證交易的輸出是否符合白名單規則。</p>
</li>
<li>
<p><strong>時鎖（絕對/相對）</strong>：<code>OP_CHECKLOCKTIMEVERIFY</code>（CLTV，BIP-65）用於絕對時間鎖（交易在某個區塊高度或時間戳之後才能生效）；<code>OP_CHECKSEQUENCEVERIFY</code>（CSV，BIP-112）用於相對時間鎖（交易在輸入的 UTXO 被確認後的一段時間後才能花費）。時鎖可用於實現定期結算、延遲執行等機制。</p>
</li>
<li>
<p><strong>緊急恢復路徑（social recovery）</strong>：如果主要簽名者的密鑰全部遺失或無法使用，需要有備用的恢復機制。常見做法是在 Taproot 的 script tree 中預設一個「N+M 天後，恢復密鑰可以單獨花費」的分支。例如：正常路徑是 2-of-3 多簽，恢復路徑是「180 天後，恢復密鑰可以單獨轉出資金到指定的冷錢包」。</p>
</li>
</ul>
<hr />
<h2 id="1611-utxo-安全檢查清單"><a class="header" href="#1611-utxo-安全檢查清單">16.11 UTXO 安全檢查清單</a></h2>
<p>以下是 UTXO 系統上線前必須確認的安全檢查項：</p>
<h3 id="----地址與腳本型別檢查p2pkhp2wpkhp2tr-等"><a class="header" href="#----地址與腳本型別檢查p2pkhp2wpkhp2tr-等">- [ ] 地址與腳本型別檢查（P2PKH/P2WPKH/P2TR 等）</a></h3>
<p>確保系統正確處理所有支援的地址格式。不同的地址格式對應不同的腳本類型和費用結構。混用地址格式可能導致相容性問題。建議優先使用 Bech32/Bech32m 地址（P2WPKH/P2TR），它們的費用最低且有內建的錯誤檢測。</p>
<h3 id="----coin-selection-策略與隱私策略分離"><a class="header" href="#----coin-selection-策略與隱私策略分離">- [ ] Coin selection 策略與隱私策略分離</a></h3>
<p>Coin selection 不僅影響費用，還影響隱私。對於有隱私需求的系統，coin selection 策略應避免將不同來源的 UTXO 混合在同一筆交易中。建議將 coin selection 策略設計為可配置的，讓不同的業務場景使用不同的策略。</p>
<h3 id="----交易模擬與費率估算多來源比對"><a class="header" href="#----交易模擬與費率估算多來源比對">- [ ] 交易模擬與費率估算多來源比對</a></h3>
<p>費率估算應參考多個資料來源（如 mempool.space、bitcoinfees.earn.com、本地節點的 <code>estimatesmartfee</code>），並取中位數或加權平均。單一來源的費率估算可能因為網路條件突變而失準。</p>
<h3 id="----change-output-不落到錯誤地址池"><a class="header" href="#----change-output-不落到錯誤地址池">- [ ] Change output 不落到錯誤地址池</a></h3>
<p>確保找零 output 使用正確的派生路徑，且地址確實屬於自己的錢包。在多 HD wallet 或多 account 的環境中，找零地址被送到錯誤的 account 是一個常見的 bug。每筆交易送出前都應驗證找零地址的所有權。</p>
<h3 id="----大額轉帳使用多簽--時鎖"><a class="header" href="#----大額轉帳使用多簽--時鎖">- [ ] 大額轉帳使用多簽 + 時鎖</a></h3>
<p>對於超過預設門檻的轉帳（例如 &gt; 1 BTC），強制使用多簽 wallet 並附加 timelock。這為大額交易提供了額外的安全保障，即使某個簽名者的密鑰被盜，攻擊者也無法在 timelock 期限內轉出資金。</p>
<h3 id="----卡交易有-rbfcpfp-runbook"><a class="header" href="#----卡交易有-rbfcpfp-runbook">- [ ] 卡交易有 RBF/CPFP runbook</a></h3>
<p>準備明確的操作手冊，描述交易卡住時的處理步驟：如何判斷交易是否真的卡住（而非僅僅是延遲）、何時觸發 RBF、何時使用 CPFP、以及自動化加速的觸發條件和費率上限。</p>
<hr />
<h2 id="1612-什麼場景適合-utxo"><a class="header" href="#1612-什麼場景適合-utxo">16.12 什麼場景適合 UTXO</a></h2>
<h3 id="高審計要求的資產結算"><a class="header" href="#高審計要求的資產結算">高審計要求的資產結算</a></h3>
<p>UTXO 的天然可追蹤性使其成為需要嚴格稽核的資產結算系統的理想選擇。每一筆資金的來源和去向都可以透過 transaction graph 完整追蹤，不需要額外的索引系統。對於需要向監管機構證明資金來源合法性的機構，UTXO 模型比 Account 模型更容易產出清晰的稽核報告。</p>
<h3 id="需簡潔可驗證的支付引擎"><a class="header" href="#需簡潔可驗證的支付引擎">需簡潔可驗證的支付引擎</a></h3>
<p>如果你的核心需求是「安全地從 A 轉帳到 B」，UTXO 模型提供了最簡潔的驗證邏輯：檢查輸入是否有效、簽名是否正確、金額是否守恆。不需要理解複雜的合約邏輯或狀態轉換。這使得 UTXO 系統的安全審計範圍小、可驗證性強。</p>
<h3 id="不追求複雜共享合約狀態"><a class="header" href="#不追求複雜共享合約狀態">不追求複雜共享合約狀態</a></h3>
<p>UTXO 模型不適合需要多方頻繁交互同一個共享狀態的場景（如 AMM DEX、借貸協議）。如果你的應用主要是點對點支付、資產發行與轉讓、或簡單的多簽託管，UTXO 是很好的選擇。如果你需要複雜的 DeFi 邏輯，Account 模型（或 EUTXO 的特殊設計）更適合。</p>
<h3 id="決策矩陣"><a class="header" href="#決策矩陣">決策矩陣</a></h3>
<pre><code class="language-text">你的場景適合 UTXO 嗎？

需要複雜合約邏輯？ ──是──&gt; Account 模型 (Ethereum/Solana)
      │
      否
      │
需要高頻交互共享狀態？ ──是──&gt; Account 模型 或 EUTXO + 特殊設計
      │
      否
      │
需要強稽核追蹤？ ──是──&gt; UTXO (Bitcoin/Litecoin)
      │
      否
      │
需要交易隱私？ ──是──&gt; Privacy UTXO (Zcash/Monero)
      │
      否
      │
需要高吞吐低延遲？ ──是──&gt; UTXO + DAG (Kaspa)
      │
      否
      │
簡單支付場景 ──&gt; UTXO (Bitcoin/Litecoin)
</code></pre>
<hr />
<h2 id="白話總結-15"><a class="header" href="#白話總結-15">白話總結</a></h2>
<p>UTXO 就像你皮夾裡一堆紙鈔。你的「餘額」不是一個數字，而是你手上所有紙鈔面額加起來的結果。每次付款時，你從皮夾裡挑幾張鈔票出來（input），把該付的金額給對方（output），找零的部分以新紙鈔的形式回到你手上（change output），差額就是給收銀員的小費（miner fee）。</p>
<p>這種模型最大的好處是「可追蹤」：每一張紙鈔（UTXO）都有明確的來源，你可以一路追溯到它最初被印出來的那一刻（coinbase 交易）。這讓 UTXO 特別適合需要稽核的資產系統。另一個好處是天然的並行性：因為不同的紙鈔互不干擾，多筆不涉及相同紙鈔的交易可以同時驗證。</p>
<p>但 UTXO 也有它的工程痛點。紙鈔會碎片化（一堆零錢比大鈔難管理），選幣策略會影響手續費和隱私，找零管理出錯會導致資金「消失」，交易卡住時需要 RBF 或 CPFP 來加速。EUTXO 試圖在紙鈔上寫上更多資訊，讓紙鈔不只是紙鈔、還能承載合約狀態，但這也讓開發難度上升了一個量級。</p>
<p>總結來說：如果你的需求是簡潔安全的支付和結算、需要清晰的金流追蹤、不需要複雜的共享合約狀態，UTXO 是成熟且可靠的選擇。Bitcoin 十多年的安全運行紀錄就是最好的證明。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第2篇-區塊鏈技術篇"><a class="header" href="#第2篇-區塊鏈技術篇">第2篇 區塊鏈技術篇</a></h1>
<p>本篇涵蓋第4章到第6章，重點是把區塊鏈當成分散式系統來理解。</p>
<h2 id="重要度分級"><a class="header" href="#重要度分級">重要度分級</a></h2>
<ul>
<li><code>P0</code> 必修：直接影響架構、開發與安全</li>
<li><code>P1</code> 重要：影響方案選型與產品方向</li>
<li><code>P2</code> 補充：特定場景或產業知識</li>
</ul>
<h2 id="篇章定位"><a class="header" href="#篇章定位">篇章定位</a></h2>
<ul>
<li>第4章：底層基礎（P2P、資料結構、PoW、UTXO、安全）</li>
<li>第5章：核心原理（以太坊、共識、跨鏈、ZK、L2）</li>
<li>第6章：產業落地（公鏈/聯盟鏈、合規、熱門應用）</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第4章-初識區塊鏈"><a class="header" href="#第4章-初識區塊鏈">第4章 初識區塊鏈</a></h1>
<p>本章聚焦於區塊鏈最底層共識與資料結構，目標是建立可實作的工程理解。</p>
<h2 id="41-區塊鏈的誕生與發展-p1"><a class="header" href="#41-區塊鏈的誕生與發展-p1">4.1 區塊鏈的誕生與發展 <code>P1</code></a></h2>
<h3 id="411-區塊鏈的誕生-p1"><a class="header" href="#411-區塊鏈的誕生-p1">4.1.1 區塊鏈的誕生 <code>P1</code></a></h3>
<p>區塊鏈誕生的核心背景是：</p>
<ul>
<li>中心化系統容易形成單點故障與信任成本</li>
<li>網路原生資產需要「不靠中心機構」的記帳方式</li>
<li>雙花問題需要在開放網路中可被驗證地解決</li>
</ul>
<p>在區塊鏈出現之前，所有的數位交易都需要一個可信的中間人。銀行、支付平台、清算所——這些機構扮演著「記帳員」的角色，負責確保 Alice 轉給 Bob 的那筆錢不會同時轉給 Charlie。這套模式在實體世界運作得不錯，但它有一個根本性的代價：你必須信任這個中間人不會倒閉、不會被攻破、不會審查你的交易。2008 年金融危機讓這個代價變得格外刺眼——全球最「可信」的金融機構幾乎同時失信。</p>
<p>Satoshi Nakamoto 在 2008 年 10 月發表的白皮書《Bitcoin: A Peer-to-Peer Electronic Cash System》提出了一個關鍵洞見：如果我們能讓網路中所有參與者共同維護一本帳本，並且用密碼學和經濟激勵來取代對單一機構的信任，那麼我們就能實現「trustless」的數位價值轉移。這裡的 trustless 不是「不信任」，而是「不需要預先信任特定對象」。</p>
<p>雙花問題（double spending）是數位貨幣的核心難題。實體鈔票轉手後就不在原持有者手上了，但數位資料可以被無限複製。過去解決這個問題的唯一方式是中心化帳本。比特幣的突破在於：透過 PoW 共識機制，讓全網節點就交易順序達成一致，從而在去中心化環境中解決了雙花問題。任何人想要「撤回」已確認的交易，都必須重做大量計算工作，使得攻擊在經濟上不可行。</p>
<p>工程結論：區塊鏈不是單一技術，而是密碼學、分散式網路、經濟激勵三者結合。這三根支柱缺一不可——沒有密碼學，資料無法被驗證；沒有分散式網路，系統會退化為中心化架構；沒有經濟激勵，節點沒有動力誠實運作。理解這一點對工程設計至關重要，因為它意味著區塊鏈工程師需要同時具備這三個領域的知識。</p>
<h3 id="412-認識密碼龐克組織-p1"><a class="header" href="#412-認識密碼龐克組織-p1">4.1.2 認識密碼龐克組織 <code>P1</code></a></h3>
<p>密碼龐克（Cypherpunk）核心理念：</p>
<ul>
<li>以密碼學工具保護個體自由</li>
<li>系統要「最小信任」而非「善意假設」</li>
<li>協議透明、程式可驗證</li>
</ul>
<p>密碼龐克運動可以追溯到 1990 年代初期。Eric Hughes 在 1993 年發表的《A Cypherpunk's Manifesto》中寫道：「隱私不是秘密。隱私是選擇性地向世界展示自己的權力。」這個運動匯聚了一群密碼學家、程式設計師和社會活動家，他們相信強密碼學是對抗監控和保護個人自由的最後防線。</p>
<p>這個群體中產生了許多區塊鏈的前身技術：Adam Back 的 Hashcash（PoW 的原型）、Wei Dai 的 b-money（去中心化電子現金提案）、Hal Finney 的 Reusable Proof of Work、Nick Szabo 的 Bit Gold。這些方案各自解決了部分問題，但都未能完整地解決拜占庭容錯環境下的共識問題。比特幣可以被理解為站在這些巨人肩膀上的集大成者。</p>
<p>對工程的直接影響：</p>
<ul>
<li>預設 hostile environment</li>
<li>重要規則寫進協議而非寫在文件</li>
<li>採用可公開審計的安全模型</li>
</ul>
<p>密碼龐克的思維方式對現代區塊鏈工程有深遠影響。「Don't trust, verify」不只是口號，它是一種設計哲學。在傳統軟體工程中，我們經常假設輸入是善意的、伺服器是可信的、網路是可靠的。但在區塊鏈工程中，每一個假設都可能被利用。例如，Smart Contract 開發中的 reentrancy attack 就是因為開發者「假設」外部合約不會在回調中做壞事。密碼龐克教會我們：安全模型必須基於對手可以做什麼，而不是期望對手會做什麼。</p>
<h3 id="413-區塊鏈技術的高速發展-p1"><a class="header" href="#413-區塊鏈技術的高速發展-p1">4.1.3 區塊鏈技術的高速發展 <code>P1</code></a></h3>
<p>發展主軸：</p>
<ul>
<li>Bitcoin：價值轉移與 PoW 安全</li>
<li>Ethereum：可程式化狀態與合約平台</li>
<li>L2：擴容與低成本</li>
<li>ZK/模組化：可驗證計算與分層架構</li>
</ul>
<p>區塊鏈的發展可以用「四個時代」來理解。第一個時代（2009-2014）是比特幣時代，核心創新是去中心化的價值轉移。這個階段的工程挑戰集中在 P2P 網路穩定性、UTXO 模型設計、PoW 難度調整演算法。比特幣證明了一件事：不需要銀行也能轉帳，而且這個系統在真實的對抗環境中是安全的。</p>
<p>第二個時代（2015-2019）由以太坊開啟，引入了圖靈完備的智能合約平台。Vitalik Buterin 的洞見是：如果區塊鏈能執行任意程式碼，那它就不只是一個帳本，而是一台「世界電腦」。EVM（Ethereum Virtual Machine）讓開發者可以在鏈上部署任意邏輯，催生了 ICO、DeFi、NFT 等應用。但這也帶來了新的工程挑戰：Gas 計費、狀態膨脹、合約安全。</p>
<p>第三個時代（2020-2023）是 DeFi 爆發與 L2 擴容。DeFi Summer（2020 年夏天）讓以太坊主網擁堵到 Gas 費高達數十美元，直接推動了 L2 方案的發展。Optimistic Rollup（如 Arbitrum、Optimism）和 ZK Rollup（如 zkSync、StarkNet）提供了在繼承 L1 安全性的前提下擴容的路徑。</p>
<pre><code class="language-text">時代演進：

2009         2015         2020         2024+
  |            |            |            |
  v            v            v            v
Bitcoin    Ethereum    DeFi/L2      Modular/ZK
(帳本)     (程式化)    (擴容)       (可驗證)
  |            |            |            |
  v            v            v            v
UTXO       EVM/Gas     Rollup      DA+Exec分離
PoW        PoW-&gt;PoS    Bridge      ZK Proof
</code></pre>
<p>第四個時代（2024 至今）是模組化與可驗證計算。Celestia 提出的「模組化區塊鏈」概念將傳統單體鏈拆分為 Data Availability、Execution、Settlement、Consensus 四層，每層可以獨立優化。ZK 技術從 L2 擴展到更廣泛的應用場景——ZK 身份驗證、ZK 機器學習推論驗證、ZK coprocessor 等。工程師的思維方式也從「寫一條鏈」轉變為「組合模組」。</p>
<h2 id="42-p2p網絡-p0"><a class="header" href="#42-p2p網絡-p0">4.2 P2P網絡 <code>P0</code></a></h2>
<h3 id="421-p2p網絡概述-p0"><a class="header" href="#421-p2p網絡概述-p0">4.2.1 P2P網絡概述 <code>P0</code></a></h3>
<p>P2P 網路特徵：</p>
<ul>
<li>無中心主機，節點對等交換資料</li>
<li>新交易/新區塊透過 gossip 擴散</li>
<li>每節點只需連少量鄰居即可參與全網同步</li>
</ul>
<p>P2P（Peer-to-Peer）網路是區塊鏈去中心化的基礎設施層。與傳統的 Client-Server 架構不同，P2P 網路中每個節點既是客戶端也是伺服器。這意味著沒有單一的故障點——即使部分節點離線，其餘節點仍能正常運作。比特幣網路自 2009 年上線以來，除了早期的一些軟體 bug 導致的短暫異常，從未「宕機」過。這種韌性正是 P2P 架構的核心優勢。</p>
<p>Gossip 協議是區塊鏈 P2P 網路中最常見的訊息傳播機制。它的運作方式類似謠言傳播：當一個節點收到新交易或新區塊時，會隨機選擇幾個鄰居轉發。這些鄰居再轉發給它們的鄰居，如此遞迴，直到整個網路都收到消息。在數學上，gossip 協議可以在 O(log N) 輪中將消息傳播到 N 個節點，效率極高。比特幣網路的實測顯示，一筆新交易通常在 2-5 秒內就能傳播到全網大多數節點。</p>
<pre><code class="language-text">Gossip 傳播示意圖：

時間 T0:        時間 T1:           時間 T2:

   [A]             [A]                [A]
    |              / \               / | \
   新TX          [B] [C]          [B] [C] [D]
                  |                |   |   |
                 [D]             [E] [F] [G]

   A 收到交易     A 傳給 B,C       繼續擴散到全網
</code></pre>
<p>在工程實務上，P2P 網路的設計需要考慮 NAT 穿越問題。大多數家用網路環境下，節點位於 NAT 後方，無法被外部直接連接。解決方案包括 UPnP、STUN/TURN 協議、以及像 libp2p 這種框架提供的 relay 機制。以太坊使用的 devp2p 協議棧和 libp2p（被 Polkadot、Filecoin 等採用）是目前最主流的兩個區塊鏈 P2P 網路框架。</p>
<h3 id="422-p2p網絡的搭建重點-p0"><a class="header" href="#422-p2p網絡的搭建重點-p0">4.2.2 P2P網絡的搭建重點 <code>P0</code></a></h3>
<p>搭建重點：</p>
<ul>
<li>節點發現：seed/bootnode/mDNS</li>
<li>連線治理：限速、黑名單、重試退避</li>
<li>訊息設計：消息類型、版本協商、校驗碼</li>
<li>韌性策略：避免 eclipse attack、避免單點 seed</li>
</ul>
<p><strong>節點發現</strong>是 P2P 網路的第一個工程挑戰。新加入網路的節點需要找到至少一個已有節點才能開始同步。常見策略包括：硬編碼的 bootnode 清單（比特幣的 DNS seed）、DHT（Distributed Hash Table）自動發現、以及區域網路的 mDNS 廣播。以太坊使用 Kademlia DHT 的變體作為節點發現層，每個節點維護一張路由表，按照 XOR 距離將其他節點分組存儲。</p>
<pre><code class="language-text">Kademlia DHT 節點發現：

Node ID: 0x1A3F (本節點)

路由表 (k-bucket):
┌──────────────────────────────────────────┐
│ 距離範圍    │ 儲存的鄰居節點              │
├──────────────────────────────────────────┤
│ 2^0 - 2^1  │ 0x1A3E                      │
│ 2^1 - 2^2  │ 0x1A3D, 0x1A3C              │
│ 2^2 - 2^4  │ 0x1A3B, 0x1A38              │
│ ...        │ ...                          │
│ 2^15-2^16  │ 0x8F21, 0xC4A2, 0xE103      │
└──────────────────────────────────────────┘

越遠的距離範圍，儲存的節點數量上限一樣（k 個），
但覆蓋的 ID 空間更大 → 保證 O(log N) 查找效率
</code></pre>
<p><strong>連線治理</strong>是防止資源耗盡的關鍵。一個節點不可能連接全網所有節點，因此需要設定最大連接數（通常 25-50 個）、入站/出站比例、連線品質評分。如果某個 peer 頻繁傳送無效資料或響應過慢，應降低其評分並最終斷開連線。指數退避（exponential backoff）是處理連線失敗的標準做法——第一次失敗等 1 秒重試，第二次等 2 秒，第三次等 4 秒，以此類推，避免在網路異常時產生重試風暴。</p>
<p><strong>Eclipse Attack</strong> 是 P2P 網路中最嚴重的威脅之一。攻擊者控制受害節點的所有入站和出站連接，使其與真實網路隔離。防禦措施包括：限制同一 IP 段的連接數量、保持一定比例的出站連接（出站連接由本節點主動發起，較難被攻擊者控制）、以及定期隨機替換 peer。比特幣在 2015 年的論文《Eclipse Attacks on Bitcoin's Peer-to-Peer Network》之後強化了相關防禦。</p>
<h3 id="423-區塊鏈網絡的資料同步機制-p0"><a class="header" href="#423-區塊鏈網絡的資料同步機制-p0">4.2.3 區塊鏈網絡的資料同步機制 <code>P0</code></a></h3>
<p>資料同步常見流程：</p>
<ol>
<li>節點互報高度與 tip hash</li>
<li>缺塊節點請求區塊清單</li>
<li>逐塊拉取並驗證</li>
<li>更新本地鏈狀態與交易池</li>
</ol>
<p>區塊同步是新節點加入網路後最耗時的過程。以比特幣為例，從創世塊同步到最新狀態需要下載超過 500 GB 的區塊資料。以太坊的全節點同步則可能需要數天甚至數週。因此，同步效率直接影響了網路的可及性。</p>
<pre><code class="language-text">區塊同步流程：

新節點 N                    已同步節點 P
   |                            |
   |--- Handshake (版本/鏈 ID) --&gt;|
   |                            |
   |&lt;-- Status (高度/tip hash) --|
   |                            |
   |--- GetHeaders (起點 hash)-&gt;|
   |                            |
   |&lt;-- Headers[] --------------|
   |                            |
   |--- GetBodies (hash[]) ----&gt;|
   |                            |
   |&lt;-- Bodies[] ---------------|
   |                            |
   |   [本地驗證每個區塊]         |
   |   [更新狀態]                |
   |                            |
</code></pre>
<p>主要有三種同步策略：<strong>Full Sync</strong> 從創世塊開始逐塊執行所有交易，安全性最高但耗時最長。<strong>Fast Sync</strong>（以太坊的術語）先下載所有區塊頭，驗證 PoW/PoS，然後只下載最近狀態的快照（state trie），再從快照點開始全量執行。<strong>Snap Sync</strong> 是 Fast Sync 的改進，透過 range proof 分批下載狀態樹，大幅減少同步時間。<strong>Light Client</strong> 只下載區塊頭，需要查詢交易時向全節點請求 Merkle proof。</p>
<p>工程要點：</p>
<ul>
<li>交易池去重</li>
<li>區塊驗證先於入庫</li>
<li>fork 時保留分叉資料以便重組</li>
</ul>
<p>交易池（mempool）的管理是另一個重要的工程問題。每個全節點維護一個未確認交易的記憶體池。當新交易進入時，需要檢查：(1) 格式是否正確；(2) 簽名是否有效；(3) 是否與池中已有交易衝突（雙花檢測）；(4) 手續費是否高於最低門檻。交易池通常有容量限制（比特幣預設 300 MB），當池滿時會驅逐低費率交易。</p>
<p>Fork 處理是區塊同步中最複雜的部分。當網路中同時出現兩個有效但互斥的區塊時，節點需要保留兩個分支，直到其中一個分支變得更長（在 PoW 中是更多累積工作量）。此時節點執行 <strong>reorg</strong>（鏈重組）：回滾較短分支的交易，應用較長分支的交易。工程實作上，這要求資料庫支持高效的回滾操作，通常使用 journal/undo log 機制。</p>
<h2 id="43-區塊鏈的資料結構-p0"><a class="header" href="#43-區塊鏈的資料結構-p0">4.3 區塊鏈的資料結構 <code>P0</code></a></h2>
<h3 id="431-哈希函數-p0"><a class="header" href="#431-哈希函數-p0">4.3.1 哈希函數 <code>P0</code></a></h3>
<p>hash 函數在鏈中用途：</p>
<ul>
<li>交易 ID</li>
<li>區塊 ID</li>
<li>Merkle 根</li>
<li>狀態承諾</li>
</ul>
<p>哈希函數是區塊鏈最基礎的密碼學工具。它將任意長度的輸入映射為固定長度的輸出（稱為摘要或 hash），並具有三個關鍵特性：(1) <strong>抗碰撞性</strong>（collision resistance）——找不到兩個不同的輸入產生相同的輸出；(2) <strong>抗原像性</strong>（preimage resistance）——無法從 hash 反推原始輸入；(3) <strong>雪崩效應</strong>（avalanche effect）——輸入的微小改動導致輸出完全不同。</p>
<p>比特幣使用 SHA-256（雙重 SHA-256 用於區塊頭），以太坊使用 Keccak-256（注意：這與 NIST 標準化的 SHA-3 略有不同）。選擇哪種 hash 函數對系統設計有深遠影響——它決定了地址長度、proof 大小、以及未來的量子安全性。</p>
<pre><code class="language-text">Hash 函數示意：

輸入: "Hello, Blockchain!"
           |
      ┌────v────┐
      │ SHA-256  │
      └────┬────┘
           |
輸出: 0x7f83b1657ff1fc53b92dc18148a1d65d
      fc2d4b1fa3d677284addd200126d9069

改一個字元:
輸入: "Hello, Blockchain?"  (! -&gt; ?)
           |
      ┌────v────┐
      │ SHA-256  │
      └────┬────┘
           |
輸出: 0x3e23e8160039594a33894f6564e1b134  &lt;-- 完全不同
      8bbd7a0088d42c4acb73eeaed59c009d
</code></pre>
<p>工程原則：</p>
<ul>
<li>序列化必須穩定</li>
<li>hash 算法版本變更要有兼容策略</li>
</ul>
<p><strong>序列化穩定性</strong>是容易被忽視但極其關鍵的工程問題。Hash 函數的輸入是位元組串，因此在計算 hash 之前，必須將結構化資料（如交易、區塊頭）序列化為位元組。如果不同實作使用不同的序列化順序或格式，即使資料相同也會產生不同的 hash。比特幣使用嚴格定義的 little-endian 二進位格式；以太坊使用 RLP（Recursive Length Prefix）編碼。常見的坑包括：整數的大小端問題、字串的編碼方式、空值的處理方式。在跨語言實作時，這些問題尤其容易出錯。</p>
<h3 id="432-時序的鏈塊式結構-p0"><a class="header" href="#432-時序的鏈塊式結構-p0">4.3.2 時序的鏈塊式結構 <code>P0</code></a></h3>
<p>區塊透過 <code>prev_block_hash</code> 串連，形成時間順序。
任一歷史區塊被改動，都會破壞後續鏈接校驗。</p>
<p>鏈塊式結構是區塊鏈最具標誌性的設計。每個區塊包含前一個區塊的 hash，形成一條不可篡改的鏈條。如果攻擊者試圖修改歷史區塊中的任何一筆交易，這個區塊的 hash 會改變，導致下一個區塊中記錄的 <code>prev_block_hash</code> 不再匹配，進而使整條後續鏈條失效。攻擊者必須從被修改的區塊開始，重新計算所有後續區塊的 hash——在 PoW 系統中，這意味著重做大量計算工作。</p>
<pre><code class="language-text">區塊結構與鏈接：

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│    Block 0       │    │    Block 1       │    │    Block 2       │
│  (Genesis)       │    │                  │    │                  │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ prev_hash: 0x00 │    │ prev_hash: 0xA1 │◄───│ prev_hash: 0xB2 │
│ timestamp       │    │ timestamp        │    │ timestamp        │
│ nonce           │    │ nonce            │    │ nonce            │
│ merkle_root     │    │ merkle_root      │    │ merkle_root      │
│ tx_list         │    │ tx_list          │    │ tx_list          │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ hash: 0xA1...   │───►│ hash: 0xB2...   │───►│ hash: 0xC3...    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
</code></pre>
<p>一個區塊頭通常包含以下欄位：前區塊 hash、時間戳記、難度目標（PoW 專用）、nonce（PoW 專用）、Merkle root、以及可能的額外資料欄位。區塊體則包含該區塊中打包的所有交易。以比特幣為例，區塊頭固定 80 bytes，而區塊體的大小取決於包含的交易數量，上限約 1 MB（SegWit 後有效容量約 4 MB weight）。</p>
<p>工程上需要注意的一個細節是「孤塊」（orphan block）的處理。由於網路延遲，節點可能先收到子區塊後收到父區塊。此時需要暫存這些找不到父區塊的孤塊，待父區塊到達後再連接。同時要防止攻擊者發送大量無效孤塊來耗盡記憶體，因此孤塊快取通常有大小限制。</p>
<h3 id="433-梅克爾樹-p0"><a class="header" href="#433-梅克爾樹-p0">4.3.3 梅克爾樹 <code>P0</code></a></h3>
<p>Merkle Tree 解決兩件事：</p>
<ul>
<li>大量交易的摘要承諾</li>
<li>只用路徑證明即可驗證交易包含性</li>
</ul>
<p>Merkle Tree（梅克爾樹）是由 Ralph Merkle 在 1979 年提出的資料結構。它的核心思想是：將所有交易兩兩配對做 hash，再將結果兩兩配對做 hash，層層往上，最終得到一個根 hash（Merkle Root）。這個根 hash 是所有交易的「指紋」——只要任何一筆交易被修改，根 hash 就會完全不同。</p>
<pre><code class="language-text">Merkle Tree 結構：

              Root Hash
             (= H(H01 + H23))
            /                \
         H01                  H23
     (= H(H0+H1))        (= H(H2+H3))
       /      \             /      \
     H0        H1         H2        H3
     |         |          |         |
   Tx 0      Tx 1       Tx 2      Tx 3


Merkle Proof 示例（證明 Tx2 存在於此區塊）：
驗證者只需要：Tx2, H3, H01, Root

驗證步驟：
1. 計算 H2 = hash(Tx2)
2. 計算 H23 = hash(H2 + H3)      ← 需要 H3
3. 計算 Root' = hash(H01 + H23)   ← 需要 H01
4. 比對 Root' == Root              ← 驗證通過
</code></pre>
<p>Merkle Proof 的效率非常驚人。假設一個區塊包含 4096 筆交易，要驗證某筆交易是否存在，只需要提供 12 個 hash（log2(4096) = 12），而不是所有 4096 筆交易。這使得輕節點（light client）成為可能——手機錢包不需要下載整條鏈，只需要區塊頭和 Merkle Proof 就能驗證交易。</p>
<p>常見坑：</p>
<ul>
<li>奇數葉節點複製規則未統一</li>
<li>葉節點 hash 前處理不一致</li>
</ul>
<p><strong>奇數葉節點問題</strong>值得詳細說明。當交易數量是奇數時，最後一個交易沒有配對對象。比特幣的做法是複製最後一個 hash 與自己配對。但這引入了一個已知的攻擊向量：攻擊者可以構造一個包含重複交易的區塊，使其 Merkle Root 與正常區塊相同（CVE-2012-2459）。修復方法是在驗證時檢查是否存在重複的交易 hash。以太坊使用的 Modified Merkle Patricia Trie 結構不同，不存在這個問題，但引入了其他複雜性（如 trie 路徑編碼）。</p>
<p><strong>葉節點前處理</strong>也是常見的坑。為了防止第二原像攻擊（second preimage attack），葉節點和內部節點的 hash 計算應使用不同的前綴。例如，葉節點 hash = H(0x00 + data)，內部節點 hash = H(0x01 + left + right)。如果不區分，攻擊者可能將某個內部節點偽裝成葉節點。</p>
<h2 id="44-pow機制-p0"><a class="header" href="#44-pow機制-p0">4.4 PoW機制 <code>P0</code></a></h2>
<h3 id="441-分佈式網絡中共識的意義-p0"><a class="header" href="#441-分佈式網絡中共識的意義-p0">4.4.1 分佈式網絡中共識的意義 <code>P0</code></a></h3>
<p>共識要回答：</p>
<ul>
<li>哪筆交易先發生</li>
<li>哪個區塊是有效延伸</li>
<li>網路分割後如何收斂到單一歷史</li>
</ul>
<p>在分散式系統中，「共識」是一個經典的難題。FLP 不可能定理告訴我們：在異步網路中，即使只有一個節點可能故障，也無法保證所有正確節點在有限時間內達成共識。區塊鏈的突破在於：它不追求確定性共識，而是接受機率性共識——交易被確認的機率隨時間遞增，但永遠不會達到 100%。</p>
<p>為什麼交易排序如此重要？考慮這個場景：Alice 的帳戶有 10 ETH，她同時發送兩筆交易——一筆轉 10 ETH 給 Bob，另一筆轉 10 ETH 給 Charlie。兩筆交易都是「合法」的（簽名正確、餘額充足），但它們不能同時有效。網路必須對它們的順序達成一致，且這個順序一旦確定就不能被更改。這就是共識要解決的核心問題。</p>
<pre><code class="language-text">共識的必要性（雙花場景）：

Alice 餘額: 10 ETH

     Tx1: Alice -&gt; Bob (10 ETH)
    /
Alice
    \
     Tx2: Alice -&gt; Charlie (10 ETH)

如果沒有共識：
  節點 A 看到 Tx1 先到 → Bob 得到 10 ETH
  節點 B 看到 Tx2 先到 → Charlie 得到 10 ETH
  → 系統狀態不一致！

有共識（PoW）：
  礦工打包 Tx1 進區塊 → 全網同意 Bob 得到 10 ETH
  Tx2 變成無效交易 → 被丟棄
</code></pre>
<h3 id="442-什麼是pow-p0"><a class="header" href="#442-什麼是pow-p0">4.4.2 什麼是PoW <code>P0</code></a></h3>
<p>PoW：透過計算成本取得出塊權。
有效區塊條件：<code>hash(header) &lt; target</code>。</p>
<p>Proof of Work 的核心機制極其簡單：礦工不斷改變區塊頭中的 nonce 值，重新計算 hash，直到 hash 值小於一個目標值。這個過程本質上是暴力搜索——沒有捷徑，唯一的加速方式是增加計算能力。找到符合條件的 nonce 被稱為「挖到區塊」，礦工獲得區塊獎勵和交易手續費。</p>
<pre><code>PoW 挖礦過程（偽代碼）：

function mine(block_header, target):
    nonce = 0
    while true:
        block_header.nonce = nonce
        hash = SHA256(SHA256(block_header))
        if hash &lt; target:
            return nonce    // 找到了！
        nonce += 1

// 例如 target 前面需要 20 個零位元：
// target:  0x00000FFFFFFFFFFFFFFFFFFFFFFFFFFF...
// hash1:   0x7A3B1...  ← 不符合，繼續
// hash2:   0x2F8C4...  ← 不符合，繼續
// ...
// hash N:  0x00000123... ← 符合！出塊成功
</code></pre>
<p>難度調整是 PoW 系統的精妙設計。比特幣每 2016 個區塊（約兩週）調整一次難度，確保平均出塊時間維持在 10 分鐘。如果這 2016 個區塊的實際耗時少於兩週，說明算力增加了，就提高難度；反之則降低。這個負回饋機制使比特幣的出塊速率在算力劇烈變化的十多年間保持了驚人的穩定。</p>
<h3 id="443-pow的本質原理-p0"><a class="header" href="#443-pow的本質原理-p0">4.4.3 PoW的本質原理 <code>P0</code></a></h3>
<p>本質是「用客觀成本限制作惡」：</p>
<ul>
<li>想改歷史要重做工作量</li>
<li>攻擊成本與鏈安全預算相關</li>
</ul>
<p>PoW 的安全性來自一個經濟學論證：攻擊區塊鏈需要付出的電力和硬體成本必須超過攻擊的預期收益。以比特幣為例，2024 年全網算力超過 500 EH/s，要發動 51% 攻擊需要控制超過 250 EH/s 的算力。按當時的 ASIC 礦機價格和電費計算，這需要數十億美元的投資。而攻擊成功後能獲得的收益（主要是雙花攻擊）遠小於這個成本。</p>
<p>工程觀點：</p>
<ul>
<li>PoW 提供機率最終性</li>
<li>大額交易要提高確認數</li>
</ul>
<p><strong>機率最終性</strong>是一個重要的工程概念。一筆交易被包含在區塊中後，並不是立即「最終確認」的。攻擊者有一定機率能夠建立更長的替代鏈來替換包含這筆交易的區塊。但隨著後續區塊的累積，攻擊成功的機率呈指數下降。比特幣社群的慣例是等待 6 個確認（約 1 小時）才認為交易是「安全」的。Satoshi 在白皮書中計算過：假設攻擊者擁有 10% 的算力，6 個確認後攻擊成功的機率不到 0.02%。</p>
<pre><code class="language-text">確認數與安全性：

確認數    攻擊成功機率（攻擊者 10% 算力）
  1          ~20%
  2          ~4%
  3          ~1%
  6          ~0.02%
  12         ~0.000004%

實務建議：
┌─────────────────┬───────────┐
│ 交易金額         │ 建議確認數 │
├─────────────────┼───────────┤
│ &lt; $1,000        │ 1-2       │
│ $1,000-$10,000  │ 3-4       │
│ $10,000-$100k   │ 6         │
│ &gt; $100k         │ 12+       │
└─────────────────┴───────────┘
</code></pre>
<p>PoW 的一個常見批評是能源消耗。比特幣網路的年耗電量已經超過許多中小型國家。這推動了業界對替代共識機制（尤其是 PoS）的探索。但支持者認為，PoW 的能源消耗正是其安全性的來源——正是因為攻擊需要消耗大量能源，攻擊才不可行。這個辯論涉及「安全性每單位成本」的經濟學分析，超出了純技術範疇。</p>
<h2 id="45-utxo與交易-p0"><a class="header" href="#45-utxo與交易-p0">4.5 UTXO與交易 <code>P0</code></a></h2>
<h3 id="451-什麼是utxo-p0"><a class="header" href="#451-什麼是utxo-p0">4.5.1 什麼是UTXO <code>P0</code></a></h3>
<p>UTXO 是尚未花費輸出。
交易透過消耗舊輸出、創建新輸出完成轉移。</p>
<p>UTXO（Unspent Transaction Output，未花費交易輸出）是比特幣的帳本模型。與我們直覺中的「帳戶餘額」不同，UTXO 模型不存在「帳戶」的概念。你的「餘額」實際上是分散在區塊鏈上所有屬於你的 UTXO 的總和。這就像你的錢包裡有好幾張不同面額的鈔票——你不能撕碎一張 100 元鈔票來付 50 元，你必須把整張 100 元交出去，然後收到 50 元的找零。</p>
<pre><code class="language-text">UTXO 模型示意：

Alice 的 "餘額" = 3 BTC，實際上是：
┌──────────────────┐
│ UTXO-1: 1.5 BTC  │ (來自交易 TX-A，輸出 #0)
│ UTXO-2: 0.8 BTC  │ (來自交易 TX-B，輸出 #1)
│ UTXO-3: 0.7 BTC  │ (來自交易 TX-C，輸出 #0)
└──────────────────┘

Alice 要轉 2 BTC 給 Bob：
  消耗: UTXO-1 (1.5) + UTXO-2 (0.8) = 2.3 BTC
  產生: Output-0: Bob 2.0 BTC  (新 UTXO)
        Output-1: Alice 0.29 BTC (找零 UTXO)
        Fee: 0.01 BTC (隱含手續費)
</code></pre>
<p>UTXO 模型有幾個工程上的重要優勢：(1) <strong>天然支援並行驗證</strong>——不同交易如果消耗不同的 UTXO，它們之間沒有依賴關係，可以並行驗證。(2) <strong>隱私性較好</strong>——每次交易可以使用新地址接收找零，增加交易圖分析的難度。(3) <strong>確定性驗證</strong>——交易的有效性只取決於它引用的 UTXO 是否存在且未被花費，不受其他交易影響。</p>
<p>UTXO 的劣勢在於狀態查詢和複雜邏輯的實作難度較高。要查詢某個地址的「餘額」，需要掃描整個 UTXO 集合找出屬於該地址的所有 UTXO。實作智能合約式的複雜邏輯也比帳戶模型困難得多，因為每個 UTXO 都是獨立的，沒有共享狀態。</p>
<h3 id="452-比特幣交易模型-p0"><a class="header" href="#452-比特幣交易模型-p0">4.5.2 比特幣交易模型 <code>P0</code></a></h3>
<p>基本結構：</p>
<ul>
<li>Inputs：引用前序輸出</li>
<li>Outputs：新輸出（收款 + 找零）</li>
<li>Fee：輸入總額減輸出總額</li>
</ul>
<p>一筆比特幣交易的完整結構如下：</p>
<pre><code class="language-text">交易結構：

┌─────────────────────────────────────────┐
│ Transaction                              │
├─────────────────────────────────────────┤
│ version: 2                               │
│                                          │
│ inputs: [                                │
│   {                                      │
│     prev_tx_hash: 0xABC...,              │
│     prev_output_index: 0,                │
│     script_sig: &lt;signature&gt; &lt;pubkey&gt;,    │
│     sequence: 0xFFFFFFFF                 │
│   }                                      │
│ ]                                        │
│                                          │
│ outputs: [                               │
│   {                                      │
│     value: 200000000,   // 2 BTC (satoshi)│
│     script_pubkey: OP_DUP OP_HASH160     │
│                    &lt;pubkey_hash&gt;          │
│                    OP_EQUALVERIFY         │
│                    OP_CHECKSIG            │
│   },                                     │
│   {                                      │
│     value: 29000000,    // 0.29 BTC (找零)│
│     script_pubkey: ...                   │
│   }                                      │
│ ]                                        │
│                                          │
│ locktime: 0                              │
└─────────────────────────────────────────┘
</code></pre>
<pre><code class="language-text">old outputs -&gt; tx inputs -&gt; validation -&gt; tx outputs
</code></pre>
<p>手續費的計算方式是隱含的：輸入總額減去輸出總額就是手續費。如果 Alice 消耗了 2.3 BTC 的輸入，產生了 2.0 BTC 給 Bob 和 0.29 BTC 給自己，那麼 0.01 BTC 就是手續費。一個常見的新手錯誤是忘記加找零輸出，導致全部差額變成手續費。曾經有人因此在一筆交易中付了超過 80 BTC 的手續費。</p>
<p>比特幣手續費以「每 vByte 的 satoshi」（sat/vB）為單位。交易的虛擬大小取決於它包含的輸入和輸出數量。更多的輸入意味著更多的簽名資料，交易更大，手續費更高。因此，管理 UTXO 的「碎片化」是錢包工程中的重要課題——太多小額 UTXO 會導致未來交易的手續費比 UTXO 本身的價值還高。</p>
<h3 id="453-交易腳本-p0"><a class="header" href="#453-交易腳本-p0">4.5.3 交易腳本 <code>P0</code></a></h3>
<p>腳本負責定義「誰能花這筆錢」：</p>
<ul>
<li>locking script（鎖定條件）</li>
<li>unlocking witness/script（解鎖證明）</li>
</ul>
<p>比特幣的腳本系統是一個基於堆疊的、非圖靈完備的腳本語言（稱為 Bitcoin Script）。它故意限制了功能——沒有迴圈、沒有遞迴——以避免程式執行時間不可預測的問題。每個 UTXO 被一個 locking script（也稱 scriptPubKey）鎖定；要花費這個 UTXO，花費者必須提供一個滿足條件的 unlocking script（也稱 scriptSig 或 witness）。</p>
<pre><code class="language-text">P2PKH (Pay-to-Public-Key-Hash) 腳本執行：

Locking Script (存在 UTXO 中):
  OP_DUP OP_HASH160 &lt;pubKeyHash&gt; OP_EQUALVERIFY OP_CHECKSIG

Unlocking Script (花費時提供):
  &lt;signature&gt; &lt;publicKey&gt;

堆疊執行過程：
Stack: []
  → push &lt;signature&gt;         Stack: [sig]
  → push &lt;publicKey&gt;         Stack: [sig, pubKey]
  → OP_DUP                   Stack: [sig, pubKey, pubKey]
  → OP_HASH160                Stack: [sig, pubKey, hash(pubKey)]
  → push &lt;pubKeyHash&gt;        Stack: [sig, pubKey, hash(pubKey), pubKeyHash]
  → OP_EQUALVERIFY           Stack: [sig, pubKey]  (hash 相等，繼續)
  → OP_CHECKSIG              Stack: [true]  (簽名驗證通過)
</code></pre>
<p>工程重點：</p>
<ul>
<li>支援常見模板（P2PKH/P2WPKH/P2TR）</li>
<li>驗證失敗要可追蹤錯誤原因</li>
</ul>
<p>隨著比特幣的演進，腳本類型也在進化。P2PKH 是最早的標準類型。P2SH（Pay-to-Script-Hash）允許將複雜的鎖定條件壓縮成一個 hash，讓付款者不需要了解解鎖條件的細節。P2WPKH（SegWit）將見證資料移出交易主體，降低了交易大小和手續費。P2TR（Taproot，2021 年啟用）引入了 Schnorr 簽名和 MAST（Merkelized Alternative Script Trees），同時提升了隱私性和多簽場景的效率。</p>
<p>工程實作中，驗證失敗的錯誤追蹤非常重要。腳本驗證失敗可能有多種原因——簽名無效、hash 不匹配、時間鎖未到期等。一個好的實作應該在驗證過程中記錄堆疊狀態和失敗的操作碼，以便於除錯。在開發期間，使用 Bitcoin Core 的 <code>signrawtransactionwithwallet</code> 或類似的 debug 工具可以幫助定位腳本問題。</p>
<h2 id="46-區塊鏈帳本的安全與挑戰-p0"><a class="header" href="#46-區塊鏈帳本的安全與挑戰-p0">4.6 區塊鏈帳本的安全與挑戰 <code>P0</code></a></h2>
<h3 id="461-雙花攻擊-p0"><a class="header" href="#461-雙花攻擊-p0">4.6.1 雙花攻擊 <code>P0</code></a></h3>
<p>同一資產被提交兩筆互斥交易。
防護：</p>
<ul>
<li>UTXO/nonce 檢查</li>
<li>足夠確認數</li>
<li>高風險交易延遲出貨</li>
</ul>
<p>雙花攻擊（Double Spending Attack）是區塊鏈系統最基本的威脅模型。攻擊者試圖將同一筆資產花費兩次——例如，用同一個 UTXO 同時支付給兩個不同的收款人。在 UTXO 模型中，每個 UTXO 只能被花費一次；在帳戶模型中，每筆交易的 nonce 必須嚴格遞增。這是第一道防線。</p>
<p>常見的雙花攻擊變體包括：</p>
<pre><code class="language-text">1. Race Attack（競速攻擊）:
   攻擊者同時向網路廣播兩筆衝突交易
   → 防護：等待至少 1 個確認

2. Finney Attack:
   攻擊者預先挖好包含 Tx1 的區塊，
   然後廣播 Tx2 到商家，再公佈區塊
   → 防護：等待多個確認

3. 51% Attack（多數算力攻擊）:
   攻擊者秘密挖一條更長的鏈
   → 防護：增加確認數、監控異常
</code></pre>
<p><strong>案例研究：2018 年 Bitcoin Gold 雙花事件。</strong> Bitcoin Gold（BTG）是比特幣的一個分叉幣，使用 Equihash 演算法。2018 年 5 月，攻擊者控制了 BTG 網路超過 51% 的算力，成功執行了雙花攻擊，從交易所竊取了約 1800 萬美元。攻擊者的手法是：先在交易所存入大量 BTG 並兌換成其他幣種提走，然後用秘密挖的更長鏈重組帳本，使存入交易消失。這個事件說明了兩個工程教訓：(1) 小算力幣種的安全性本質上較弱；(2) 交易所的確認數設定需要根據幣種的安全預算來調整。</p>
<h3 id="462-51攻擊-p0"><a class="header" href="#462-51攻擊-p0">4.6.2 51%攻擊 <code>P0</code></a></h3>
<p>若攻擊者控制多數算力/權益，可提高重組與審查能力。
防護：</p>
<ul>
<li>提升經濟安全（算力/質押分散）</li>
<li>增加確認數策略</li>
<li>監控異常重組</li>
</ul>
<p>51% 攻擊是區塊鏈安全模型中最被廣泛討論的威脅。控制多數共識資源（PoW 中的算力、PoS 中的質押）的攻擊者可以：(1) 雙花已確認的交易（透過鏈重組）；(2) 審查特定交易（拒絕將其打包進區塊）；(3) 阻止其他礦工/驗證者出塊。但攻擊者「不能」做的事也很重要：不能偽造簽名、不能花費不屬於自己的資產、不能修改共識規則。</p>
<pre><code class="language-text">51% 攻擊原理：

正常鏈:     A - B - C - D - E  (公開)
                    \
攻擊者秘密鏈:         C'- D'- E'- F' (秘密挖礦)

當攻擊者的秘密鏈更長時：
公佈秘密鏈 → 全網重組到 C'- D'- E'- F'
→ 區塊 C, D, E 中的交易被撤銷
→ 攻擊者在 C' 中放入不同的交易（雙花）
</code></pre>
<p>在 PoS 系統中，51% 攻擊的動態有所不同。攻擊者需要控制超過 1/3 的質押量才能阻止共識達成（BFT 系統），或超過 2/3 的質押量才能單方面確認區塊。但 PoS 系統有一個獨特的防禦手段：<strong>slashing</strong>（罰沒）。如果驗證者被發現簽署了兩個衝突的區塊，其質押會被沒收。這意味著攻擊者即使成功，也會損失大量資本。以太坊的 Casper FFG 設計中，成功的 51% 攻擊需要至少 1/3 的質押被罰沒，按當前質押量計算約 100 億美元。</p>
<p>監控異常重組是工程防禦的重要手段。正常運作下，1-2 個區塊深度的重組偶爾會發生。但 3 個區塊以上的重組就值得警惕，6 個以上幾乎肯定是攻擊。工程上可以部署監控系統，偵測重組深度，一旦超過閾值就觸發警報，暫停高價值操作（如交易所提款）。</p>
<h3 id="463-激勵相容-p0"><a class="header" href="#463-激勵相容-p0">4.6.3 激勵相容 <code>P0</code></a></h3>
<p>協議應讓誠實行為獲得最大期望收益。</p>
<p>激勵相容（Incentive Compatibility）是機制設計理論中的核心概念，意思是：協議的設計應該使得理性參與者的最優策略就是誠實行為。換句話說，不需要假設參與者是「好人」——即使每個人都只追求自利，系統仍能正常運作。</p>
<p>比特幣的激勵設計是一個經典案例。礦工有兩個選擇：(1) 誠實挖礦，獲得區塊獎勵和手續費；(2) 嘗試攻擊（如雙花），可能獲得更大收益但也可能失敗。中本聰在白皮書中論證了：只要誠實礦工控制多數算力，攻擊的期望收益就是負的。因此，理性的礦工會選擇誠實挖礦。</p>
<pre><code class="language-text">激勵相容分析：

礦工策略選擇：

策略 A（誠實挖礦）：
  收入 = 區塊獎勵 + 手續費
  成本 = 電費 + 硬體折舊
  期望利潤 = 穩定正數

策略 B（51% 攻擊）：
  收入 = 雙花金額（如果成功）
  成本 = 電費 + 硬體 + 被攻擊幣種價格崩跌的損失
  成功率 = 取決於算力佔比
  期望利潤 = 通常為負數（因為攻擊成功後幣價崩跌）

結論：理性礦工選擇策略 A
</code></pre>
<p>工程檢核：</p>
<ul>
<li>出塊獎勵與費率模型是否合理</li>
<li>作惡成本是否高於收益</li>
<li>懲罰機制是否可執行</li>
</ul>
<p>工程上需要特別關注激勵失衡的邊緣情況。例如，比特幣的區塊獎勵每四年減半，最終將完全依賴手續費。如果手續費不足以覆蓋挖礦成本，礦工可能會退出，導致安全性下降。另一個例子是 MEV（Maximal Extractable Value）——在以太坊上，礦工/驗證者可以透過重新排序交易來獲取額外收益（如三明治攻擊、清算搶跑）。MEV 的存在改變了激勵結構，可能導致共識不穩定（如 time-bandit attack）。PBS（Proposer-Builder Separation）等設計試圖在協議層面解決 MEV 帶來的激勵問題。</p>
<h2 id="工程核心回顧"><a class="header" href="#工程核心回顧">工程核心回顧</a></h2>
<p>本章最重要的是三條線：</p>
<ul>
<li>結構線：hash + 鏈塊 + Merkle</li>
<li>網路線：P2P 傳播與同步</li>
<li>共識線：PoW + 激勵 + 安全邊界</li>
</ul>
<p>這三條線構成了區塊鏈系統的骨架。<strong>結構線</strong>確保資料不可篡改——hash 函數提供資料指紋，鏈塊結構確保時序不可逆，Merkle Tree 使輕量驗證成為可能。<strong>網路線</strong>確保資料可傳播——P2P 網路讓系統沒有單點故障，gossip 協議讓訊息在秒級傳遍全網，同步機制讓新節點能加入網路。<strong>共識線</strong>確保系統收斂——PoW 讓出塊有成本，激勵相容讓理性行為等於誠實行為，安全邊界讓攻擊在經濟上不可行。</p>
<p>對工程師而言，理解這三條線的相互作用至關重要。例如，P2P 網路的延遲會影響 PoW 的有效性（高延遲導致更多孤塊，降低有效安全性）；Merkle Tree 的設計影響輕客戶端的可行性（進而影響網路的去中心化程度）；激勵設計影響節點運營者的行為（進而影響網路的健康度）。一個好的區塊鏈工程師需要能夠在這三個維度之間做出合理的取捨。</p>
<h2 id="白話總結-16"><a class="header" href="#白話總結-16">白話總結</a></h2>
<p>簡單講，區塊鏈就是一群互不認識的電腦，在沒有「老大」的情況下，共同維護一本大家都認可的帳本。為了防止有人動手腳改帳，每一頁帳本都蓋了一個跟前一頁相關的「章」（hash），你改了任何一頁，後面所有頁的章就對不上了。消息在電腦之間像八卦一樣傳開（gossip），幾秒鐘全網都知道了。而 PoW 挖礦本質上就是「用電費來保證你不敢亂來」——你要作弊得花的電費比你能賺到的還多。UTXO 模型有點反直覺，你的比特幣不是存在「帳戶」裡的，而是像散落在區塊鏈各處的「零錢」，花的時候拼起來用，多的再找零回來。Merkle Tree 讓你的手機錢包不用下載幾百 GB 的資料就能驗證交易是否存在。整個系統最精妙的地方在於「激勵相容」——不需要假設大家是好人，只要大家是理性的，系統就能正常運作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第5章-區塊鏈的技術原理"><a class="header" href="#第5章-區塊鏈的技術原理">第5章 區塊鏈的技術原理</a></h1>
<p>本章重點是從 Ethereum 視角理解現代區塊鏈系統，並掌握主流共識與技術演進方向。</p>
<h2 id="51-以太坊詳解-p0"><a class="header" href="#51-以太坊詳解-p0">5.1 以太坊詳解 <code>P0</code></a></h2>
<h3 id="511-以太坊概述-p0"><a class="header" href="#511-以太坊概述-p0">5.1.1 以太坊概述 <code>P0</code></a></h3>
<p>以太坊是通用智能合約平台，核心能力：</p>
<ul>
<li>EVM 執行環境</li>
<li>帳戶模型（EOA/Contract）</li>
<li>Gas 計費機制</li>
<li>開放標準（ERC）</li>
</ul>
<p>工程定位：適合快速組合 DeFi/NFT/治理應用。</p>
<p>以太坊由 Vitalik Buterin 於 2013 年提出，2015 年正式上線。它的核心創新在於將區塊鏈從「分散式帳本」擴展為「分散式狀態機」。比特幣只能記錄「誰有多少錢」，而以太坊可以記錄任意狀態——合約的變數、NFT 的所有權、DAO 的投票結果、DeFi 協議的借貸關係。這個抽象層級的提升，使得區塊鏈從單一的支付用途擴展到了幾乎無限的應用場景。</p>
<p>EVM（Ethereum Virtual Machine）是以太坊的核心執行引擎。它是一個基於堆疊的虛擬機，所有節點執行相同的位元組碼，確保狀態轉換的確定性。EVM 的設計有幾個關鍵特點：(1) 完全沙箱化——合約無法存取檔案系統或網路；(2) 確定性——相同輸入永遠產生相同輸出（不允許浮點數、隨機數等非確定性操作）；(3) 可計量——每個操作都有明確的 Gas 消耗。</p>
<pre><code class="language-text">以太坊架構概覽：

┌─────────────────────────────────────────────┐
│                  使用者/DApp                    │
└──────────────────────┬──────────────────────┘
                       │ JSON-RPC
┌──────────────────────v──────────────────────┐
│              以太坊節點 (Geth/Reth)            │
├─────────────────────────────────────────────┤
│  ┌─────────┐  ┌──────────┐  ┌────────────┐ │
│  │ 交易池   │  │ EVM 執行  │  │ 共識引擎    │ │
│  │ (Mempool)│  │  Engine   │  │(Beacon)    │ │
│  └────┬────┘  └─────┬────┘  └─────┬──────┘ │
│       │             │             │         │
│  ┌────v─────────────v─────────────v──────┐  │
│  │           State Database               │  │
│  │  (LevelDB / PebbleDB / MDBX)          │  │
│  └────────────────────────────────────────┘  │
├─────────────────────────────────────────────┤
│              P2P Network (devp2p)            │
└─────────────────────────────────────────────┘
</code></pre>
<p>Gas 機制是以太坊防止 DoS 攻擊和資源濫用的核心設計。每個 EVM 操作碼都有固定的 Gas 消耗——ADD 花 3 Gas，SSTORE（寫入存儲）花 20000 Gas，創建合約花至少 32000 Gas。使用者在發送交易時指定 Gas Limit（最多願意消耗的 Gas）和 Gas Price（每單位 Gas 的價格）。如果執行過程中 Gas 耗盡，交易失敗但手續費不退。這個設計確保了即使合約有無限迴圈，也不會讓網路癱瘓。</p>
<h3 id="512-智能合約-p0"><a class="header" href="#512-智能合約-p0">5.1.2 智能合約 <code>P0</code></a></h3>
<p>智能合約是鏈上狀態機：</p>
<ul>
<li>狀態（storage）</li>
<li>轉移函數（function）</li>
<li>外部觀測（event）</li>
</ul>
<p>智能合約的概念最早由 Nick Szabo 在 1994 年提出，但直到以太坊才真正實現。你可以把智能合約理解為「住在區塊鏈上的程式」——它有自己的地址、餘額和存儲空間，一旦部署就永久存在於鏈上，任何人都可以按照預定的規則與它互動。</p>
<pre><code class="language-text">智能合約狀態機模型：

┌─────────────────────────────┐
│      Smart Contract          │
│                              │
│  State (Storage):            │
│  ┌─────────────────────┐    │
│  │ owner: 0xABC...     │    │
│  │ balance: 1000 USDC  │    │
│  │ totalSupply: 10000  │    │
│  └─────────────────────┘    │
│                              │
│  Functions:                  │
│  ┌─────────────────────┐    │
│  │ transfer(to, amount)│───&gt;│ 修改 state
│  │ approve(spender)    │───&gt;│ 修改 state
│  │ balanceOf(addr)     │───&gt;│ 只讀 (view)
│  └─────────────────────┘    │
│                              │
│  Events:                     │
│  ┌─────────────────────┐    │
│  │ Transfer(from,to,v) │───&gt;│ 寫入 log（不佔 storage）
│  │ Approval(owner,sp)  │    │
│  └─────────────────────┘    │
└─────────────────────────────┘
</code></pre>
<p>以 Solidity 為例，一個簡單的代幣合約展示了智能合約的核心結構：</p>
<pre><code class="language-solidity">// 簡化的 ERC-20 代幣合約
contract SimpleToken {
    // State（存儲在鏈上）
    mapping(address =&gt; uint256) public balances;
    uint256 public totalSupply;

    // Event（鏈上日誌，供外部系統索引）
    event Transfer(address indexed from, address indexed to, uint256 value);

    // Function（狀態轉移函數）
    function transfer(address to, uint256 amount) external {
        require(balances[msg.sender] &gt;= amount, "Insufficient balance");
        balances[msg.sender] -= amount;
        balances[to] += amount;
        emit Transfer(msg.sender, to, amount);
    }
}
</code></pre>
<p>風險面：</p>
<ul>
<li>不可逆部署</li>
<li>外部調用風險</li>
<li>升級與權限治理</li>
</ul>
<p><strong>不可逆部署</strong>意味著合約一旦上鏈就無法修改。如果合約存在 bug，唯一的「修復」方式是部署新合約並遷移狀態。2016 年的 The DAO 事件就是最著名的案例——一個遞迴調用漏洞導致 360 萬 ETH（當時約 5000 萬美元）被盜，最終社群不得不透過硬分叉來回滾交易，這直接導致了以太坊（ETH）和以太坊經典（ETC）的分裂。</p>
<p><strong>外部調用風險</strong>是智能合約安全中最常見的問題。Reentrancy（重入攻擊）就是典型例子：合約 A 在轉帳給合約 B 時，B 的 fallback 函數可以在 A 更新狀態之前再次調用 A 的提款函數。防禦方式包括：(1) Check-Effects-Interactions 模式——先檢查條件、更新狀態、最後才做外部調用；(2) 使用 ReentrancyGuard 鎖；(3) 使用 pull 而非 push 模式進行轉帳。</p>
<p><strong>升級模式</strong>是現代合約開發的必備知識。常見的升級模式有 Proxy Pattern（透明代理、UUPS）和 Diamond Pattern（EIP-2535）。代理模式的核心思想是：使用者互動的合約地址不變（proxy），但實際邏輯可以指向新的實作合約。這帶來了便利但也引入了信任問題——誰有權升級？多簽？時間鎖？治理投票？</p>
<h3 id="513-外部帳戶與合約帳戶-p0"><a class="header" href="#513-外部帳戶與合約帳戶-p0">5.1.3 外部帳戶與合約帳戶 <code>P0</code></a></h3>
<ul>
<li>EOA：私鑰控制，主動發起交易</li>
<li>Contract Account：程式碼控制，被交易或合約調用觸發</li>
</ul>
<p>工程差異：</p>
<ul>
<li>EOA 有 nonce</li>
<li>合約無私鑰，只能按程式規則執行</li>
</ul>
<p>以太坊的帳戶模型與比特幣的 UTXO 模型有根本性的不同。在以太坊中，每個地址對應一個帳戶，帳戶有四個欄位：nonce（交易計數）、balance（ETH 餘額）、codeHash（合約程式碼的 hash，EOA 為空）、storageRoot（合約存儲的 Merkle root，EOA 為空）。</p>
<pre><code class="language-text">帳戶類型對比：

┌────────────────────────┬────────────────────────┐
│     EOA (外部帳戶)       │   Contract Account      │
├────────────────────────┼────────────────────────┤
│ 由私鑰控制              │ 由程式碼控制              │
│ 可主動發起交易           │ 只能被動觸發             │
│ 沒有程式碼              │ 有程式碼（不可變）        │
│ 沒有 storage            │ 有 storage               │
│ nonce = 交易數量        │ nonce = 創建合約數量      │
│ 建立成本: 免費           │ 建立成本: 部署 Gas        │
├────────────────────────┼────────────────────────┤
│ 地址 = keccak256(pubKey)│ 地址 = keccak256(        │
│        取最後 20 bytes   │   sender, nonce) 或      │
│                         │   CREATE2 確定性地址      │
└────────────────────────┴────────────────────────┘
</code></pre>
<p>**Account Abstraction（帳戶抽象）**是以太坊近年來最重要的改進方向之一。ERC-4337 允許用戶使用智能合約錢包（而非 EOA）作為主要帳戶，從而支持社交恢復、多簽授權、Gas 代付、批量交易等功能。這對用戶體驗的提升是巨大的——用戶不再需要保管助記詞，也不需要事先持有 ETH 來支付 Gas。</p>
<p>工程上需要注意的一個陷阱是 <code>tx.origin</code> vs <code>msg.sender</code> 的區分。<code>tx.origin</code> 永遠是發起交易的 EOA 地址，而 <code>msg.sender</code> 是直接的調用者（可能是另一個合約）。用 <code>tx.origin</code> 做權限檢查是一個經典的安全漏洞，因為攻擊者可以透過中間合約來繞過檢查。</p>
<h3 id="514-世界狀態樹-p0"><a class="header" href="#514-世界狀態樹-p0">5.1.4 世界狀態樹 <code>P0</code></a></h3>
<p>以太坊主要樹結構：</p>
<ul>
<li>State Trie：帳戶狀態</li>
<li>Transactions Trie：區塊交易</li>
<li>Receipts Trie：交易結果</li>
</ul>
<p>作用：</p>
<ul>
<li>狀態可驗證</li>
<li>區塊摘要可快速校驗</li>
</ul>
<p>以太坊使用 Modified Merkle Patricia Trie（MPT）作為核心資料結構。與比特幣簡單的 Merkle Tree 不同，MPT 是一種鍵值對存儲結構，支持高效的查詢、插入和刪除操作，同時保持 Merkle 的可驗證性。</p>
<pre><code class="language-text">以太坊的三棵樹：

Block Header
├── stateRoot ──────────&gt; State Trie
│                         (所有帳戶的當前狀態)
│                         Key: 帳戶地址
│                         Value: [nonce, balance, storageRoot, codeHash]
│
├── transactionsRoot ───&gt; Transactions Trie
│                         (本區塊的所有交易)
│                         Key: 交易索引 (RLP encoded)
│                         Value: 交易資料
│
└── receiptsRoot ───────&gt; Receipts Trie
                          (本區塊所有交易的執行結果)
                          Key: 交易索引
                          Value: [status, gasUsed, logs[], ...]
</code></pre>
<p><strong>State Trie</strong> 是最重要也最龐大的一棵樹。它記錄了以太坊網路中每個帳戶的當前狀態。每當一筆交易被執行，State Trie 就會被更新——修改的帳戶對應的路徑會產生新的節點，而未修改的部分則保持不變（結構共享）。這種設計使得每個區塊只需要存儲「差異」而非完整狀態，大幅節省了存儲空間。</p>
<p>MPT 的工程挑戰主要在效能方面。由於 trie 的深度可以很大（以太坊地址是 20 bytes = 40 hex chars），一次狀態讀取可能需要多次磁碟 I/O。以太坊客戶端使用了大量的快取和資料庫優化來緩解這個問題。Geth 的 snap sync 和 path-based storage 都是針對 MPT 效能問題的改進。更激進的方案是 Verkle Tree——使用向量承諾（vector commitment）替代 hash，將 proof 大小從 O(log N) 降低到 O(1)，這是以太坊路線圖中的重要里程碑。</p>
<pre><code class="language-text">Modified Merkle Patricia Trie 結構示意：

                    Root
                   /    \
              [0x1]      [0x7]
             /    \         \
         [0x1A]  [0x1F]    [0x7B]
          /                   \
      [0x1A3F]              [0x7B2C]
         |                     |
    Account A             Account B
    {nonce: 5,            {nonce: 0,
     balance: 10 ETH,     balance: 100 ETH,
     storageRoot: ...,    storageRoot: ...,
     codeHash: ...}       codeHash: 0x0}
</code></pre>
<h3 id="515-以太坊經濟體-p0"><a class="header" href="#515-以太坊經濟體-p0">5.1.5 以太坊經濟體 <code>P0</code></a></h3>
<p>經濟結構關鍵：</p>
<ul>
<li>EIP-1559：base fee + priority fee</li>
<li>PoS 質押與懲罰</li>
<li>MEV 對排序與收益分配的影響</li>
</ul>
<p><strong>EIP-1559</strong>（2021 年 8 月倫敦升級引入）是以太坊手續費機制的重大改革。在此之前，以太坊使用簡單的「第一價格拍賣」——用戶出價越高越容易被打包，但這導致了嚴重的 Gas 價格波動和用戶體驗問題。EIP-1559 引入了雙層費率結構：</p>
<pre><code class="language-text">EIP-1559 費率結構：

┌──────────────────────────────────────────┐
│ 用戶支付的總手續費 =                        │
│   Base Fee (協議決定，動態調整) +            │
│   Priority Fee (用戶設定，給驗證者的小費)      │
├──────────────────────────────────────────┤
│                                          │
│ Base Fee:                                │
│ - 由協議根據區塊使用率自動調整              │
│ - 區塊 &gt; 50% 滿 → base fee 上升           │
│ - 區塊 &lt; 50% 滿 → base fee 下降           │
│ - 每區塊最多變動 12.5%                     │
│ - Base Fee 被銷毀（burn）！                │
│                                          │
│ Priority Fee (tip):                      │
│ - 用戶自行設定                             │
│ - 直接支付給區塊驗證者                     │
│ - 用於在同一區塊內的交易優先排序            │
└──────────────────────────────────────────┘
</code></pre>
<p>Base Fee 的銷毀機制（burn）是一個精妙的經濟設計。ETH 的總供應量不再只增不減——當網路使用量高時，銷毀的 ETH 可能超過新發行的 ETH，使 ETH 成為通縮資產。2022 年 The Merge 之後，ETH 的年發行率從 PoW 時代的約 4.3% 降至 PoS 的約 0.5%，加上 EIP-1559 的銷毀，ETH 在高使用量時期確實出現了淨通縮。</p>
<p><strong>PoS 質押經濟</strong>在 The Merge（2022 年 9 月）後成為以太坊安全的基礎。驗證者需要質押 32 ETH 才能參與共識。誠實的驗證者獲得出塊獎勵和 attestation 獎勵（年化約 3-5%）；惡意行為則被 slashing——例如 double voting（同一 slot 投票給兩個不同區塊）或 surround voting 會導致質押被部分或全部沒收。</p>
<p>**MEV（Maximal Extractable Value）**是以太坊經濟中一個複雜且影響深遠的現象。驗證者（或更精確地說，區塊建構者）可以透過重新排序、插入或刪除交易來獲取額外收益。典型的 MEV 策略包括：</p>
<pre><code class="language-text">MEV 常見策略：

1. 三明治攻擊 (Sandwich Attack):
   用戶提交: swap 10 ETH → USDC
   攻擊者:
   ├── Tx1: 先買入大量 USDC（推高價格）
   ├── 用戶 Tx: 以更高價格買入（用戶多付了）
   └── Tx2: 攻擊者賣出 USDC（獲利）

2. 清算搶跑 (Liquidation Front-running):
   DeFi 借貸協議中，有人的抵押品不足
   → 攻擊者搶先執行清算，獲得清算獎勵

3. 套利 (Arbitrage):
   DEX A 上 ETH = $2000
   DEX B 上 ETH = $2010
   → 在 A 買入，在 B 賣出，淨賺 $10
</code></pre>
<p>工程要點：</p>
<ul>
<li>交易策略需適配動態費率</li>
<li>高價值交易需防 MEV 與重排</li>
</ul>
<p>為了緩解 MEV 的負面影響，以太坊生態發展出了 MEV-Boost 系統——驗證者將區塊建構權外包給專業的 block builder，builder 透過 relay 提交區塊，驗證者選擇收益最高的區塊進行提議。這種 Proposer-Builder Separation（PBS）的設計將 MEV 的提取規範化，減少了驗證者直接進行時間敏感操作的需求，但也引入了新的中心化風險（少數 builder 佔據大部分區塊建構）。</p>
<h2 id="52-區塊鏈的共識演算法-p0"><a class="header" href="#52-區塊鏈的共識演算法-p0">5.2 區塊鏈的共識演算法 <code>P0</code></a></h2>
<h3 id="521-pos原理-p0"><a class="header" href="#521-pos原理-p0">5.2.1 PoS原理 <code>P0</code></a></h3>
<p>PoS 由質押權益決定提議/驗證權：</p>
<ul>
<li>誠實參與獲得收益</li>
<li>惡意行為可被 slash</li>
</ul>
<p>優點：低能源消耗、最終性更快。</p>
<p>Proof of Stake（權益證明）是目前最主流的共識機制。與 PoW 使用計算能力來決定出塊權不同，PoS 使用經濟質押——驗證者鎖定一定數量的代幣作為「保證金」，然後被協議隨機選中來提議或驗證區塊。誠實行為獲得獎勵，惡意行為則面臨質押被罰沒的風險。</p>
<p>以太坊的 PoS 實作（Gasper = Casper FFG + LMD-GHOST）是目前最複雜的 PoS 系統之一。它的工作流程如下：</p>
<pre><code class="language-text">以太坊 PoS 共識流程：

時間軸:
├── Slot 0 (12秒) ──── Slot 1 ──── Slot 2 ──── ... ──── Slot 31 ──┤
│                                                                    │
└──────────────────── Epoch (32 slots = 6.4 分鐘) ──────────────────┘

每個 Slot:
1. 一位驗證者被隨機選為 Proposer → 提議區塊
2. 一組驗證者（Committee）被選為 Attester → 對區塊投票

每個 Epoch 結束:
- Casper FFG 嘗試 finalize（最終確定）checkpoint
- 需要 2/3 的驗證者投票同意
- 一旦 finalized → 該區塊及之前的歷史不可逆轉

Slashing 條件:
├── Double voting: 同一 slot 投票給兩個不同區塊
└── Surround voting: attestation 範圍包含另一個 attestation
    → 質押被沒收（最少 1/32 ~ 最多全部）
    → 被強制退出驗證者集合
</code></pre>
<p>PoS 相比 PoW 的優勢不僅在於能源消耗。PoS 可以提供<strong>經濟最終性</strong>——一旦區塊被 finalized，要逆轉它需要至少 1/3 的質押被罰沒。這比 PoW 的機率最終性要強得多。在以太坊上，交易通常在 2 個 epoch（約 12.8 分鐘）後被 finalized。</p>
<p>PoS 的主要挑戰包括：(1) <strong>Nothing at Stake 問題</strong>——在 PoW 中，礦工只能在一條鏈上挖礦（因為算力有限），但在 PoS 中，驗證者可以在多條分叉上同時投票（因為投票幾乎沒有成本）。Casper 透過 slashing 來解決這個問題。(2) <strong>Long Range Attack</strong>——攻擊者取得舊的私鑰（對應已退出的驗證者），從很久以前的區塊開始建立替代鏈。防禦方式是 weak subjectivity checkpoint——新節點需要從可信來源獲取最近的 checkpoint。(3) <strong>質押中心化</strong>——Lido 等流動性質押協議佔據了大量質押份額，引發了去中心化的擔憂。</p>
<h3 id="522-dpos原理-p1"><a class="header" href="#522-dpos原理-p1">5.2.2 DPoS原理 <code>P1</code></a></h3>
<p>DPoS 透過持幣人投票選出代表節點。</p>
<p>優點：性能與治理效率高。
代價：權力更集中，治理博弈更明顯。</p>
<p>Delegated Proof of Stake（委託權益證明）是 Daniel Larimer 在 2014 年提出的共識機制，最初應用於 BitShares，後來在 EOS、TRON 等公鏈中廣泛採用。DPoS 的核心思想是「代議制」——持幣人不直接參與共識，而是投票選出一組代表（通常稱為 block producer 或 witness），由這些代表輪流出塊。</p>
<pre><code class="language-text">DPoS 運作模型：

持幣者投票:
┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐
│User A│ │User B│ │User C│ │User D│ ...
└──┬───┘ └──┬───┘ └──┬───┘ └──┬───┘
   │        │        │        │
   v        v        v        v
┌────────────────────────────────────┐
│         投票池 (按質押權重)          │
└───────────────┬────────────────────┘
                │ 選出 Top 21 (以 EOS 為例)
                v
   ┌────┐ ┌────┐ ┌────┐     ┌────┐
   │BP 1│ │BP 2│ │BP 3│ ... │BP21│
   └──┬─┘ └──┬─┘ └──┬─┘     └──┬─┘
      │      │      │          │
      v      v      v          v
   Block 1  Block 2  Block 3  ...  (輪流出塊)
</code></pre>
<p>DPoS 的性能優勢來自於其較少的共識參與者數量。當只有 21 個節點需要達成共識時，通訊複雜度從 PoS 的 O(N^2) 降低到了可管理的範圍，出塊時間可以低至 0.5 秒。EOS 曾經宣稱達到 4000+ TPS 的處理能力。</p>
<p>然而，DPoS 的去中心化程度一直受到質疑。投票往往被大戶把持，形成了「寡頭政治」——EOS 的 21 個超級節點中，很多都來自同一利益集團。此外，投票冷漠是另一個問題——大多數持幣者不參與投票，導致少數積極投票者擁有不成比例的影響力。這些治理問題提醒我們：共識機制不僅是技術選擇，更是社會制度設計。</p>
<h3 id="523-pbft原理-p1"><a class="header" href="#523-pbft原理-p1">5.2.3 PBFT原理 <code>P1</code></a></h3>
<p>PBFT 適合節點數較少、身份可管理場景（常見於聯盟鏈）。</p>
<p>特點：</p>
<ul>
<li>快速確定性最終性</li>
<li>通訊複雜度較高</li>
</ul>
<p>Practical Byzantine Fault Tolerance（實用拜占庭容錯）由 Miguel Castro 和 Barbara Liskov 在 1999 年提出。它是第一個在實際環境中可行的 BFT 演算法。PBFT 可以容忍最多 f 個惡意節點（在總共 3f+1 個節點中），並保證只要惡意節點不超過 1/3，系統就能正確運作並達成共識。</p>
<pre><code class="language-text">PBFT 三階段協議：

Client         Primary        Replica 1      Replica 2      Replica 3
  |               |               |               |               |
  |--- Request --&gt;|               |               |               |
  |               |               |               |               |
  |               |== Pre-prepare ================================&gt;|
  |               |               |               |               |
  |               |&lt;============= Prepare ========================&gt;|
  |               |               |               |               |
  |               |&lt;============= Commit =========================&gt;|
  |               |               |               |               |
  |&lt;== Reply =====================================================|
  |               |               |               |               |

三階段:
1. Pre-prepare: Primary 對請求排序並廣播
2. Prepare: 節點確認排序，收到 2f+1 個 prepare 進入 prepared 狀態
3. Commit: 節點確認已 prepared，收到 2f+1 個 commit 後執行

容錯能力: 3f+1 個節點可容忍 f 個惡意節點
通訊複雜度: O(N^2) — 每階段每個節點都要與所有其他節點通訊
</code></pre>
<p>PBFT 的最大優勢是<strong>確定性最終性</strong>——一旦交易被確認，就不會被逆轉（除非超過 1/3 的節點是惡意的）。這與 PoW 的機率最終性形成鮮明對比。對於金融機構等需要即時確認的場景，這個特性非常重要。</p>
<p>PBFT 的主要限制在於<strong>可擴展性</strong>。O(N^2) 的通訊複雜度意味著當節點數量增加時，網路流量會急劇上升。在實踐中，PBFT 通常只適用於數十個節點的場景。這也是為什麼 PBFT 主要用於聯盟鏈——參與者數量有限且身份已知。Hyperledger Fabric、Tendermint（Cosmos 的共識引擎）都使用了 PBFT 的變體。</p>
<p>現代 BFT 共識演算法（如 HotStuff、Jolteon、Bullshark）在 PBFT 的基礎上做了重要改進，將通訊複雜度從 O(N^2) 降低到 O(N)，使得更大規模的驗證者集合成為可能。HotStuff 被 Facebook（Meta）的 Diem 項目採用，後來也影響了 Aptos 和 Sui 的共識設計。</p>
<h2 id="53-區塊鏈的技術方向"><a class="header" href="#53-區塊鏈的技術方向">5.3 區塊鏈的技術方向</a></h2>
<h3 id="531-跨鏈-p0"><a class="header" href="#531-跨鏈-p0">5.3.1 跨鏈 <code>P0</code></a></h3>
<p>跨鏈核心是「在鏈 A 驗證鏈 B 的事件」：</p>
<ul>
<li>鎖鑄（lock-mint）</li>
<li>燒釋（burn-release）</li>
<li>訊息橋（message bridge）</li>
</ul>
<p>跨鏈技術解決的是區塊鏈生態的「孤島問題」。每條區塊鏈都是一個獨立的信任域，它們之間無法直接通訊。你在以太坊上的 ETH 不能直接在 Solana 上使用，Cosmos 上的 ATOM 也不能直接在 Polkadot 上交易。跨鏈橋的出現使得資產和資訊可以在不同鏈之間流動。</p>
<pre><code class="language-text">跨鏈橋基本架構：

Lock-and-Mint 模式 (最常見):

Chain A                     Bridge                    Chain B
┌───────────┐         ┌──────────────┐         ┌───────────┐
│           │  Lock    │              │  Mint    │           │
│  User 鎖定 │────────&gt;│  Relayer/    │────────&gt;│ User 收到  │
│  10 ETH   │         │  Oracle 驗證  │         │ 10 wETH   │
│  到 Bridge │         │  並轉發證明   │         │(wrapped)  │
│  Contract  │         │              │         │           │
└───────────┘         └──────────────┘         └───────────┘

返回流程 (Burn-and-Release):
Chain B: Burn 10 wETH → Bridge 驗證 → Chain A: Release 10 ETH
</code></pre>
<p>安全重點：</p>
<ul>
<li>驗證者模型</li>
<li>最終性假設</li>
<li>重放與重組處理</li>
</ul>
<p>跨鏈橋的安全性是區塊鏈領域最大的工程挑戰之一。2022 年是跨鏈橋安全的災難年——Wormhole 被盜 3.2 億美元（偽造簽名）、Ronin Bridge 被盜 6.25 億美元（私鑰洩露）、Nomad Bridge 被盜 1.9 億美元（驗證邏輯 bug）。Vitalik Buterin 曾指出，跨鏈橋的安全上限受限於它所依賴的最弱信任假設。</p>
<pre><code class="language-text">跨鏈橋安全模型對比：

┌─────────────┬──────────────┬──────────────┬──────────────┐
│ 驗證模型     │ 信任假設      │ 安全性       │ 代表項目      │
├─────────────┼──────────────┼──────────────┼──────────────┤
│ 多簽        │ N/M 簽名者    │ 低           │ Ronin        │
│             │ 誠實          │              │              │
├─────────────┼──────────────┼──────────────┼──────────────┤
│ Oracle/     │ 外部驗證者    │ 中           │ LayerZero    │
│ Relayer     │ 集合誠實      │              │              │
├─────────────┼──────────────┼──────────────┼──────────────┤
│ Light       │ 源鏈共識      │ 高           │ IBC          │
│ Client      │ 安全          │              │ (Cosmos)     │
├─────────────┼──────────────┼──────────────┼──────────────┤
│ ZK Proof    │ 數學正確性    │ 最高         │ zkBridge,    │
│             │              │              │ Succinct     │
└─────────────┴──────────────┴──────────────┴──────────────┘
</code></pre>
<p>工程上最安全的跨鏈方式是 <strong>Light Client 驗證</strong>：在目標鏈上運行源鏈的輕客戶端，直接驗證源鏈的共識證明。Cosmos 的 IBC（Inter-Blockchain Communication）協議就是這個思路。更先進的方案是用 <strong>ZK Proof</strong> 來壓縮驗證——在目標鏈上驗證一個 ZK 證明，該證明證明了源鏈的共識正確性。這可以大幅降低鏈上驗證的 Gas 消耗。</p>
<h3 id="532-同態加密-p1"><a class="header" href="#532-同態加密-p1">5.3.2 同態加密 <code>P1</code></a></h3>
<p>同態加密允許在密文上計算，潛力在隱私計算與機構協作。</p>
<p>限制：</p>
<ul>
<li>計算與延遲成本高</li>
<li>通用場景尚需工程折衷</li>
</ul>
<p>同態加密（Homomorphic Encryption, HE）是密碼學中的「聖杯」之一。它允許在不解密的情況下對加密資料進行計算，計算結果解密後與在明文上計算的結果相同。用數學表示：E(a) + E(b) = E(a+b)，其中 E 是加密函數。</p>
<pre><code class="language-text">同態加密原理：

傳統計算:
  明文資料 → 計算 → 結果
  (資料可見，隱私風險)

同態加密計算:
  明文 → 加密 → 密文資料 → 在密文上計算 → 密文結果 → 解密 → 明文結果
  (計算過程中資料始終加密，第三方看不到原始資料)

類型:
┌────────────────────┬───────────────┬────────────┐
│ 類型                │ 支持的操作     │ 效能        │
├────────────────────┼───────────────┼────────────┤
│ 部分同態 (PHE)      │ 只支持加法或   │ 快          │
│                     │ 只支持乘法     │             │
├────────────────────┼───────────────┼────────────┤
│ 有限同態 (SHE)      │ 有限次加法+    │ 中等        │
│                     │ 乘法           │             │
├────────────────────┼───────────────┼────────────┤
│ 全同態 (FHE)        │ 任意次數的     │ 非常慢      │
│                     │ 加法+乘法      │ (10^4-10^6x)│
└────────────────────┴───────────────┴────────────┘
</code></pre>
<p>在區塊鏈中，FHE 的應用場景包括：(1) <strong>隱私 DeFi</strong>——在不暴露交易金額的情況下執行借貸和交易邏輯；(2) <strong>隱私投票</strong>——在不暴露個別投票的情況下計算投票結果；(3) <strong>機構協作</strong>——多個機構共享加密資料進行聯合計算。Zama 的 fhEVM 專案就是嘗試將 FHE 整合到 EVM 中，使得智能合約可以在加密狀態上進行計算。</p>
<p>然而，FHE 的效能問題仍然是最大的工程障礙。目前全同態加密的計算開銷約為明文計算的 10,000 到 1,000,000 倍。雖然硬體加速（如專用 ASIC）和演算法改進正在持續推進，但距離大規模生產環境的應用還有相當距離。工程上的折衷方案是混合使用——只在必要的部分使用同態加密，其餘部分使用傳統技術。</p>
<h3 id="533-零知識證明-p0"><a class="header" href="#533-零知識證明-p0">5.3.3 零知識證明 <code>P0</code></a></h3>
<p>ZK 用於「證明我知道答案且答案正確，但不暴露細節」。</p>
<p>主流方向：</p>
<ul>
<li>zk-SNARK</li>
<li>zk-STARK</li>
</ul>
<p>零知識證明（Zero-Knowledge Proof, ZKP）是現代密碼學中最強大的工具之一。它允許證明者（prover）向驗證者（verifier）證明一個陳述是真的，而不暴露任何除了「陳述為真」以外的資訊。</p>
<p>一個經典的類比：你想向朋友證明你知道某個迷宮的解法，但不想告訴他具體路線。你讓朋友先離開，你走到迷宮的出口等他。朋友回來後看到你在出口——他確信你知道解法，但完全不知道你走的是哪條路。</p>
<pre><code class="language-text">ZK Proof 運作流程：

Prover (證明者)              Verifier (驗證者)
    |                             |
    |  1. 我知道一個 x,            |
    |     使得 hash(x) = Y        |
    |                             |
    |  2. 生成 ZK Proof π         |
    |     (不暴露 x 的值)          |
    |                             |
    |--- 發送 proof π -----------&gt;|
    |                             |
    |                    3. 驗證 π |
    |                       (只需 Y 和 π)
    |                       不需要知道 x
    |                             |
    |               驗證通過 ✓     |
    |   (驗證者確信 x 存在，       |
    |    但完全不知道 x 是什麼)     |


zk-SNARK vs zk-STARK 對比：

┌──────────────┬─────────────────┬─────────────────┐
│              │ zk-SNARK         │ zk-STARK         │
├──────────────┼─────────────────┼─────────────────┤
│ Proof 大小    │ ~200 bytes      │ ~50-200 KB       │
│ 驗證時間      │ ~ms             │ ~ms              │
│ 證明時間      │ 秒-分鐘         │ 秒-分鐘          │
│ Trusted Setup│ 需要 ❗          │ 不需要 ✅         │
│ 量子安全      │ 否              │ 是               │
│ 代表項目      │ Groth16,        │ StarkNet,        │
│              │ PLONK            │ STARK prover     │
└──────────────┴─────────────────┴─────────────────┘
</code></pre>
<p>工程用途：</p>
<ul>
<li>L2 validity proof</li>
<li>隱私轉帳</li>
<li>身份最小揭露</li>
</ul>
<p><strong>L2 Validity Proof</strong> 是 ZK 技術目前最重要的應用。ZK Rollup 在鏈下執行大量交易，然後生成一個 ZK Proof 提交到 L1。L1 合約只需要驗證這個 proof（消耗很少的 Gas），就能確信所有鏈下交易都被正確執行了。這使得 L2 可以在繼承 L1 安全性的前提下，將吞吐量提升數百倍。</p>
<p><strong>隱私轉帳</strong>是 ZK 的另一個重要應用。Zcash 使用 zk-SNARK 來隱藏交易的發送者、接收者和金額。Tornado Cash 使用 ZK 來實現以太坊上的混幣器——用戶存入固定金額的 ETH，稍後從不同地址提取，ZK Proof 證明提取者確實曾經存入過，但不暴露是哪次存入。</p>
<p><strong>身份最小揭露</strong>是 ZK 的新興應用方向。例如，你想證明自己年滿 18 歲，但不想暴露出生日期。透過 ZK Proof，你可以生成一個證明：「我持有一份有效的身份文件，其中的出生日期早於 18 年前」，而不暴露身份文件的任何其他資訊。Worldcoin 的 World ID 和 Polygon ID 都在探索這個方向。</p>
<h3 id="534-二層網絡layer2-p0"><a class="header" href="#534-二層網絡layer2-p0">5.3.4 二層網絡（Layer2） <code>P0</code></a></h3>
<p>L2 目標：降低費用、提高吞吐，同時繼承 L1 安全。</p>
<p>主流：</p>
<ul>
<li>Optimistic Rollup</li>
<li>ZK Rollup</li>
</ul>
<pre><code class="language-text">User Tx -&gt; L2 Sequencer -&gt; Batch/Proof -&gt; L1 Settlement
</code></pre>
<p>Layer 2 是解決區塊鏈「不可能三角」（去中心化、安全性、可擴展性三者不可兼得）的核心技術路徑。L2 的基本思想是：將大量交易的「執行」移到鏈下，但將「驗證」和「資料可用性」留在 L1。這樣 L2 繼承了 L1 的安全性，但不受 L1 吞吐量的限制。</p>
<pre><code class="language-text">L2 架構全景：

┌─────────────────────────────────────────────────────────┐
│                     Layer 2                              │
│                                                          │
│  ┌──────────────────────┐  ┌──────────────────────────┐ │
│  │  Optimistic Rollup    │  │      ZK Rollup            │ │
│  ├──────────────────────┤  ├──────────────────────────┤ │
│  │ - 先假設交易有效       │  │ - 每批交易附帶 ZK Proof   │ │
│  │ - 7天挑戰期           │  │ - 數學保證交易正確性      │ │
│  │ - 有人挑戰成功        │  │ - 無需等待挑戰期         │ │
│  │   → 交易被撤銷        │  │ - 即時確認               │ │
│  │ - 代表: Arbitrum,     │  │ - 代表: zkSync,          │ │
│  │   Optimism, Base      │  │   StarkNet, Scroll       │ │
│  └──────────────────────┘  └──────────────────────────┘ │
│                                                          │
│  ┌──────────────────────────────────────────────────┐   │
│  │                  Sequencer                         │   │
│  │  - 接收用戶交易                                    │   │
│  │  - 排序並執行                                      │   │
│  │  - 批量提交到 L1                                   │   │
│  │  - 目前多為中心化（去中心化 sequencer 進行中）       │   │
│  └──────────────────────────────────────────────────┘   │
└───────────────────────────┬─────────────────────────────┘
                            │ Batch / Proof / DA
                            v
┌─────────────────────────────────────────────────────────┐
│                   Layer 1 (Ethereum)                     │
│  - 驗證 proof 或處理挑戰                                  │
│  - 存儲交易資料（data availability）                       │
│  - 提供最終結算                                           │
└─────────────────────────────────────────────────────────┘
</code></pre>
<p><strong>Optimistic Rollup</strong> 的工作原理是「樂觀假設」：先假設所有提交到 L1 的交易批次都是正確的。如果有人發現錯誤，可以在挑戰期（通常 7 天）內提交「fraud proof」（欺詐證明）。如果 fraud proof 被 L1 合約驗證為有效，錯誤的批次會被回滾，惡意的 sequencer 被罰沒。這種設計的優勢是技術實現相對簡單（不需要 ZK 電路），劣勢是提款到 L1 需要等待 7 天的挑戰期。</p>
<p><strong>ZK Rollup</strong> 則是每次提交批次時都附帶一個 ZK Proof，數學證明所有交易都被正確執行。L1 合約只需要驗證這個 proof（幾十萬 Gas），就能確信整個批次的正確性。ZK Rollup 不需要挑戰期，提款可以在 proof 被驗證後立即完成。但 ZK Rollup 的開發難度更高——需要將 EVM 的所有操作轉換為 ZK 電路（即 zkEVM），這是一項巨大的工程挑戰。</p>
<p>工程上需要特別關注的是 <strong>Sequencer 的中心化問題</strong>。目前大多數 L2（Arbitrum、Optimism、zkSync）的 sequencer 都是中心化的——由項目方運行單一的 sequencer 節點。這意味著 sequencer 可以審查交易、提取 MEV、甚至暫停服務。去中心化 sequencer 是各個 L2 項目的長期目標，但實現起來面臨排序公平性、延遲要求、激勵設計等多重挑戰。作為工程折衷，許多 L2 提供了「強制包含」機制——即使 sequencer 不合作，用戶也可以直接向 L1 提交交易。</p>
<h3 id="535-nft-p1"><a class="header" href="#535-nft-p1">5.3.5 NFT <code>P1</code></a></h3>
<p>NFT 是非同質資產標準化表達：</p>
<ul>
<li>ERC-721（單一資產）</li>
<li>ERC-1155（多資產混合）</li>
</ul>
<p>NFT（Non-Fungible Token，非同質化代幣）代表了區塊鏈上獨一無二的數位資產。與 ERC-20 代幣不同（每個 USDC 都是等價可替換的），每個 NFT 都有唯一的 token ID，可以代表不同的資產——數位藝術品、遊戲道具、域名、房地產權證等。</p>
<pre><code class="language-text">ERC-721 vs ERC-1155 對比：

ERC-721 (單一資產):
┌──────────────────────────────────┐
│ Contract: CryptoPunks             │
│ Token #1 → Owner: 0xAAA          │
│ Token #2 → Owner: 0xBBB          │
│ Token #3 → Owner: 0xCCC          │
│ 每個 token 都是獨立的 NFT         │
│ 每次轉移一個                      │
└──────────────────────────────────┘

ERC-1155 (多資產混合):
┌──────────────────────────────────┐
│ Contract: GameItems               │
│ Token ID 1 (劍) → 0xAAA: 3個     │
│                   0xBBB: 1個     │
│ Token ID 2 (盾) → 0xCCC: 5個     │
│ Token ID 3 (限量皮膚) → 0xDDD:1個│
│ 同時支持同質(劍/盾)和非同質(皮膚)  │
│ 可批量轉移，節省 Gas              │
└──────────────────────────────────┘
</code></pre>
<p>工程重點：</p>
<ul>
<li>metadata 存儲策略（鏈上/鏈下）</li>
<li>版權與授權模型</li>
<li>市場流動性與洗售風險</li>
</ul>
<p><strong>Metadata 存儲</strong>是 NFT 工程中最重要的設計決策之一。NFT 的鏈上部分通常只包含 token ID 和一個 <code>tokenURI</code>（指向 metadata 的 URL）。Metadata 本身（名稱、描述、圖片 URL 等）可以存儲在三個地方：(1) 完全鏈上——最去中心化但最昂貴，適合小型 SVG 藝術品；(2) IPFS/Arweave——內容尋址，不可篡改，是目前的最佳實踐；(3) 中心化伺服器——最便宜但項目方可以隨時修改或下線。</p>
<p><strong>常見的 NFT 工程陷阱</strong>包括：(1) metadata 伺服器當機導致 NFT 顯示為空白——OpenSea 上曾多次出現此情況；(2) tokenURI 指向 HTTP URL 而非 IPFS，項目方可以偷偷替換圖片；(3) 合約沒有實現 <code>supportsInterface</code>（EIP-165），導致某些市場無法正確識別 NFT 標準；(4) 未考慮 royalty 標準（EIP-2981），導致二次銷售無法自動收取版稅。</p>
<h2 id="技術原理深度回顧"><a class="header" href="#技術原理深度回顧">技術原理深度回顧</a></h2>
<ul>
<li>Ethereum 提供了可程式化金融基座</li>
<li>共識機制決定了安全與性能上限</li>
<li>跨鏈、ZK、L2 是未來幾年的核心主線</li>
</ul>
<p>以太坊的意義在於它證明了「可程式化區塊鏈」的可行性，並圍繞它建立了一個龐大的開發者生態。從 Solidity 語言到 Hardhat/Foundry 開發框架，從 OpenZeppelin 的安全合約庫到 The Graph 的資料索引，以太坊生態已經形成了完整的開發工具鏈。即使其他 L1（Solana、Avalanche、Sui）在效能上可能更優，以太坊的開發者生態和 DeFi 流動性仍然是其最大的護城河。</p>
<p>共識機制的選擇是區塊鏈架構設計的第一個重大決策。PoW 提供了最強的去中心化和安全性，但犧牲了效能和能源效率。PoS 在安全性和效能之間找到了更好的平衡點。DPoS 和 PBFT 適合對效能要求極高但可以接受較少驗證者的場景。沒有「最好的」共識機制——只有最適合特定需求的共識機制。</p>
<p>跨鏈、ZK 和 L2 三條技術主線正在深度融合。ZK Rollup 本身就是 ZK + L2 的結合。跨鏈橋越來越多地使用 ZK Proof 來提升安全性。模組化架構讓 DA 層、執行層、結算層可以自由組合。未來的區塊鏈系統很可能不是一條單體鏈，而是一個由多個專業化模組組成的網路。</p>
<h2 id="白話總結-17"><a class="header" href="#白話總結-17">白話總結</a></h2>
<p>如果說比特幣是去中心化的「計算機」，以太坊就是去中心化的「智慧型手機」——它不只能做一件事，而是可以跑各種 App。智能合約就像是住在區塊鏈上的小程式，一旦部署就誰也改不了（所以寫 bug 的代價特別大）。Gas 費是你用以太坊要付的「使用費」，EIP-1559 之後這個費用變得更可預測了，而且一部分會被銷毀——就像央行在回收鈔票一樣。PoS 共識讓以太坊不再需要礦工燒電，取而代之的是驗證者押錢來保證誠實。跨鏈橋讓不同區塊鏈能互相「講話」，但橋一直是被駭客盯上的大目標，幾十億美元的損失告訴我們橋的安全設計不能馬虎。ZK 證明大概是密碼學裡最「魔法」的東西——我能證明我知道答案，但你完全不知道答案是什麼。L2 Rollup 就像在以太坊旁邊開了一條快車道，交易在快車道上執行，結果再寫回主鏈，速度快了百倍但安全性一樣。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第6章-區塊鏈技術的發展趨勢"><a class="header" href="#第6章-區塊鏈技術的發展趨勢">第6章 區塊鏈技術的發展趨勢</a></h1>
<p>本章聚焦「落地」：公鏈與聯盟鏈如何選、產業怎麼用、合規如何進系統設計。</p>
<h2 id="61-公鏈與聯盟鏈"><a class="header" href="#61-公鏈與聯盟鏈">6.1 公鏈與聯盟鏈</a></h2>
<h3 id="611-公鏈與聯盟鏈的對比-p1"><a class="header" href="#611-公鏈與聯盟鏈的對比-p1">6.1.1 公鏈與聯盟鏈的對比 <code>P1</code></a></h3>
<p>對比維度：</p>
<ul>
<li>開放性：公鏈高，聯盟鏈中</li>
<li>去中心化：公鏈高，聯盟鏈可控</li>
<li>性能：聯盟鏈通常更高</li>
<li>治理：公鏈社群治理，聯盟鏈機構治理</li>
</ul>
<p>公鏈（Public Blockchain）和聯盟鏈（Consortium Blockchain）是區塊鏈落地的兩條主要路徑，它們的設計哲學有根本性的差異。公鏈追求的是「無許可」（permissionless）——任何人都可以加入網路、發送交易、甚至參與共識，不需要任何人的批准。聯盟鏈則是「有許可」（permissioned）——只有經過授權的機構才能運行節點、參與共識，一般使用者可能需要經過 KYC 才能發送交易。</p>
<pre><code class="language-text">公鏈 vs 聯盟鏈架構對比：

公鏈 (Permissionless):
┌───────────────────────────────────────┐
│  任何人都可以:                         │
│  ├── 運行全節點                       │
│  ├── 發送交易                         │
│  ├── 部署合約                         │
│  └── 參與共識 (質押/挖礦)             │
│                                       │
│  節點數: 數千-數萬                     │
│  TPS: 10-100 (L1), 1000+ (L2)       │
│  最終性: 分鐘級                       │
│  代表: Ethereum, Bitcoin, Solana     │
└───────────────────────────────────────┘

聯盟鏈 (Permissioned):
┌───────────────────────────────────────┐
│  授權機構可以:                         │
│  ├── 運行共識節點 (需批准)             │
│  ├── 管理權限 (RBAC)                  │
│  └── 設定交易規則和隱私策略            │
│                                       │
│  節點數: 數十-數百                     │
│  TPS: 1000-10000+                    │
│  最終性: 秒級 (BFT)                   │
│  代表: Hyperledger Fabric, FISCO BCOS│
└───────────────────────────────────────┘
</code></pre>
<p>選型結論：</p>
<ul>
<li>對外資產流通與生態組合 -&gt; 公鏈</li>
<li>跨機構內部協作與合規主導 -&gt; 聯盟鏈</li>
</ul>
<p>選型決策不是非黑即白的。越來越多的專案採用混合架構——核心業務邏輯在聯盟鏈上運行（高效能、可控、合規），但資產結算或跨生態互動透過公鏈或公鏈上的 L2 進行。例如，某銀行可能在 Hyperledger Fabric 上運行貿易融資流程，但在以太坊上發行代幣化的資產。</p>
<p>工程師在做選型時需要考慮的核心問題包括：(1) 資料是否需要對公眾可見？如果是，公鏈更適合（透明性是內建的）。(2) 是否需要嚴格的身份管理？如果是，聯盟鏈更適合。(3) 性能需求是多少？如果需要高 TPS 且延遲要求嚴格，聯盟鏈更有優勢。(4) 是否需要與現有 DeFi 生態互動？如果是，公鏈是唯一選擇。(5) 監管合規要求是什麼？某些司法管轄區可能要求資料不離境，這時聯盟鏈的私有部署是必要的。</p>
<h3 id="612-常見聯盟鏈平臺-p2"><a class="header" href="#612-常見聯盟鏈平臺-p2">6.1.2 常見聯盟鏈平臺 <code>P2</code></a></h3>
<p>常見平台：</p>
<ul>
<li>Hyperledger Fabric</li>
<li>FISCO BCOS</li>
<li>Quorum</li>
</ul>
<p><strong>Hyperledger Fabric</strong> 是目前最成熟的企業級聯盟鏈平台，由 Linux Foundation 主導，IBM 是最主要的貢獻者。Fabric 的獨特設計在於「Execute-Order-Validate」架構（與傳統區塊鏈的 Order-Execute 不同），以及 Channel 機制——不同的業務可以在不同的 Channel 中運行，實現資料隔離。</p>
<pre><code class="language-text">Hyperledger Fabric 架構：

┌─────────────────────────────────────────────────┐
│                   Application                     │
│                   (SDK/REST)                       │
└────────────────────────┬────────────────────────┘
                         │
┌────────────────────────v────────────────────────┐
│                Peer Nodes                         │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐      │
│  │ Endorser  │  │ Endorser  │  │ Committer │      │
│  │ (Org A)   │  │ (Org B)   │  │ (Org C)   │      │
│  │ +Chaincode│  │ +Chaincode│  │           │      │
│  └──────────┘  └──────────┘  └──────────┘      │
└────────────────────────┬────────────────────────┘
                         │
┌────────────────────────v────────────────────────┐
│              Ordering Service                     │
│         (Raft / Kafka / BFT)                      │
│  負責交易排序，不執行交易邏輯                      │
└─────────────────────────────────────────────────┘

執行流程 (Execute-Order-Validate):
1. Execute: Client 發送交易提案給 Endorser
   → Endorser 執行 Chaincode，返回簽名背書
2. Order: Client 將背書後的交易發送給 Orderer
   → Orderer 排序並打包成區塊
3. Validate: Committer 驗證背書策略和讀寫集衝突
   → 有效交易更新 State DB (CouchDB/LevelDB)
</code></pre>
<p><strong>FISCO BCOS</strong> 是由微眾銀行牽頭、金鏈盟（金融區塊鏈合作聯盟）開源的聯盟鏈平台，在中國大陸的政務、金融、供應鏈等場景中應用廣泛。它支持群組架構（類似 Fabric 的 Channel）、國密演算法（SM2/SM3/SM4），以及 PBFT 和 RAFT 共識。</p>
<p><strong>Quorum</strong> 是 JPMorgan 基於以太坊 Geth 客戶端開發的聯盟鏈平台，後來捐贈給 ConsenSys 維護。它的優勢在於與以太坊工具鏈的兼容性——Solidity 合約可以直接部署到 Quorum，開發者的學習成本較低。Quorum 還提供了 Private Transaction 功能，使用 Tessera 組件實現交易資料的選擇性共享。</p>
<p>工程關注：</p>
<ul>
<li>權限模型</li>
<li>節點身份管理</li>
<li>審計接口</li>
</ul>
<p>在聯盟鏈的工程實踐中，<strong>權限模型</strong>的設計往往比技術實現更複雜。需要回答的問題包括：誰能部署合約？誰能調用哪些合約函數？誰能讀取哪些資料？權限變更需要幾方同意？這些問題不僅涉及技術，更涉及機構間的信任關係和業務流程。一個好的聯盟鏈權限系統應該支持基於角色的存取控制（RBAC）、細粒度的資料可見性控制、以及可審計的權限變更歷史。</p>
<h3 id="613-baas平臺-p2"><a class="header" href="#613-baas平臺-p2">6.1.3 BaaS平臺 <code>P2</code></a></h3>
<p>BaaS 優點：快速部署、降低運維門檻。
風險：供應商鎖定與可移植性不足。</p>
<p>BaaS（Blockchain-as-a-Service）是雲服務商提供的「一鍵部署區塊鏈」服務。主要的 BaaS 平台包括 AWS Managed Blockchain、Azure Blockchain Service（已停止）、阿里雲 BaaS、騰訊雲 TBaaS 等。這些平台將區塊鏈節點的部署、監控、升級等運維工作封裝成雲服務，使企業不需要深入了解底層技術就能使用區塊鏈。</p>
<pre><code class="language-text">BaaS 架構示意：

┌────────────────────────────────────────┐
│            企業應用層                     │
│  ┌──────┐ ┌──────┐ ┌──────┐           │
│  │供應鏈  │ │存證   │ │金融   │           │
│  │管理   │ │系統   │ │結算   │           │
│  └──┬───┘ └──┬───┘ └──┬───┘           │
│     └────────┼────────┘                │
│              │ SDK / API                │
├──────────────v─────────────────────────┤
│          BaaS 平台                      │
│  ┌───────────────────────────────┐     │
│  │ 控制面板 (Dashboard)           │     │
│  │ - 節點管理                     │     │
│  │ - 合約部署                     │     │
│  │ - 監控告警                     │     │
│  │ - 權限管理                     │     │
│  └───────────────────────────────┘     │
│  ┌───────────────────────────────┐     │
│  │ 底層鏈 (Fabric/BCOS/Quorum)   │     │
│  │ - 自動部署                     │     │
│  │ - 自動擴容                     │     │
│  │ - 資料備份                     │     │
│  └───────────────────────────────┘     │
├────────────────────────────────────────┤
│          雲基礎設施 (IaaS)              │
│  ┌────┐ ┌────┐ ┌────┐ ┌────┐         │
│  │VM 1│ │VM 2│ │VM 3│ │VM 4│         │
│  └────┘ └────┘ └────┘ └────┘         │
└────────────────────────────────────────┘
</code></pre>
<p>BaaS 的價值主要體現在概念驗證（PoC）階段和中小企業。對於大型企業或對資料主權有嚴格要求的場景，BaaS 的風險不可忽視：(1) <strong>供應商鎖定</strong>——BaaS 平台通常提供專有的管理 API 和 SDK，遷移到其他平台或自建環境成本高；(2) <strong>資料主權</strong>——區塊鏈節點運行在雲廠商的基礎設施上，資料的實際控制權存疑；(3) <strong>可審計性</strong>——雲環境的變更（如安全修補）可能影響鏈的一致性。</p>
<p>工程上的建議是：在 PoC 階段可以使用 BaaS 快速啟動，但在生產環境中，應該確保核心節點由自己或可信第三方運維，並建立從 BaaS 到自建環境的遷移路徑。</p>
<h3 id="614-區塊鏈應用的合規性-p1"><a class="header" href="#614-區塊鏈應用的合規性-p1">6.1.4 區塊鏈應用的合規性 <code>P1</code></a></h3>
<p>合規重點：</p>
<ul>
<li>KYC/AML 流程與留存</li>
<li>交易監控與可疑活動上報</li>
<li>資料保護與跨境傳輸要求</li>
</ul>
<p>合規性是區塊鏈從技術實驗走向產業落地的最大門檻之一。不同司法管轄區對區塊鏈應用有不同的監管要求，工程師需要理解這些要求，並將其融入系統設計中。</p>
<pre><code class="language-text">合規考量維度：

┌─────────────────────────────────────────────────┐
│                 合規架構                          │
├─────────────────────────────────────────────────┤
│                                                  │
│  1. 身份識別 (KYC)                               │
│     ├── 用戶註冊時收集身份資訊                    │
│     ├── 定期重新驗證                              │
│     └── 與鏈上地址建立映射                        │
│                                                  │
│  2. 反洗錢 (AML)                                 │
│     ├── 交易模式監控（大額、頻繁、分拆等）         │
│     ├── 可疑活動報告 (SAR)                        │
│     └── 制裁名單篩查 (OFAC/UN)                   │
│                                                  │
│  3. 資料保護                                     │
│     ├── GDPR「被遺忘權」vs 區塊鏈不可篡改         │
│     ├── 個資去識別化/加密存儲                     │
│     └── 跨境資料傳輸限制                          │
│                                                  │
│  4. 證券法規                                     │
│     ├── Token 是否構成證券？(Howey Test)          │
│     ├── 發行是否需要注冊？                        │
│     └── 交易平台是否需要牌照？                    │
│                                                  │
└─────────────────────────────────────────────────┘
</code></pre>
<p><strong>GDPR 與區塊鏈的矛盾</strong>是最常被討論的合規問題之一。GDPR 賦予歐盟公民「被遺忘權」（right to be forgotten）——即要求資料控制者刪除其個人資料的權利。但區塊鏈的核心特性是資料不可篡改。工程解決方案包括：(1) 只在鏈上存儲加密後的資料 hash，原始資料存儲在鏈下——刪除鏈下資料即可「遺忘」；(2) 使用 chameleon hash 等特殊密碼學結構，允許在不破壞鏈完整性的情況下修改特定資料；(3) 在聯盟鏈中實施「可編輯區塊鏈」（editable blockchain），在治理委員會的同意下修改歷史資料。</p>
<p>工程落地：</p>
<ul>
<li>將合規規則做成 policy engine</li>
<li>關鍵交易保留審批證據鏈</li>
</ul>
<p><strong>Policy Engine</strong> 是合規系統工程化的核心模式。與其在每個業務邏輯中硬編碼合規規則，不如建立一個獨立的 policy engine，將合規規則以可配置的方式表達。例如，使用 Open Policy Agent（OPA）或自建的規則引擎來定義：「單筆交易金額超過 10,000 美元需要額外審批」「來自高風險國家的地址需要增強盡職調查」。這種架構使合規規則可以在不修改業務程式碼的情況下快速更新——在監管環境快速變化的區塊鏈領域，這種靈活性至關重要。</p>
<h2 id="62-聯盟鏈與基礎建設"><a class="header" href="#62-聯盟鏈與基礎建設">6.2 聯盟鏈與基礎建設</a></h2>
<h3 id="621-數碼化身份-p2"><a class="header" href="#621-數碼化身份-p2">6.2.1 數碼化身份 <code>P2</code></a></h3>
<p>方向：DID + VC（可驗證憑證）。
應用：企業身份、教育證書、供應鏈角色授權。</p>
<p>去中心化身份（Decentralized Identity, DID）是 W3C 制定的標準，旨在讓個人和組織能夠自主管理自己的數位身份，而不依賴中心化的身份提供者（如 Google 帳號或政府資料庫）。DID 與可驗證憑證（Verifiable Credential, VC）一起構成了自主主權身份（Self-Sovereign Identity, SSI）的技術基礎。</p>
<pre><code class="language-text">DID + VC 架構：

┌────────────┐                              ┌────────────┐
│   Issuer    │   簽發 VC (Verifiable        │  Verifier   │
│  (發行者)    │   Credential)               │  (驗證者)    │
│  如: 大學   │──────────────────────&gt;        │  如: 雇主   │
└────────────┘         │                     └──────┬─────┘
                       │                            │
                       v                            │
              ┌────────────────┐                    │
              │    Holder       │                    │
              │   (持有者)       │    出示 VP          │
              │   如: 畢業生     │──────────────────&gt;│
              │                 │  (Verifiable       │
              │ 持有: DID 文件   │   Presentation)    │
              │ 持有: 畢業證書 VC│                    │
              └────────────────┘                    │
                       │                            │
                       v                            v
              ┌─────────────────────────────────────────┐
              │        DID Registry (區塊鏈)             │
              │  - 存儲 DID Document (公鑰、端點)        │
              │  - 不存儲個人資料！                       │
              │  - 任何人都可以解析 DID → 公鑰            │
              └─────────────────────────────────────────┘
</code></pre>
<p>DID 的工程實作需要解決幾個關鍵問題：(1) <strong>DID 方法</strong>——DID 標準是與鏈無關的（did:ethr、did:ion、did:web 等），選擇哪個 DID 方法決定了底層的存儲和解析機制；(2) <strong>憑證格式</strong>——VC 可以用 JSON-LD、JWT 等格式表達，不同格式在大小、可驗證性和工具支持上有不同的取捨；(3) <strong>撤銷機制</strong>——已簽發的 VC 如何被撤銷？常見方案包括撤銷列表（Revocation List）和狀態查詢。</p>
<p>實際案例：歐盟的 EBSI（European Blockchain Services Infrastructure）使用 DID 和 VC 來實現跨國教育證書互認——法國大學簽發的畢業證書可以被德國雇主即時驗證，無需冗長的認證流程。</p>
<h3 id="622-數碼人民幣-p2"><a class="header" href="#622-數碼人民幣-p2">6.2.2 數碼人民幣 <code>P2</code></a></h3>
<p>觀察重點：</p>
<ul>
<li>雙層運營模式</li>
<li>可控匿名</li>
<li>可程式化支付探索</li>
</ul>
<p>數碼人民幣（e-CNY / DC/EP）是中國人民銀行主導的央行數字貨幣（CBDC）項目，是全球最大規模的 CBDC 試驗之一。雖然數碼人民幣的底層技術並非嚴格意義上的區塊鏈（央行層使用的是改良的分散式帳本技術），但它的設計理念和技術挑戰與區塊鏈領域高度相關。</p>
<pre><code class="language-text">數碼人民幣雙層運營模式：

┌──────────────────────────────────────────┐
│              中國人民銀行 (第一層)           │
│  - 發行數碼人民幣                          │
│  - 管理總帳本                              │
│  - 設定貨幣政策                            │
└──────────────────┬───────────────────────┘
                   │ 兌換
                   v
┌──────────────────────────────────────────┐
│         商業銀行/支付機構 (第二層)           │
│  ┌───────┐  ┌───────┐  ┌───────┐        │
│  │工商銀行│  │建設銀行│  │支付寶 │ ...     │
│  └───┬───┘  └───┬───┘  └───┬───┘        │
│      │          │          │             │
│      v          v          v             │
│  ┌──────────────────────────────────┐    │
│  │          一般用戶/商家              │    │
│  │  - 透過 App 持有和使用              │    │
│  │  - 離線支付（碰一碰）               │    │
│  │  - 小額匿名 / 大額實名              │    │
│  └──────────────────────────────────┘    │
└──────────────────────────────────────────┘
</code></pre>
<p><strong>可控匿名</strong>是數碼人民幣最具特色的設計。小額支付不需要提供完整的身份資訊（類似現金的匿名性），但大額支付需要實名認證。央行可以在必要時（如反洗錢調查）追溯交易，但一般商業銀行和商家無法看到完整的交易資訊。這種設計試圖在隱私保護和監管合規之間找到平衡。</p>
<p><strong>可程式化支付</strong>是 CBDC 的潛在殺手級應用。想像一下：政府發放教育補貼，這筆錢只能用於購買書籍和繳納學費，而且只能在一年內使用。透過在數碼貨幣中嵌入智能合約式的條件，可以實現這種精確的資金定向使用。目前數碼人民幣在這方面仍處於探索階段，但已經在消費券、預付款管理等場景中進行了小規模試驗。</p>
<p>從工程角度看，CBDC 的核心挑戰在於：(1) <strong>超高 TPS</strong>——需要支撐十幾億人的日常支付，峰值可能達到數十萬 TPS；(2) <strong>離線支付</strong>——在沒有網路的環境下仍需支持交易，這需要硬體安全模組的支持；(3) <strong>向後兼容</strong>——需要與現有的支付基礎設施（POS 機、ATM、銀行系統）無縫對接。</p>
<h3 id="623-存證溯源平臺-p2"><a class="header" href="#623-存證溯源平臺-p2">6.2.3 存證溯源平臺 <code>P2</code></a></h3>
<p>典型場景：</p>
<ul>
<li>合同存證</li>
<li>供應鏈溯源</li>
<li>醫療/司法資料指紋</li>
</ul>
<p>存證溯源是區塊鏈在聯盟鏈場景中最成熟、落地最廣泛的應用類型。其核心價值在於：利用區塊鏈的不可篡改性，為資料提供一個可信的時間戳和完整性證明。</p>
<pre><code class="language-text">存證溯源系統架構：

┌──────────────────────────────────────────────┐
│                應用層                          │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐   │
│  │ 合同簽署  │  │ 供應鏈   │  │ 司法存證  │   │
│  │ 平台     │  │ 追蹤系統  │  │ 系統     │   │
│  └────┬─────┘  └────┬─────┘  └────┬─────┘   │
│       └─────────────┼─────────────┘          │
│                     │                         │
├─────────────────────v─────────────────────────┤
│              存證服務中間層                      │
│  ┌──────────────────────────────────────┐    │
│  │ 1. 計算資料 hash (SHA-256)            │    │
│  │ 2. 附加時間戳和簽名                    │    │
│  │ 3. 提交 hash 到區塊鏈                 │    │
│  │ 4. 返回存證憑據 (txHash + blockNum)   │    │
│  └──────────────────────────────────────┘    │
│                     │                         │
├─────────────────────v─────────────────────────┤
│              區塊鏈層 (聯盟鏈)                  │
│  ┌──────────────────────────────────────┐    │
│  │ 存儲: 資料 hash + 時間戳 + 提交者 ID  │    │
│  │ 不存儲原始資料！(隱私 + 效能考量)      │    │
│  └──────────────────────────────────────┘    │
└──────────────────────────────────────────────┘

驗證流程:
1. 提供原始資料
2. 重新計算 hash
3. 與鏈上記錄比對
4. hash 一致 → 資料未被篡改 ✓
</code></pre>
<p><strong>合同存證</strong>是中國大陸應用最廣泛的場景之一。杭州互聯網法院在 2018 年首次採納了區塊鏈存證作為電子證據。實務中，電子合同平台在合同簽署後將合同 hash 寫入區塊鏈，日後發生糾紛時可以證明合同內容未被篡改。天平鏈、螞蟻鏈司法存證等平台已經處理了數十億條存證記錄。</p>
<p><strong>供應鏈溯源</strong>是另一個高價值場景。以食品溯源為例，每個環節（農場、加工廠、物流、零售）將關鍵資料（批次號、檢測結果、溫度記錄）的 hash 寫入區塊鏈，消費者可以掃描產品上的二維碼查看完整的供應鏈資訊。沃爾瑪（Walmart）與 IBM 合作的食品溯源專案是最知名的案例——芒果的溯源時間從 7 天縮短到了 2.2 秒。</p>
<p>工程上需要注意的關鍵問題是 <strong>Oracle Problem</strong>——區塊鏈只能保證鏈上資料的不可篡改性，但無法保證上鏈前的資料是真實的。如果有人在食品檢測環節造假，然後把假的檢測結果 hash 寫入鏈上，區塊鏈無法識別這是假資料。因此，存證溯源系統的可信度取決於整個資料鏈條中最薄弱的環節，而不僅僅是區塊鏈本身。配合 IoT 設備自動採集資料、多方交叉驗證、以及可信執行環境（TEE）等技術，可以提升整體系統的可信度。</p>
<h2 id="63-公鏈的熱門應用方向"><a class="header" href="#63-公鏈的熱門應用方向">6.3 公鏈的熱門應用方向</a></h2>
<h3 id="631-去中心化交易所-p1"><a class="header" href="#631-去中心化交易所-p1">6.3.1 去中心化交易所 <code>P1</code></a></h3>
<p>DEX 核心：</p>
<ul>
<li>AMM（x*y=k）</li>
<li>集中流動性</li>
<li>訂單路由與滑點控制</li>
</ul>
<p>風險：MEV、流動性斷層、預言機偏差。</p>
<p>去中心化交易所（Decentralized Exchange, DEX）是 DeFi 生態中最基礎的元件。與中心化交易所（CEX）不同，DEX 不需要用戶將資產託管給交易所——交易完全在智能合約中執行，用戶始終保持對資產的控制權。Uniswap、Curve、PancakeSwap 是最知名的 DEX。</p>
<pre><code class="language-text">AMM (Automated Market Maker) 原理：

Uniswap V2: 恆定乘積公式 x * y = k

流動性池:
┌──────────────────────────────────────┐
│          Liquidity Pool               │
│                                       │
│  ETH 儲備 (x): 100 ETH              │
│  USDC 儲備 (y): 200,000 USDC        │
│  k = 100 * 200,000 = 20,000,000     │
│                                       │
│  價格 = y/x = 2,000 USDC/ETH        │
└──────────────────────────────────────┘

交易過程（買入 1 ETH）:
  新的 x = 100 - 1 = 99 ETH
  新的 y = k / x = 20,000,000 / 99 = 202,020.20 USDC
  用戶支付: 202,020.20 - 200,000 = 2,020.20 USDC
  實際價格: 2,020.20 USDC/ETH（比「市場價」貴 ~1%）
  → 這就是「滑點」(slippage)


Uniswap V3: 集中流動性
┌──────────────────────────────────────┐
│  傳統 AMM: 流動性均勻分佈在 0-∞      │
│  ════════════════════════════         │
│                                       │
│  V3 集中流動性: LP 指定價格區間       │
│         ┌────────┐                    │
│  ═══════│████████│═══════             │
│         └────────┘                    │
│         $1800   $2200                 │
│                                       │
│  效果: 相同資金量，在指定區間內提供    │
│        更深的流動性，減少滑點          │
└──────────────────────────────────────┘
</code></pre>
<p><strong>集中流動性</strong>是 Uniswap V3 引入的革命性設計。在 V2 中，流動性均勻分佈在 0 到無窮大的價格範圍中——但實際上大部分交易都發生在一個很窄的價格範圍內。V3 允許流動性提供者（LP）選擇自己要提供流動性的價格區間，大幅提升了資金效率。但這也帶來了新的複雜性——LP 需要主動管理自己的倉位，當價格移出指定區間時，LP 不再賺取手續費且面臨無常損失（impermanent loss）。</p>
<p><strong>MEV 對 DEX 的影響</strong>是一個嚴峻的工程和經濟問題。三明治攻擊讓用戶在每筆交易中損失了隱含成本。Flashbots 的數據顯示，MEV 每天從以太坊用戶身上提取數百萬美元的價值。防禦手段包括：(1) 使用私有交易池（如 Flashbots Protect）繞過公共 mempool；(2) 使用限價訂單（如 1inch Limit Order Protocol）而非市價訂單；(3) 在 L2 上交易，利用 sequencer 的先到先服務排序規則來降低 MEV 風險。</p>
<h3 id="632-defi應用簡介-p1"><a class="header" href="#632-defi應用簡介-p1">6.3.2 DeFi應用簡介 <code>P1</code></a></h3>
<p>核心模組：</p>
<ul>
<li>借貸</li>
<li>穩定幣</li>
<li>衍生品</li>
<li>收益聚合</li>
</ul>
<p>DeFi（Decentralized Finance，去中心化金融）是公鏈上最成功的應用類別，TVL（Total Value Locked，鎖倉量）在高峰期超過 1800 億美元。DeFi 的核心理念是用智能合約替代傳統金融中介——銀行、交易所、保險公司、資產管理公司。</p>
<pre><code class="language-text">DeFi 生態堆疊：

┌─────────────────────────────────────────┐
│              聚合層 (Aggregators)          │
│  ┌─────────┐  ┌──────────┐              │
│  │ 1inch    │  │ Yearn    │ ...          │
│  │(DEX聚合) │  │(收益聚合)│              │
│  └────┬────┘  └────┬─────┘              │
├───────┼────────────┼────────────────────┤
│       │   協議層 (Protocols)              │
│  ┌────v────┐  ┌────v─────┐  ┌────────┐ │
│  │ Uniswap │  │  Aave    │  │ Maker  │ │
│  │ (交易)  │  │ (借貸)   │  │(穩定幣)│ │
│  └─────────┘  └──────────┘  └────────┘ │
├─────────────────────────────────────────┤
│              資產層 (Assets)              │
│  ┌─────┐ ┌──────┐ ┌─────┐ ┌────────┐  │
│  │ ETH │ │ USDC │ │ DAI │ │ WBTC   │  │
│  └─────┘ └──────┘ └─────┘ └────────┘  │
├─────────────────────────────────────────┤
│           結算層 (Settlement)             │
│  ┌─────────────────────────────────┐    │
│  │      Ethereum / L2 Rollup       │    │
│  └─────────────────────────────────┘    │
└─────────────────────────────────────────┘
</code></pre>
<p><strong>借貸協議</strong>是 DeFi 中最核心的元件之一。Aave 和 Compound 是最知名的去中心化借貸協議。用戶可以存入資產作為抵押品，並借出另一種資產。利率根據供需動態調整——當某資產的借出率增加時，利率上升以激勵更多存款。清算機制是借貸協議安全性的關鍵——當抵押品價值低於清算閾值時，任何人都可以清算這個倉位，獲得清算獎勵。</p>
<p><strong>穩定幣</strong>是 DeFi 的「血液」。主流穩定幣分為三類：(1) 法幣抵押型（USDT、USDC）——由中心化機構持有等值法幣或國債作為儲備；(2) 加密資產超額抵押型（DAI）——用戶抵押 ETH 等加密資產，鑄造價值較低的穩定幣；(3) 演算法型——透過演算法控制供給來維持錨定，但歷史上多次失敗（最著名的是 2022 年 Terra/UST 的崩盤，導致約 400 億美元蒸發）。</p>
<p>工程關鍵：</p>
<ul>
<li>清算機制可用性</li>
<li>風險參數治理</li>
<li>依賴協議傳染風險</li>
</ul>
<p><strong>依賴協議傳染風險</strong>是 DeFi 工程中最容易被低估的問題。DeFi 協議之間像樂高一樣組合——Yearn 的策略可能把資金存入 Aave，Aave 的抵押品可能是 Curve 的 LP Token，而 Curve 的池子裡可能包含 MakerDAO 鑄造的 DAI。這種深度嵌套意味著一個協議的問題可能引發連鎖反應。2022 年的 Terra/LUNA 崩盤就是一個例子——UST 脫鉤導致使用 UST 作為資產的多個 DeFi 協議同時出現問題，引發了「DeFi 的雷曼時刻」。工程上的防禦措施包括：對單一資產/協議的曝光設定上限、壓力測試極端場景、以及建立自動化的風險監控和斷路器機制。</p>
<h3 id="633-ipfs應用簡介-p2"><a class="header" href="#633-ipfs應用簡介-p2">6.3.3 IPFS應用簡介 <code>P2</code></a></h3>
<p>IPFS 是內容尋址網路，常與鏈配合儲存大文件。</p>
<p>IPFS（InterPlanetary File System）是一個去中心化的檔案存儲和分享協議。與傳統的位置尋址（URL 指向伺服器位置）不同，IPFS 使用<strong>內容尋址</strong>——檔案的地址是其內容的 hash（稱為 CID，Content Identifier）。這意味著同一份檔案無論存儲在哪裡，都有相同的地址；而且如果檔案內容被修改，地址就會改變。</p>
<pre><code class="language-text">傳統 HTTP vs IPFS：

HTTP (位置尋址):
  URL: https://example.com/images/cat.jpg
  → 向 example.com 的伺服器請求 /images/cat.jpg
  → 如果伺服器當機？→ 檔案無法存取 ❌
  → 如果內容被修改？→ 同一 URL，不同內容 ⚠️

IPFS (內容尋址):
  CID: QmW2WQi7j6c7UgJTarActp7tDNikE4B2qXtFCfLPdsgaTQ
  → 向任何 IPFS 節點請求此 CID
  → 只要任何一個節點有此檔案 → 可存取 ✓
  → CID = hash(內容)，內容被修改 → CID 改變 ✓

IPFS + 區塊鏈:
┌────────────┐     CID      ┌─────────────┐
│  Blockchain │ ◄──────────  │    IPFS      │
│  (鏈上)     │              │  (鏈下)      │
│  存 CID     │              │  存原始資料   │
│  ~32 bytes  │              │  可以很大     │
└────────────┘              └─────────────┘
</code></pre>
<p>工程注意：</p>
<ul>
<li>CID 與 metadata 綁定</li>
<li>pin 策略</li>
<li>可用性 SLA</li>
</ul>
<p><strong>Pin 策略</strong>是 IPFS 工程中最重要的考量。IPFS 節點預設只快取最近存取過的資料，不常存取的資料會被垃圾回收清除。如果你的 NFT 圖片沒有被任何節點 pin 住，它最終會從網路中消失。解決方案有：(1) 自己運行 IPFS 節點並 pin 所有重要資料；(2) 使用 Pinning 服務（Pinata、Infura IPFS、Web3.Storage）；(3) 使用 Filecoin——Filecoin 是 IPFS 的激勵層，礦工透過存儲資料獲得代幣獎勵，提供了經濟激勵來確保資料的長期可用性。</p>
<p>Arweave 是另一個值得關注的去中心化存儲方案。與 IPFS 的「按時間付費」不同，Arweave 採用「一次付費，永久存儲」的模式。用戶只需支付一次性費用，資料就會被永久存儲在 Arweave 網路上。這種模式對 NFT metadata 等需要永久可用的場景特別有吸引力。</p>
<h3 id="634-dfinity應用簡介-p2"><a class="header" href="#634-dfinity應用簡介-p2">6.3.4 DFINITY應用簡介 <code>P2</code></a></h3>
<p>DFINITY（Internet Computer）強調鏈上可執行應用（canister）。</p>
<p>DFINITY 的 Internet Computer Protocol（ICP）是一個與以太坊路線截然不同的區塊鏈專案。它的目標不是「世界帳本」或「世界電腦」，而是「世界雲端」——直接在區塊鏈上運行完整的 Web 應用，包括前端（HTML/CSS/JS）、後端邏輯和資料存儲，完全不需要傳統的雲服務。</p>
<pre><code class="language-text">傳統 DApp vs ICP DApp:

傳統 DApp:
┌──────────┐   ┌──────────┐   ┌──────────┐
│ 前端      │   │ 後端 API  │   │ 智能合約  │
│ (Vercel) │──&gt;│ (AWS)    │──&gt;│(Ethereum)│
│ 中心化    │   │ 中心化    │   │ 去中心化  │
└──────────┘   └──────────┘   └──────────┘
  ⚠️ 前端和後端仍然是中心化的

ICP DApp:
┌─────────────────────────────────────────┐
│            Internet Computer             │
│  ┌─────────────────────────────────┐    │
│  │         Canister (容器)          │    │
│  │  ┌────────┐ ┌───────┐ ┌─────┐ │    │
│  │  │ 前端   │ │ 後端   │ │存儲 │ │    │
│  │  │ HTML/JS│ │ Motoko │ │     │ │    │
│  │  └────────┘ └───────┘ └─────┘ │    │
│  └─────────────────────────────────┘    │
│  全部運行在去中心化的子網上               │
└─────────────────────────────────────────┘
  ✓ 前端、後端、存儲全部去中心化
</code></pre>
<p>關注點：</p>
<ul>
<li>執行模型</li>
<li>開發工具鏈</li>
<li>生態互通性</li>
</ul>
<p>ICP 使用 <strong>Canister</strong>（容器）作為基本的計算單元，類似於以太坊的智能合約但功能更強大。Canister 可以存儲 GB 級的資料（以太坊合約存儲極其昂貴）、直接回應 HTTP 請求（以太坊合約不行）、以及進行跨 Canister 的異步調用。ICP 使用 <strong>Chain Key 密碼學</strong>讓子網之間可以高效通訊，並提供了 <strong>Cycle</strong> 作為計算資源的計費單位（類似以太坊的 Gas，但成本低得多）。</p>
<p>ICP 的開發語言是 <strong>Motoko</strong>（專為 ICP 設計的語言）或 <strong>Rust</strong>。Motoko 的設計考慮了 Actor 模型和異步編程，與 Canister 的執行模型天然匹配。但生態較小是 ICP 面臨的主要挑戰——相比以太坊龐大的開發者社群和工具鏈，ICP 的開發者資源和 DeFi 流動性都還比較有限。</p>
<p>ICP 最有意思的特性是 <strong>Bitcoin 和 Ethereum 整合</strong>——Canister 可以直接持有比特幣（不需要橋或 wrapped token），並在 ICP 上執行比特幣交易。這是透過 Chain Key 簽名和門限 ECDSA 實現的。如果這個方向成熟，它可能會為跨鏈互操作提供一種全新的範式。</p>
<h2 id="落地趨勢全景回顧"><a class="header" href="#落地趨勢全景回顧">落地趨勢全景回顧</a></h2>
<p>趨勢不是單看技術新舊，而是「安全、合規、成本、治理」四維同時可落地。</p>
<p>區塊鏈落地的核心挑戰從來不是技術本身——技術已經足夠成熟，能夠支撐絕大多數應用場景。真正的挑戰在於如何在現實世界的約束條件下做出正確的取捨。</p>
<p><strong>安全</strong>是第一優先級。無論是公鏈還是聯盟鏈，安全事故都會直接導致資金損失和信任崩塌。2022 年的跨鏈橋攻擊、DeFi 閃電貸攻擊、以及多個 CEX 的倒閉，讓整個行業付出了數百億美元的學費。工程師需要將安全作為設計的核心約束，而不是事後的附加要求。</p>
<p><strong>合規</strong>是不可迴避的現實。全球監管環境正在快速演變——歐盟的 MiCA（Markets in Crypto-Assets Regulation）、美國 SEC 對加密資產的分類、中國對虛擬貨幣交易的禁止但對區塊鏈技術的鼓勵。工程師需要理解這些監管要求，並將合規能力（KYC、AML、資料保護）設計為系統的基本功能，而非可選插件。</p>
<p><strong>成本</strong>決定了商業可行性。鏈上操作的成本（Gas 費、存儲費）需要與業務收益相匹配。以太坊主網上一次簡單的 ERC-20 轉帳在高峰期可能花費數十美元——對於小額支付場景，這是不可接受的。L2、聯盟鏈、以及鏈上鏈下混合架構都是降低成本的方法。</p>
<p><strong>治理</strong>決定了系統的長期可持續性。誰來決定協議的升級方向？參數如何調整？出現問題時誰負責？公鏈的鏈上治理（如 Compound 的 Governor 合約）和聯盟鏈的委員會治理各有優劣。沒有完美的治理模型，但沒有治理模型的系統注定無法長久。</p>
<pre><code class="language-text">區塊鏈落地決策矩陣：

┌──────────┬────────────┬────────────┬────────────┐
│ 場景      │ 推薦方案    │ 核心考量    │ 代表案例    │
├──────────┼────────────┼────────────┼────────────┤
│ DeFi     │ 公鏈 + L2  │ 流動性、    │ Uniswap,   │
│          │            │ 可組合性    │ Aave       │
├──────────┼────────────┼────────────┼────────────┤
│ 供應鏈   │ 聯盟鏈     │ 隱私、合規  │ IBM Food   │
│          │            │ 身份管理    │ Trust      │
├──────────┼────────────┼────────────┼────────────┤
│ 數位身份 │ 混合       │ 互通性、    │ Polygon ID │
│          │            │ 標準化      │            │
├──────────┼────────────┼────────────┼────────────┤
│ 支付結算 │ CBDC /     │ TPS、離線   │ e-CNY,     │
│          │ 聯盟鏈     │ 合規       │ JPM Coin   │
├──────────┼────────────┼────────────┼────────────┤
│ NFT/遊戲 │ 公鏈 + L2  │ 用戶體驗、  │ Immutable  │
│          │            │ 低手續費    │ zkEVM      │
├──────────┼────────────┼────────────┼────────────┤
│ 存證溯源 │ 聯盟鏈     │ 法律效力、  │ 天平鏈、    │
│          │            │ 成本       │ 螞蟻鏈     │
└──────────┴────────────┴────────────┴────────────┘
</code></pre>
<h2 id="白話總結-18"><a class="header" href="#白話總結-18">白話總結</a></h2>
<p>區塊鏈到底該怎麼落地？其實就看你的場景需要什麼。如果你做的是面向全球用戶的金融應用，需要跟各種 DeFi 協議互動，那就用公鏈或 L2。如果你做的是銀行之間的結算系統或者企業供應鏈管理，數據不想讓全世界看到，那聯盟鏈更適合。BaaS 平台可以讓你快速搭起一套區塊鏈環境試試水，但真上生產環境的時候要小心被雲廠商綁架。合規這件事不能事後再想——KYC、AML、數據保護法規一開始就要設計進系統裡。DEX 和 DeFi 是公鏈上最成功的應用，但 MEV 和合約安全問題依然讓人頭痛。存證溯源是聯盟鏈上最成熟的場景，已經在法院和供應鏈中廣泛使用了。最重要的一句話：技術選型沒有「最好」，只有「最適合你的場景」——安全、合規、成本、治理這四個維度缺一不可。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第3篇-區塊鏈開發篇"><a class="header" href="#第3篇-區塊鏈開發篇">第3篇 區塊鏈開發篇</a></h1>
<p>本篇涵蓋第7章到第9章，重點是從語言到工具鏈，再到錢包工程。</p>
<h2 id="重要度分級-1"><a class="header" href="#重要度分級-1">重要度分級</a></h2>
<ul>
<li><code>P0</code> 必修：智能合約與錢包核心能力</li>
<li><code>P1</code> 重要：工程最佳實踐與常見標準</li>
<li><code>P2</code> 補充：特定案例或場景延伸</li>
</ul>
<h2 id="篇章定位-1"><a class="header" href="#篇章定位-1">篇章定位</a></h2>
<ul>
<li>第7章：Solidity 語法與物件設計基礎</li>
<li>第8章：標準、升級、最佳實踐、Python 調用</li>
<li>第9章：離線錢包原理與核心功能</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第7章-solidity智能合約開發入門"><a class="header" href="#第7章-solidity智能合約開發入門">第7章 Solidity智能合約開發入門</a></h1>
<p>本章目標是建立 Solidity 的可開發能力：能正確建模資料、寫安全函數、理解合約互動界面。</p>
<h2 id="71-智能合約運作原理與環境搭建-p0"><a class="header" href="#71-智能合約運作原理與環境搭建-p0">7.1 智能合約運作原理與環境搭建 <code>P0</code></a></h2>
<h3 id="711-智能合約的概念-p0"><a class="header" href="#711-智能合約的概念-p0">7.1.1 智能合約的概念 <code>P0</code></a></h3>
<p>智能合約是「部署在鏈上的程式」，特性：</p>
<ul>
<li>可公開驗證</li>
<li>狀態可追蹤</li>
<li>結果由共識保證</li>
</ul>
<p>工程重點：一旦部署，修改成本很高，設計需先做風險建模。</p>
<p>智能合約（Smart Contract）這個名詞最早由密碼學家 Nick Szabo 在 1990 年代提出，但直到 Ethereum 出現後才真正被大規模實踐。簡單來說，智能合約就是一段部署在區塊鏈上的程式碼，它按照預先定義好的規則自動執行，任何人都可以驗證其行為是否符合預期。這與傳統的伺服器端程式有根本性的差異——傳統程式運行在某家公司的伺服器上，使用者必須「信任」那台伺服器不會被篡改；智能合約則運行在去中心化的節點網路上，其執行結果由共識機制保證。</p>
<p>從工程角度來看，智能合約最關鍵的特性是「不可變性」（immutability）。一旦合約被部署到鏈上，其程式碼就無法直接修改。這意味著任何 bug 都會永久存在於鏈上，修復的成本遠比傳統軟體高得多。2016 年的 The DAO 事件就是一個經典案例——一個重入漏洞導致了價值約 6000 萬美元的 ETH 被盜，最終迫使 Ethereum 社群進行硬分叉。因此，在寫智能合約之前，工程師必須先進行完整的威脅建模（threat modeling）：列出所有可能的攻擊向量、邊界條件、權限異常情境，再開始撰寫程式碼。</p>
<p>智能合約的另一個重要特性是「確定性」（determinism）。同樣的輸入必須產生同樣的輸出，否則不同節點無法達成共識。這代表智能合約不能使用隨機數（需要透過 oracle 或 VRF）、不能直接呼叫外部 API、不能依賴系統時鐘的精確值。這些限制在設計合約時必須充分考慮。</p>
<pre><code class="language-text">傳統軟體 vs 智能合約對比：

┌─────────────────┬─────────────────────┬─────────────────────┐
│     比較項目     │     傳統軟體         │     智能合約         │
├─────────────────┼─────────────────────┼─────────────────────┤
│ 部署後修改       │ 隨時可更新           │ 不可變（需 Proxy）   │
│ 執行環境         │ 中心化伺服器         │ 去中心化節點網路     │
│ 信任模型         │ 信任營運方           │ 信任程式碼           │
│ 執行成本         │ 按伺服器資源計費     │ 按 gas 計費          │
│ 錯誤修復         │ 熱修補丁             │ 需部署新版 + 遷移    │
│ 資料透明度       │ 營運方控制           │ 全鏈公開可查         │
└─────────────────┴─────────────────────┴─────────────────────┘
</code></pre>
<h3 id="712-智能合約的運作機制-p0"><a class="header" href="#712-智能合約的運作機制-p0">7.1.2 智能合約的運作機制 <code>P0</code></a></h3>
<p>運作流程：</p>
<ol>
<li>使用者提交交易</li>
<li>節點執行 EVM 字節碼</li>
<li>產生狀態變更與事件</li>
<li>打包進區塊</li>
</ol>
<pre><code class="language-text">Tx -&gt; EVM Execute -&gt; State Change + Event -&gt; Block
</code></pre>
<p>讓我們更細緻地拆解這個流程。當使用者想要與智能合約互動時，他首先需要構建一筆交易（transaction）。這筆交易包含目標合約地址、要呼叫的函數簽名、傳入的參數、以及支付的 gas 費用。交易構建完成後，使用者用自己的私鑰對交易進行簽名，然後將已簽名的交易廣播到 Ethereum 網路。</p>
<p>當節點接收到這筆交易後，會將其放入交易池（mempool）等待打包。被選中的驗證者（validator）會從 mempool 中選取交易，在 EVM（Ethereum Virtual Machine）中逐一執行。EVM 是一個堆疊式虛擬機器，它讀取合約編譯後的字節碼（bytecode），按照指令集逐步執行。每一條指令都有對應的 gas 消耗量，如果交易附帶的 gas 不足以完成所有指令，交易會被 revert，但已消耗的 gas 不會退還。</p>
<pre><code class="language-text">詳細運作流程：

  User                    Network                    EVM                     Chain
   │                        │                         │                        │
   │  1. Build Tx           │                         │                        │
   │  (to, data, gas,       │                         │                        │
   │   nonce, value)        │                         │                        │
   │                        │                         │                        │
   │  2. Sign Tx            │                         │                        │
   │  (ECDSA signature)     │                         │                        │
   │                        │                         │                        │
   │  3. Broadcast ────────&gt;│                         │                        │
   │                        │  4. Enter Mempool       │                        │
   │                        │                         │                        │
   │                        │  5. Validator selects ──&gt;│                        │
   │                        │                         │  6. Load bytecode      │
   │                        │                         │  7. Execute opcodes    │
   │                        │                         │  8. Update state ─────&gt;│
   │                        │                         │  9. Emit events ──────&gt;│
   │                        │                         │                        │
   │  10. Get receipt &lt;─────│&lt;─────────────────────────│&lt;───────────────────────│
   │  (status, logs, gas)   │                         │                        │
</code></pre>
<p>執行完成後，EVM 會產生兩類結果：狀態變更（State Change）和事件日誌（Event Log）。狀態變更是寫入區塊鏈永久儲存的資料，例如帳戶餘額的增減、mapping 中新增的鍵值對等。事件日誌則不會影響鏈上狀態，但會被記錄在交易收據（receipt）中，供外部系統（如前端 DApp、索引服務）監聽和查詢。</p>
<p>一個常見的誤解是「交易提交就代表執行成功」。實際上，交易被打包進區塊只代表它被處理了，但不代表它執行成功。交易收據中的 <code>status</code> 欄位為 <code>1</code> 才代表成功，為 <code>0</code> 代表 revert。工程上必須檢查收據狀態，而非僅確認交易上鏈。</p>
<h3 id="713-智能合約運作三要素-p0"><a class="header" href="#713-智能合約運作三要素-p0">7.1.3 智能合約運作三要素 <code>P0</code></a></h3>
<p>三要素：</p>
<ul>
<li><code>State</code>：儲存資料</li>
<li><code>Function</code>：狀態轉移邏輯</li>
<li><code>Event</code>：對外通知與索引依據</li>
</ul>
<p>智能合約可以被理解為一個狀態機（state machine），而這個狀態機由三個核心要素組成。理解這三個要素之間的關係，是正確設計合約的前提。</p>
<p><strong>State（狀態）</strong> 是合約在鏈上持久保存的資料。每個合約都有自己獨立的儲存空間（storage），以 256-bit 的 slot 為單位組織。狀態變數的值會在交易之間持續存在，直到被新的交易修改。例如，一個 ERC-20 token 合約的 <code>balances</code> mapping 就是一個典型的狀態——它記錄了每個地址持有的 token 數量。設計狀態時的關鍵考量是：哪些資料真正需要上鏈？上鏈的每一個 byte 都需要支付 gas，因此應該只儲存最必要的資料，其餘資料可以透過事件日誌或鏈下儲存來處理。</p>
<p><strong>Function（函數）</strong> 是改變狀態的邏輯。函數接收外部輸入（交易的 calldata），按照定義好的規則修改狀態。函數可以有不同的可見性和狀態屬性，這些我們會在後面的章節詳細討論。設計函數時的核心原則是：每個函數的前置條件（precondition）和後置條件（postcondition）都必須清晰明確，並且透過 <code>require</code> 或 custom error 來強制執行。</p>
<p><strong>Event（事件）</strong> 是合約對外部世界的通知機制。事件被記錄在交易日誌中，但不佔用合約的 storage 空間，因此 gas 成本相對較低。事件的主要用途有三個：一是讓前端 DApp 能夠監聽合約狀態變化並即時更新 UI；二是作為鏈下索引服務（如 The Graph）的資料來源；三是作為審計追蹤的依據。一個好的合約設計應該為所有重要的狀態變更都發出對應的事件。</p>
<pre><code class="language-text">三要素互動關係：

┌──────────────────────────────────────────────────┐
│                Smart Contract                     │
│                                                   │
│   ┌─────────────────────────────────────┐        │
│   │           State (Storage)            │        │
│   │  ┌──────────┐  ┌──────────────────┐ │        │
│   │  │ balances │  │ allowances       │ │        │
│   │  │ mapping  │  │ mapping          │ │        │
│   │  └──────────┘  └──────────────────┘ │        │
│   │  ┌──────────┐  ┌──────────────────┐ │        │
│   │  │ owner    │  │ totalSupply      │ │        │
│   │  │ address  │  │ uint256          │ │        │
│   │  └──────────┘  └──────────────────┘ │        │
│   └─────────────────────────────────────┘        │
│         ▲                                         │
│         │ read/write                              │
│         │                                         │
│   ┌─────┴─────────────────────────────┐          │
│   │         Functions                  │          │
│   │  transfer()  approve()  mint()     │──────&gt; Events
│   │  burn()      pause()               │   Transfer()
│   └───────────────────────────────────┘   Approval()
│         ▲                                         │
│         │ calldata                                │
└─────────┼────────────────────────────────────────┘
          │
    External Call (Transaction)
</code></pre>
<h3 id="714-智能合約開發環境搭建-p0"><a class="header" href="#714-智能合約開發環境搭建-p0">7.1.4 智能合約開發環境搭建 <code>P0</code></a></h3>
<p>建議環境：</p>
<ul>
<li>編譯測試：Foundry/Hardhat</li>
<li>本地鏈：Anvil</li>
<li>安全庫：OpenZeppelin</li>
</ul>
<p>最小命令流：</p>
<ul>
<li>編譯</li>
<li>測試</li>
<li>部署</li>
<li>驗證</li>
</ul>
<p>開發環境的選擇直接影響開發效率和測試品質。目前主流的 Solidity 開發框架有兩個：<strong>Foundry</strong> 和 <strong>Hardhat</strong>。兩者各有優勢，選擇取決於團隊偏好和專案需求。</p>
<p><strong>Foundry</strong> 是用 Rust 寫的工具鏈，包含 <code>forge</code>（編譯與測試）、<code>cast</code>（鏈上互動）、<code>anvil</code>（本地測試鏈）三個核心工具。它的最大優勢是測試用 Solidity 本身來寫，不需要在 JavaScript/TypeScript 和 Solidity 之間切換語境。此外，Foundry 內建了 fuzz testing 和 invariant testing 能力，對安全性要求高的專案特別有價值。</p>
<pre><code class="language-bash"># Foundry 安裝與基本工作流

# 安裝
curl -L https://foundry.paradigm.xyz | bash
foundryup

# 初始化專案
forge init my-contract

# 編譯
forge build

# 測試（含 fuzz testing）
forge test -vvv

# 部署到本地測試鏈
anvil &amp;                         # 啟動本地鏈
forge create src/MyContract.sol:MyContract \
  --rpc-url http://localhost:8545 \
  --private-key 0xac0974bec...

# 部署到測試網
forge create src/MyContract.sol:MyContract \
  --rpc-url $SEPOLIA_RPC_URL \
  --private-key $DEPLOYER_KEY \
  --verify \
  --etherscan-api-key $ETHERSCAN_KEY
</code></pre>
<p><strong>Hardhat</strong> 是用 JavaScript/TypeScript 寫的工具鏈，生態系更成熟，有大量的外掛可用（如 hardhat-deploy、hardhat-gas-reporter 等）。測試用 JavaScript/TypeScript 撰寫，適合前端工程師或已有 JavaScript 經驗的團隊。</p>
<pre><code class="language-bash"># Hardhat 基本工作流

# 初始化專案
npx hardhat init

# 編譯
npx hardhat compile

# 測試
npx hardhat test

# 部署
npx hardhat run scripts/deploy.js --network sepolia

# 驗證合約
npx hardhat verify --network sepolia &lt;CONTRACT_ADDRESS&gt; &lt;CONSTRUCTOR_ARGS&gt;
</code></pre>
<p><strong>本地測試鏈</strong> 是開發過程中不可或缺的工具。Anvil（Foundry 配套）和 Hardhat Network 都可以在本機啟動一條完整的 Ethereum 模擬鏈，支援即時出塊、時間快轉、狀態快照等功能。使用本地鏈可以大幅加速開發迭代，同時避免在測試網上浪費測試幣。</p>
<p><strong>OpenZeppelin</strong> 是智能合約開發的標準安全庫，提供了經過審計的 ERC-20、ERC-721、AccessControl、ReentrancyGuard 等常用合約實作。工程上的建議是：凡是 OpenZeppelin 已經實作的功能，都應該優先使用其實作，而非自己從頭寫。自行實作標準功能不僅浪費時間，還容易引入安全漏洞。</p>
<pre><code class="language-text">開發環境選擇決策樹：

需要 Solidity 原生測試？ ──── Yes ──&gt; Foundry
        │
        No
        │
團隊熟悉 JavaScript？ ──── Yes ──&gt; Hardhat
        │
        No
        │
需要大量外掛支援？ ──── Yes ──&gt; Hardhat
        │
        No
        │
重視編譯與測試速度？ ──── Yes ──&gt; Foundry
        │
        No ──&gt; 兩者皆可，建議 Foundry（業界趨勢）
</code></pre>
<h3 id="715-remix環境簡介-p1"><a class="header" href="#715-remix環境簡介-p1">7.1.5 Remix環境簡介 <code>P1</code></a></h3>
<p>Remix 適合：</p>
<ul>
<li>快速驗證語法</li>
<li>教學與原型</li>
<li>小範例除錯</li>
</ul>
<p>不適合：</p>
<ul>
<li>團隊協作大專案</li>
<li>需要完整 CI/CD 的場景</li>
</ul>
<p>Remix（https://remix.ethereum.org）是一個瀏覽器內的 Solidity IDE，無需安裝任何工具即可開始撰寫和測試智能合約。它內建了 Solidity 編譯器、JavaScript VM（模擬 EVM）、以及合約部署和互動介面。對於初學者來說，Remix 是最快上手的工具。</p>
<p>Remix 最大的優勢在於「零配置」。打開瀏覽器就能開始寫合約、編譯、部署到模擬環境、並透過 UI 直接呼叫合約函數查看結果。這對於快速驗證一個語法概念或測試一段小邏輯非常方便。此外，Remix 還提供了 Solidity 靜態分析外掛，可以檢測常見的安全問題。</p>
<p>然而，Remix 有明顯的局限性。它不支援版本控制（Git）、不方便進行自動化測試、無法整合 CI/CD 流水線、也不適合多人協作。因此，在真正的工程專案中，Remix 通常只用於快速原型驗證和教學演示，正式開發應該使用 Foundry 或 Hardhat。</p>
<p>一個常見的工作流是：先在 Remix 中快速驗證一個想法，確認可行後再到 Foundry/Hardhat 專案中正式實作並撰寫完整的測試。</p>
<h3 id="716-初識solidity-p0"><a class="header" href="#716-初識solidity-p0">7.1.6 初識Solidity <code>P0</code></a></h3>
<p>第一原則：</p>
<ul>
<li>明確版本（<code>pragma solidity ^0.8.x</code>）</li>
<li>預設安全（溢位保護、嚴格可見性）</li>
<li>儘量用 custom error</li>
</ul>
<p>Solidity 是一門為 EVM 設計的靜態型別、合約導向的程式語言。它的語法看起來像 JavaScript，但底層行為更接近 C++。理解 Solidity 的設計哲學和基本結構，是後續所有學習的基礎。</p>
<p><strong>版本宣告</strong> 是每個 Solidity 檔案的第一行。<code>pragma solidity ^0.8.20;</code> 表示這個合約兼容 0.8.20 到（不含）0.9.0 的所有編譯器版本。版本宣告非常重要，因為不同版本的 Solidity 在安全特性上有重大差異。例如，0.8.0 之前的版本沒有內建溢位保護，開發者需要手動使用 SafeMath 庫；0.8.0 之後則預設開啟溢位檢查。</p>
<p><strong>Custom Error</strong> 是 Solidity 0.8.4 引入的特性，相比傳統的 <code>require(condition, "error message")</code> 字串錯誤，custom error 在 gas 消耗上更節省，同時提供了更好的結構化錯誤資訊。</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// 定義 custom error
error InsufficientBalance(uint256 available, uint256 required);
error Unauthorized(address caller);

contract MyFirstContract {
    address public owner;
    mapping(address =&gt; uint256) public balances;

    event Deposited(address indexed user, uint256 amount);
    event Withdrawn(address indexed user, uint256 amount);

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        if (msg.sender != owner) revert Unauthorized(msg.sender);
        _;
    }

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        emit Deposited(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external {
        uint256 bal = balances[msg.sender];
        if (bal &lt; amount) revert InsufficientBalance(bal, amount);

        balances[msg.sender] -= amount;

        (bool ok, ) = msg.sender.call{value: amount}("");
        require(ok, "transfer failed");

        emit Withdrawn(msg.sender, amount);
    }
}
</code></pre>
<p>上面的範例展示了一個最小但完整的合約結構：包含狀態變數、事件宣告、modifier、constructor、以及帶有完整錯誤處理的函數。注意 <code>withdraw</code> 函數遵循了 Checks-Effects-Interactions（CEI）模式——先檢查條件、再更新狀態、最後才進行外部呼叫。這是防止重入攻擊的基本實踐。</p>
<h2 id="72-solidity基礎語法-p0"><a class="header" href="#72-solidity基礎語法-p0">7.2 Solidity基礎語法 <code>P0</code></a></h2>
<h3 id="721-solidity基礎資料類型-p0"><a class="header" href="#721-solidity基礎資料類型-p0">7.2.1 Solidity基礎資料類型 <code>P0</code></a></h3>
<p>常用型別：</p>
<ul>
<li><code>uint256</code>, <code>int256</code></li>
<li><code>bool</code></li>
<li><code>address</code></li>
<li><code>bytes</code>, <code>string</code></li>
</ul>
<p>建議：先用 <code>uint256</code>，有明確需求再做壓縮。</p>
<p>Solidity 的型別系統與 EVM 的 256-bit 架構緊密相關。EVM 的每個 stack slot 都是 256 bits，因此 <code>uint256</code> 和 <code>int256</code> 是最「自然」的整數型別，使用它們通常不會產生額外的 gas 成本。</p>
<p><strong>整數型別</strong> 包括 <code>uint8</code> 到 <code>uint256</code>（以 8 為步進）和對應的有號整數 <code>int8</code> 到 <code>int256</code>。一個常見的誤解是「用 <code>uint8</code> 比 <code>uint256</code> 省 gas」。事實上，EVM 在操作小於 256 bits 的整數時，需要額外的 mask 操作來清除高位元，反而會增加 gas 消耗。只有在 struct 中使用 tight packing 時，較小的整數型別才能真正節省 storage 空間。</p>
<pre><code class="language-solidity">// 錯誤：以為 uint8 省 gas
uint8 public counter;  // 實際上比 uint256 更貴（獨立 slot 時）

// 正確：在 struct 中 tight packing 才有意義
struct PackedData {
    uint128 balance;    // slot 0 的前 128 bits
    uint64 timestamp;   // slot 0 的中間 64 bits
    uint64 nonce;       // slot 0 的後 64 bits
}
// 整個 struct 只佔一個 storage slot (256 bits)
</code></pre>
<p><strong><code>address</code> 型別</strong> 是 20 bytes（160 bits），代表一個 Ethereum 地址。<code>address</code> 和 <code>address payable</code> 有區別——只有 <code>address payable</code> 才有 <code>transfer</code> 和 <code>send</code> 方法，可以接收 ETH。不過在實際開發中，建議統一使用低層的 <code>call</code> 來轉帳，因為 <code>transfer</code> 和 <code>send</code> 有 2300 gas 限制，可能在某些情境下失敗。</p>
<p><strong><code>bytes</code> 和 <code>string</code></strong> 都是動態長度的型別。<code>bytes</code> 用於存放任意二進位資料，<code>string</code> 用於存放 UTF-8 文字。需要注意的是，Solidity 中的 <code>string</code> 不支援直接比較（不能用 <code>==</code>）、不支援取長度、不支援索引存取。如果需要這些操作，要先將 <code>string</code> 轉換為 <code>bytes</code>。</p>
<pre><code class="language-text">Solidity 型別記憶表：

┌─────────────┬──────────────┬───────────────────────────────┐
│   型別       │   大小        │   常見用途                     │
├─────────────┼──────────────┼───────────────────────────────┤
│ uint256     │ 32 bytes     │ 金額、計數器、時間戳            │
│ int256      │ 32 bytes     │ 需要負數的場景（少用）          │
│ bool        │ 1 byte*      │ 開關、狀態旗標                  │
│ address     │ 20 bytes     │ 帳戶、合約地址                  │
│ bytes32     │ 32 bytes     │ Hash 值、固定長度識別碼         │
│ bytes       │ 動態         │ 任意二進位資料                  │
│ string      │ 動態         │ 文字資料（鏈上盡量少用）        │
└─────────────┴──────────────┴───────────────────────────────┘
* bool 在獨立 slot 時仍佔 32 bytes
</code></pre>
<h3 id="722-函數-p0"><a class="header" href="#722-函數-p0">7.2.2 函數 <code>P0</code></a></h3>
<p>函數屬性：</p>
<ul>
<li>可見性：<code>public/external/internal/private</code></li>
<li>狀態屬性：<code>view/pure/payable</code></li>
</ul>
<p>工程建議：</p>
<ul>
<li>對外函數先驗參</li>
<li>寫操作用 custom error</li>
</ul>
<p>函數是智能合約與外部世界互動的介面。正確理解函數的可見性和狀態屬性，是寫出安全合約的基礎。</p>
<p><strong>可見性（Visibility）</strong> 決定了函數可以被誰呼叫。<code>external</code> 函數只能被外部交易或其他合約呼叫，不能在合約內部直接呼叫（除非使用 <code>this.func()</code>）。<code>public</code> 函數既可以被外部呼叫，也可以在內部呼叫。<code>internal</code> 函數只能在合約內部或繼承的子合約中呼叫。<code>private</code> 函數只能在定義它的合約中呼叫，子合約無法存取。</p>
<p>一個重要的工程實踐是：<strong>對外暴露的函數（<code>external</code>/<code>public</code>）應該盡量少</strong>。每多暴露一個函數，就多一個攻擊面。遵循最小權限原則，只暴露必要的介面。</p>
<pre><code class="language-solidity">contract FunctionVisibility {
    // external: 只能從外部呼叫，calldata 不需複製到 memory，省 gas
    function deposit() external payable { ... }

    // public: 內外都能呼叫，但 calldata 需複製
    function getBalance() public view returns (uint256) { ... }

    // internal: 只有本合約和子合約能呼叫
    function _validateInput(uint256 amount) internal pure { ... }

    // private: 只有本合約能呼叫
    function _updateState() private { ... }
}
</code></pre>
<p><strong>狀態屬性（State Mutability）</strong> 標示函數是否會修改鏈上狀態。<code>view</code> 函數只讀取狀態不修改，<code>pure</code> 函數既不讀取也不修改狀態（純計算），<code>payable</code> 函數可以接收 ETH。沒有標示的函數（nonpayable）可以修改狀態但不能接收 ETH。</p>
<pre><code class="language-solidity">contract StateMutability {
    uint256 public total;

    // payable: 可以接收 ETH
    function deposit() external payable {
        total += msg.value;
    }

    // view: 只讀取狀態
    function getTotal() external view returns (uint256) {
        return total;
    }

    // pure: 不存取任何狀態
    function add(uint256 a, uint256 b) external pure returns (uint256) {
        return a + b;
    }

    // nonpayable（預設）: 修改狀態但不接收 ETH
    function reset() external {
        total = 0;
    }
}
</code></pre>
<p><strong>常見陷阱</strong>：忘記在 <code>external</code> 函數開頭做輸入驗證。所有來自外部的輸入都應該被視為不可信的，必須在函數開頭進行完整的參數檢查。</p>
<pre><code class="language-solidity">// 不好的寫法：沒有驗證輸入
function transfer(address to, uint256 amount) external {
    balances[msg.sender] -= amount;  // 可能 underflow（0.8.x 會 revert）
    balances[to] += amount;
}

// 好的寫法：先驗證，再執行
function transfer(address to, uint256 amount) external {
    if (to == address(0)) revert ZeroAddress();
    if (amount == 0) revert ZeroAmount();
    if (balances[msg.sender] &lt; amount) revert InsufficientBalance();

    balances[msg.sender] -= amount;
    balances[to] += amount;
    emit Transfer(msg.sender, to, amount);
}
</code></pre>
<h3 id="723-修飾符-p0"><a class="header" href="#723-修飾符-p0">7.2.3 修飾符 <code>P0</code></a></h3>
<p>modifier 典型用途：</p>
<ul>
<li>權限控制</li>
<li>防重入</li>
<li>狀態檢查</li>
</ul>
<p>Modifier 是 Solidity 提供的一種程式碼重用機制，允許開發者將常見的前置檢查邏輯抽取出來，避免在每個函數中重複撰寫相同的檢查程式碼。</p>
<p>Modifier 的執行流程是：先執行 modifier 中 <code>_</code> 之前的程式碼，然後執行被修飾的函數本體，最後執行 modifier 中 <code>_</code> 之後的程式碼（如果有的話）。多個 modifier 可以組合使用，它們會按照宣告的順序依次嵌套執行。</p>
<pre><code class="language-solidity">contract ModifierExamples {
    address public owner;
    bool private _locked;
    bool public paused;

    // 權限控制 modifier
    modifier onlyOwner() {
        if (msg.sender != owner) revert Unauthorized();
        _;
    }

    // 防重入 modifier（與 OpenZeppelin ReentrancyGuard 類似）
    modifier nonReentrant() {
        if (_locked) revert ReentrancyDetected();
        _locked = true;
        _;
        _locked = false;
    }

    // 狀態檢查 modifier
    modifier whenNotPaused() {
        if (paused) revert ContractPaused();
        _;
    }

    // 組合使用多個 modifier
    function withdraw(uint256 amount) external
        nonReentrant
        whenNotPaused
    {
        // 實際業務邏輯
    }
}
</code></pre>
<p><strong>最佳實踐</strong>：modifier 中不應該包含複雜的業務邏輯，它的職責僅限於「檢查條件」。如果 modifier 中的邏輯太複雜，應該將其拆分為獨立的 internal 函數。另外，modifier 中修改狀態（如 <code>_locked = true</code>）雖然是合法的，但應該謹慎使用，因為這會讓程式碼的控制流變得不直觀。</p>
<h3 id="724-內建對象-p1"><a class="header" href="#724-內建對象-p1">7.2.4 內建對象 <code>P1</code></a></h3>
<p>常用對象：</p>
<ul>
<li><code>msg</code>, <code>block</code>, <code>tx</code></li>
</ul>
<p>注意：避免使用 <code>tx.origin</code> 做授權。</p>
<p>Solidity 提供了幾個全域可用的內建對象，讓合約可以存取交易和區塊鏈的上下文資訊。</p>
<p><strong><code>msg</code> 對象</strong> 包含了當前交易的資訊：</p>
<ul>
<li><code>msg.sender</code>：直接呼叫者的地址（可以是 EOA 或合約）</li>
<li><code>msg.value</code>：隨交易發送的 ETH 數量（以 wei 為單位）</li>
<li><code>msg.data</code>：完整的 calldata</li>
<li><code>msg.sig</code>：calldata 的前 4 bytes（函數選擇器）</li>
</ul>
<p><strong><code>block</code> 對象</strong> 包含了當前區塊的資訊：</p>
<ul>
<li><code>block.timestamp</code>：區塊時間戳（秒）</li>
<li><code>block.number</code>：區塊編號</li>
<li><code>block.basefee</code>：區塊的 base fee</li>
</ul>
<p><strong><code>tx</code> 對象</strong> 包含了交易層級的資訊：</p>
<ul>
<li><code>tx.origin</code>：交易的原始發起者（一定是 EOA）</li>
<li><code>tx.gasprice</code>：交易的 gas 價格</li>
</ul>
<p><strong>重要安全提醒</strong>：<code>tx.origin</code> 和 <code>msg.sender</code> 的區別在於，當 A 呼叫 B、B 再呼叫 C 時，C 中的 <code>msg.sender</code> 是 B，但 <code>tx.origin</code> 是 A。因此，使用 <code>tx.origin</code> 做授權檢查是危險的——攻擊者可以誘騙使用者呼叫惡意合約，惡意合約再呼叫目標合約，此時 <code>tx.origin</code> 仍然是使用者。</p>
<pre><code class="language-text">tx.origin 攻擊示意：

User (EOA)  ───&gt; Malicious Contract ───&gt; Target Contract
                                          │
tx.origin = User     ← 危險！             │
msg.sender = Malicious Contract ← 應該用這個
</code></pre>
<h3 id="725-內建函數-p1"><a class="header" href="#725-內建函數-p1">7.2.5 內建函數 <code>P1</code></a></h3>
<p>常見內建能力：</p>
<ul>
<li><code>keccak256</code></li>
<li><code>abi.encode/encodePacked</code></li>
<li><code>ecrecover</code></li>
</ul>
<p>這些內建函數在智能合約開發中非常常用，理解它們的用途和注意事項很重要。</p>
<p><strong><code>keccak256</code></strong> 是 Ethereum 使用的雜湊函數，接受 <code>bytes</code> 類型的輸入，輸出 32 bytes 的雜湊值。它常用於生成唯一識別碼、驗證資料完整性、以及在 merkle tree 中計算節點雜湊。</p>
<p><strong><code>abi.encode</code> 和 <code>abi.encodePacked</code></strong> 用於將多個值編碼為 bytes。兩者的差異在於 <code>abi.encode</code> 會為每個值補齊到 32 bytes（標準 ABI 編碼），而 <code>abi.encodePacked</code> 不補齊，直接拼接。後者產生的資料更短，但存在碰撞風險——不同的輸入組合可能產生相同的編碼結果。</p>
<pre><code class="language-solidity">// abi.encodePacked 碰撞範例
abi.encodePacked("ab", "c")   // 結果: 0x616263
abi.encodePacked("a", "bc")   // 結果: 0x616263  ← 相同！

// 安全做法：使用 abi.encode 或加入分隔
abi.encode("ab", "c")         // 結果不同於 abi.encode("a", "bc")
</code></pre>
<p><strong><code>ecrecover</code></strong> 用於從 ECDSA 簽名中恢復簽名者的地址。這是實作 meta-transaction、permit 模式、以及鏈下簽名驗證的基礎。使用時必須注意簽名延展性（signature malleability）問題，建議使用 OpenZeppelin 的 ECDSA 庫來做安全的簽名恢復。</p>
<h3 id="726-事務控制-p0"><a class="header" href="#726-事務控制-p0">7.2.6 事務控制 <code>P0</code></a></h3>
<ul>
<li><code>require</code>：輸入與條件檢查</li>
<li><code>revert</code>：主動回滾</li>
<li><code>assert</code>：不變量檢查</li>
</ul>
<p>錯誤處理是智能合約安全性的核心。Solidity 提供了三種錯誤處理機制，它們的用途和行為各不相同。</p>
<p><strong><code>require</code></strong> 用於驗證外部輸入和前置條件。當條件不滿足時，交易會 revert，未消耗的 gas 會退還。<code>require</code> 是最常用的錯誤處理方式，通常放在函數開頭，用於驗證呼叫者權限、參數合法性、狀態前置條件等。</p>
<p><strong><code>revert</code></strong> 可以搭配 custom error 使用，提供更省 gas 且更有結構的錯誤資訊。在 Solidity 0.8.4+ 的專案中，建議用 <code>revert CustomError()</code> 取代 <code>require(condition, "string")</code>。</p>
<p><strong><code>assert</code></strong> 用於檢查不變量（invariant）——即在任何情況下都不應該違反的條件。如果 <code>assert</code> 失敗，通常代表合約存在 bug。在 Solidity 0.8.0+ 中，<code>assert</code> 失敗會 revert 並退還 gas（之前版本會消耗所有 gas）。</p>
<pre><code class="language-solidity">contract ErrorHandling {
    uint256 public totalDeposits;
    uint256 public totalWithdrawals;
    mapping(address =&gt; uint256) public balances;

    error InsufficientBalance(uint256 available, uint256 requested);
    error ZeroAmount();

    function withdraw(uint256 amount) external {
        // require: 驗證外部輸入
        if (amount == 0) revert ZeroAmount();

        // require: 驗證前置條件
        uint256 bal = balances[msg.sender];
        if (bal &lt; amount) revert InsufficientBalance(bal, amount);

        // 更新狀態
        balances[msg.sender] -= amount;
        totalWithdrawals += amount;

        // assert: 檢查不變量（如果失敗代表有 bug）
        assert(totalDeposits &gt;= totalWithdrawals);

        // 外部呼叫
        (bool ok, ) = msg.sender.call{value: amount}("");
        require(ok, "transfer failed");
    }
}
</code></pre>
<h3 id="727-自訂修飾符-p0"><a class="header" href="#727-自訂修飾符-p0">7.2.7 自訂修飾符 <code>P0</code></a></h3>
<p>建議將通用安全檢查抽象成 modifier，避免漏檢。</p>
<p>自訂 modifier 是提升合約程式碼品質的重要工具。當同一個檢查邏輯在多個函數中重複出現時，將其抽取為 modifier 不僅減少了程式碼重複，更重要的是避免了「某個函數忘記加檢查」的風險。</p>
<p>在實際專案中，最常見的自訂 modifier 包括：</p>
<pre><code class="language-solidity">contract CustomModifiers {
    address public owner;
    mapping(address =&gt; bool) public operators;
    uint256 public lastActionTime;

    // 角色權限檢查
    modifier onlyOperator() {
        if (!operators[msg.sender]) revert NotOperator(msg.sender);
        _;
    }

    // 金額範圍檢查
    modifier validAmount(uint256 amount, uint256 min, uint256 max) {
        if (amount &lt; min || amount &gt; max) revert AmountOutOfRange(amount, min, max);
        _;
    }

    // 時間間隔限制（防止頻繁操作）
    modifier cooldown(uint256 interval) {
        if (block.timestamp &lt; lastActionTime + interval) revert CooldownActive();
        _;
        lastActionTime = block.timestamp;
    }

    // 組合使用
    function executeAction(uint256 amount) external
        onlyOperator
        validAmount(amount, 1 ether, 100 ether)
        cooldown(1 hours)
    {
        // 業務邏輯
    }
}
</code></pre>
<p><strong>最佳實踐</strong>：modifier 的命名應該清晰表達其檢查的條件，如 <code>onlyOwner</code>、<code>whenNotPaused</code>、<code>nonReentrant</code>。避免在 modifier 中放太多邏輯，保持它的「守門人」角色。</p>
<h2 id="73-複合資料型態與資料結構-p0"><a class="header" href="#73-複合資料型態與資料結構-p0">7.3 複合資料型態與資料結構 <code>P0</code></a></h2>
<h3 id="731-自訂結構-p0"><a class="header" href="#731-自訂結構-p0">7.3.1 自訂結構 <code>P0</code></a></h3>
<p>用 <code>struct</code> 建模業務狀態，如帳戶、訂單、提案。</p>
<p>Struct 是 Solidity 中最重要的資料建模工具。好的 struct 設計可以讓合約的狀態結構一目了然，同時透過 tight packing 優化 storage 成本。</p>
<pre><code class="language-solidity">// 一個完整的訂單管理範例
contract OrderBook {
    enum OrderStatus { Created, Filled, Cancelled }

    struct Order {
        address maker;       // slot 0: 20 bytes
        uint96 amount;       // slot 0: 12 bytes（與 maker 共用一個 slot）
        address taker;       // slot 1: 20 bytes
        uint64 createdAt;    // slot 1: 8 bytes
        uint32 orderId;      // slot 1: 4 bytes
        OrderStatus status;  // slot 2: 1 byte
    }

    mapping(uint256 =&gt; Order) public orders;
    uint256 public nextOrderId;

    function createOrder(uint96 amount) external returns (uint256) {
        uint256 id = nextOrderId++;
        orders[id] = Order({
            maker: msg.sender,
            amount: amount,
            taker: address(0),
            createdAt: uint64(block.timestamp),
            orderId: uint32(id),
            status: OrderStatus.Created
        });
        return id;
    }
}
</code></pre>
<p><strong>Storage 佈局優化</strong> 是 struct 設計的重要考量。EVM 的 storage 以 32 bytes（256 bits）為一個 slot，讀寫一個 slot 是一次 SSTORE/SLOAD 操作。如果 struct 中的多個小型欄位可以塞進同一個 slot，就能減少 storage 操作次數，節省 gas。</p>
<pre><code class="language-text">Storage Slot 佈局示意（上面 Order struct）：

Slot 0: |-- maker (20 bytes) --|-- amount (12 bytes) --|
Slot 1: |-- taker (20 bytes) --|-- createdAt (8 bytes) --|-- orderId (4 bytes) --|
Slot 2: |-- status (1 byte) --|------ unused (31 bytes) ------|

如果不注意排列順序，可能浪費 slot：
// 壞的排列（浪費空間）
struct BadOrder {
    address maker;       // slot 0: 20 bytes + 12 bytes 浪費
    uint256 amount;      // slot 1: 32 bytes（獨佔一個 slot）
    address taker;       // slot 2: 20 bytes + 12 bytes 浪費
}
// 用了 3 個 slot

// 好的排列（tight packing）
struct GoodOrder {
    uint256 amount;      // slot 0: 32 bytes
    address maker;       // slot 1: 20 bytes
    address taker;       //        + 20 bytes... 不行，超過 32 bytes
}
// 所以實際上要用 uint96 等較小型別來做 packing
</code></pre>
<h3 id="732-數組和動態數組-p0"><a class="header" href="#732-數組和動態數組-p0">7.3.2 數組和動態數組 <code>P0</code></a></h3>
<ul>
<li>固定長度陣列：成本可預期</li>
<li>動態陣列：彈性高，需留意 gas</li>
</ul>
<p>Solidity 中的陣列分為固定長度和動態長度兩種。固定長度陣列在編譯時就確定大小，storage 佈局可預測；動態陣列的大小在運行時決定，其元素儲存在由 <code>keccak256(slot)</code> 計算出的位置。</p>
<pre><code class="language-solidity">contract ArrayExamples {
    // 固定長度陣列：適合已知大小的資料
    address[3] public admins;

    // 動態陣列：適合大小不確定的資料
    address[] public members;

    // 新增元素
    function addMember(address member) external {
        members.push(member);  // gas 成本隨陣列增長不變（O(1)）
    }

    // 刪除元素（注意：delete 只會清零，不會縮短陣列）
    function removeMember(uint256 index) external {
        // 方法1：與最後一個元素交換後 pop（O(1)，不保順序）
        members[index] = members[members.length - 1];
        members.pop();
    }

    // 遍歷（危險操作！）
    function getAllMembers() external view returns (address[] memory) {
        return members;  // 如果陣列很大，可能超過 gas 上限
    }
}
</code></pre>
<p><strong>常見陷阱</strong>：在合約中遍歷一個無界動態陣列是非常危險的做法。如果陣列長度不斷增長，遍歷的 gas 消耗會最終超過區塊 gas 上限，導致函數永遠無法執行。這是一種 DoS（拒絕服務）漏洞。解決方案包括：設定陣列長度上限、使用分批處理（pagination）、或改用 mapping 結構。</p>
<h3 id="733-映射-p0"><a class="header" href="#733-映射-p0">7.3.3 映射 <code>P0</code></a></h3>
<p><code>mapping</code> 適合做 key-value 狀態索引。</p>
<p>注意：mapping 不可直接遍歷，常需外部索引或輔助陣列。</p>
<p>Mapping 是 Solidity 中最常用的資料結構，類似於其他語言的 hash table 或 dictionary。它的讀寫操作都是 O(1) 的，非常適合做帳戶餘額、授權關係、配置參數等 key-value 形式的狀態儲存。</p>
<pre><code class="language-solidity">contract MappingExamples {
    // 基本 mapping
    mapping(address =&gt; uint256) public balances;

    // 巢狀 mapping（二維索引）
    mapping(address =&gt; mapping(address =&gt; uint256)) public allowances;

    // mapping + struct
    mapping(uint256 =&gt; Order) public orders;

    // mapping 不可遍歷的解法：輔助陣列
    address[] public allUsers;
    mapping(address =&gt; bool) public isUser;

    function register() external {
        if (!isUser[msg.sender]) {
            isUser[msg.sender] = true;
            allUsers.push(msg.sender);
        }
    }

    // 可以遍歷 allUsers 陣列來間接「遍歷」mapping
    function getUserCount() external view returns (uint256) {
        return allUsers.length;
    }
}
</code></pre>
<p>Mapping 的底層儲存方式是：每個 key-value pair 的 storage 位置由 <code>keccak256(key, slot)</code> 計算而來。這意味著 mapping 中不存在的 key 會返回型別的預設值（如 <code>uint256</code> 返回 0、<code>address</code> 返回 <code>address(0)</code>、<code>bool</code> 返回 <code>false</code>），而不會拋出錯誤。這是一個需要特別注意的行為——你無法區分「key 存在但值為 0」和「key 不存在」的情況，除非額外維護一個 <code>exists</code> mapping。</p>
<h3 id="734-address類型-p0"><a class="header" href="#734-address類型-p0">7.3.4 address類型 <code>P0</code></a></h3>
<p>address 是權限與資產轉移核心型別。</p>
<p>常見操作：</p>
<ul>
<li><code>address(this)</code></li>
<li><code>payable(addr).transfer(...)</code></li>
</ul>
<p><code>address</code> 型別在 Solidity 中佔據核心地位，因為 Ethereum 的帳戶模型就是以地址為基礎的。每個合約、每個外部帳戶都有一個唯一的 20 bytes 地址。</p>
<pre><code class="language-solidity">contract AddressOperations {
    // 查詢地址的 ETH 餘額
    function getBalance(address addr) external view returns (uint256) {
        return addr.balance;
    }

    // 三種轉帳方式的比較
    function sendETH(address payable to, uint256 amount) external {
        // 方式1: transfer - 固定 2300 gas，失敗會 revert
        // 不推薦：2300 gas 可能不夠（如果接收方是合約）
        to.transfer(amount);

        // 方式2: send - 固定 2300 gas，失敗返回 false
        // 不推薦：容易忘記檢查返回值
        bool success = to.send(amount);
        require(success, "send failed");

        // 方式3: call - 可以指定 gas，推薦使用
        (bool ok, ) = to.call{value: amount}("");
        require(ok, "call failed");
    }

    // 檢查地址是否為合約
    function isContract(address addr) external view returns (bool) {
        uint256 size;
        assembly {
            size := extcodesize(addr)
        }
        return size &gt; 0;
        // 注意：constructor 執行期間 extcodesize 為 0
    }
}
</code></pre>
<p><strong>最佳實踐</strong>：統一使用 <code>call</code> 進行 ETH 轉帳，搭配 <code>require</code> 檢查返回值。<code>transfer</code> 和 <code>send</code> 的 2300 gas 上限在 Istanbul 硬分叉後可能導致某些合約的 <code>receive</code> 函數無法正常執行。</p>
<h3 id="735-memory與storage-p0"><a class="header" href="#735-memory與storage-p0">7.3.5 memory與storage <code>P0</code></a></h3>
<ul>
<li><code>storage</code>：鏈上持久狀態</li>
<li><code>memory</code>：函數暫存</li>
</ul>
<p>常見坑：</p>
<ul>
<li>對 storage 引用誤改全局狀態</li>
<li>未理解 copy/reference 行為</li>
</ul>
<p>資料位置（data location）是 Solidity 中最容易讓新手犯錯的概念之一。理解 <code>storage</code>、<code>memory</code> 和 <code>calldata</code> 的差異，以及它們之間的複製/引用行為，是避免嚴重 bug 的關鍵。</p>
<p><strong><code>storage</code></strong> 是區塊鏈上的持久儲存。所有狀態變數都儲存在 storage 中。讀取 storage 的 gas 成本是 2100（cold）或 100（warm），寫入 storage 的成本是 5000（非零值寫入已有 slot）或 20000（零值寫入新 slot）。因此，storage 操作是智能合約中最昂貴的操作之一。</p>
<p><strong><code>memory</code></strong> 是函數執行期間的暫存空間。函數結束後 memory 被清除。Memory 的讀寫成本遠低於 storage，但 memory 的大小會影響 gas 消耗（memory 擴展有二次方成本）。</p>
<p><strong><code>calldata</code></strong> 是外部函數參數的儲存位置，是只讀的。對於 <code>external</code> 函數的陣列和 struct 參數，使用 <code>calldata</code> 比 <code>memory</code> 更省 gas，因為不需要複製資料。</p>
<pre><code class="language-solidity">contract DataLocation {
    struct User {
        string name;
        uint256 balance;
    }

    User[] public users;

    // 危險：storage 引用直接修改狀態！
    function dangerousUpdate(uint256 index) internal {
        User storage user = users[index];  // 這是引用，不是複製
        user.balance = 0;  // 直接修改了鏈上狀態！
    }

    // 安全：memory 複製不影響狀態
    function safeRead(uint256 index) internal view returns (uint256) {
        User memory user = users[index];  // 這是複製
        return user.balance;  // 讀取複製的資料
    }

    // 省 gas：calldata 不需複製
    function processData(uint256[] calldata data) external pure returns (uint256) {
        uint256 sum;
        for (uint256 i; i &lt; data.length; ++i) {
            sum += data[i];
        }
        return sum;
    }
}
</code></pre>
<pre><code class="language-text">資料位置的複製/引用行為：

storage -&gt; storage  = 引用（指向同一個 slot）
storage -&gt; memory   = 複製（獨立副本）
memory  -&gt; storage  = 複製（寫入鏈上）
memory  -&gt; memory   = 引用（指向同一段 memory）
calldata -&gt; memory  = 複製
calldata -&gt; storage = 複製
</code></pre>
<h2 id="74-solidity物件導向編程-p0"><a class="header" href="#74-solidity物件導向編程-p0">7.4 Solidity物件導向編程 <code>P0</code></a></h2>
<h3 id="741-接口-p0"><a class="header" href="#741-接口-p0">7.4.1 接口 <code>P0</code></a></h3>
<p>interface 用於描述外部合約函數簽名，支援跨合約調用。</p>
<p>Interface（介面）在 Solidity 中扮演「合約之間的契約」角色。它定義了一組函數簽名，但不包含任何實作。任何實作該介面的合約都必須提供這些函數的具體實作。這讓不同的合約可以透過一致的介面互相呼叫，而不需要知道對方的內部實作細節。</p>
<pre><code class="language-solidity">// 定義介面
interface IERC20 {
    function totalSupply() external view returns (uint256);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}

// 透過介面呼叫外部合約
contract TokenVault {
    function depositToken(address token, uint256 amount) external {
        // 不需要知道 token 合約的具體實作
        // 只需要知道它實作了 IERC20 介面
        IERC20(token).transferFrom(msg.sender, address(this), amount);
    }
}
</code></pre>
<p>介面的限制：不能有狀態變數、不能有 constructor、不能有 modifier、所有函數必須是 <code>external</code>。這些限制確保了介面只描述「行為」而不描述「實作」。</p>
<p>在實際專案中，ERC 標準（如 ERC-20、ERC-721）就是以介面的形式定義的。使用標準介面可以確保合約與現有的生態系統（錢包、交易所、DApp）相容。</p>
<h3 id="742-函數選擇器與接口id-p0"><a class="header" href="#742-函數選擇器與接口id-p0">7.4.2 函數選擇器與接口ID <code>P0</code></a></h3>
<ul>
<li>selector：函數簽名 hash 前 4 bytes</li>
<li>interface id：常見於 ERC-165 能力探測</li>
</ul>
<p>當外部交易呼叫合約函數時，EVM 如何知道要執行哪個函數？答案是「函數選擇器」（function selector）。交易的 calldata 前 4 bytes 就是函數選擇器，它是函數簽名的 keccak256 hash 的前 4 bytes。</p>
<pre><code class="language-solidity">contract SelectorExample {
    // transfer(address,uint256) 的選擇器
    // keccak256("transfer(address,uint256)") = 0xa9059cbb...
    // 取前 4 bytes: 0xa9059cbb

    function getSelector() external pure returns (bytes4) {
        return this.transfer.selector;  // 0xa9059cbb
    }

    function transfer(address to, uint256 amount) external returns (bool) {
        // ...
    }
}
</code></pre>
<p><strong>Interface ID</strong> 是 ERC-165 標準定義的概念。一個介面的 ID 是該介面中所有函數選擇器的 XOR 結果。合約可以實作 <code>supportsInterface(bytes4)</code> 函數，讓外部查詢者知道這個合約支援哪些介面。這在 NFT 市場、DApp 等場景中很常用——例如，一個 NFT 市場需要檢查某個合約是否真的是 ERC-721 合約。</p>
<pre><code class="language-solidity">interface IERC165 {
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

contract MyNFT is IERC165 {
    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {
        return interfaceId == type(IERC721).interfaceId
            || interfaceId == type(IERC165).interfaceId;
    }
}
</code></pre>
<h3 id="743-library-p1"><a class="header" href="#743-library-p1">7.4.3 library <code>P1</code></a></h3>
<p>library 適合抽離通用邏輯，提升重用性。</p>
<p>Library 是 Solidity 中一種特殊的合約型別，用於封裝可重用的邏輯。Library 不能有狀態變數，不能接收 ETH，不能被繼承。它的函數可以透過 <code>using ... for</code> 語法附加到任何型別上，使程式碼更易讀。</p>
<pre><code class="language-solidity">// 定義一個 library
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c &gt;= a, "overflow");
        return c;
    }
}

// 自定義型別的 library（更實用的範例）
library ArrayUtils {
    /// @dev 在陣列中查找元素，返回 index。找不到返回 type(uint256).max
    function indexOf(address[] storage arr, address target)
        internal view returns (uint256)
    {
        for (uint256 i; i &lt; arr.length; ++i) {
            if (arr[i] == target) return i;
        }
        return type(uint256).max;
    }

    /// @dev 安全移除元素（swap and pop）
    function removeByValue(address[] storage arr, address target) internal {
        uint256 idx = indexOf(arr, target);
        require(idx != type(uint256).max, "not found");
        arr[idx] = arr[arr.length - 1];
        arr.pop();
    }
}

contract MemberRegistry {
    using ArrayUtils for address[];

    address[] private members;

    function removeMember(address member) external {
        members.removeByValue(member);  // 像呼叫方法一樣使用 library
    }
}
</code></pre>
<p><strong>部署方式</strong>：Library 中的 <code>internal</code> 函數會被內聯到呼叫合約中（不產生 DELEGATECALL）。<code>public</code> 或 <code>external</code> 函數則會被獨立部署，呼叫時使用 DELEGATECALL。在大多數情況下，建議將 library 函數標記為 <code>internal</code>，以避免跨合約呼叫的額外 gas 成本。</p>
<h3 id="744-合約繼承-p0"><a class="header" href="#744-合約繼承-p0">7.4.4 合約繼承 <code>P0</code></a></h3>
<p>繼承可以重用代碼，但要注意線性化與 override 規則。</p>
<p>Solidity 支援多重繼承，使用 C3 線性化（C3 linearization）來解決繼承順序的歧義。理解線性化規則對於正確使用繼承非常重要，特別是在使用 <code>super</code> 關鍵字時。</p>
<pre><code class="language-solidity">// 繼承範例
contract Ownable {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) public virtual onlyOwner {
        owner = newOwner;
    }
}

contract Pausable is Ownable {
    bool public paused;

    modifier whenNotPaused() {
        require(!paused);
        _;
    }

    function pause() external onlyOwner {
        paused = true;
    }
}

// 多重繼承
contract MyToken is Ownable, Pausable {
    mapping(address =&gt; uint256) public balances;

    // 必須 override 所有父合約的同名函數
    function transferOwnership(address newOwner) public override onlyOwner {
        // 呼叫 super 會按照 C3 線性化順序呼叫父合約
        super.transferOwnership(newOwner);
    }

    function transfer(address to, uint256 amount) external whenNotPaused {
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
}
</code></pre>
<pre><code class="language-text">C3 線性化範例：

contract A { }
contract B is A { }
contract C is A { }
contract D is B, C { }  // 繼承順序：D -&gt; C -&gt; B -&gt; A

呼叫 super 時的執行順序：
D.func() -&gt; C.func() -&gt; B.func() -&gt; A.func()
</code></pre>
<p><strong>常見陷阱</strong>：</p>
<ol>
<li>繼承順序影響 storage layout，修改順序可能破壞已部署合約的狀態</li>
<li><code>virtual</code> 和 <code>override</code> 關鍵字必須正確使用，否則編譯失敗</li>
<li>Constructor 的執行順序是從最基底的合約開始，到最衍生的合約結束</li>
</ol>
<h3 id="745-abstract關鍵字-p1"><a class="header" href="#745-abstract關鍵字-p1">7.4.5 abstract關鍵字 <code>P1</code></a></h3>
<p>abstract contract 用於定義未完整實作的基底規範。</p>
<p>Abstract contract 介於 interface 和完整合約之間。它可以包含已實作的函數和狀態變數，但同時也可以包含未實作的（abstract）函數。Abstract contract 不能被直接部署，必須被子合約繼承並實作所有 abstract 函數後才能部署。</p>
<pre><code class="language-solidity">abstract contract BaseVault {
    address public owner;
    uint256 public totalDeposits;

    // 已實作的通用邏輯
    constructor() {
        owner = msg.sender;
    }

    function deposit() external payable {
        totalDeposits += msg.value;
        _onDeposit(msg.sender, msg.value);  // 呼叫抽象函數
    }

    // 抽象函數：子合約必須實作
    function _onDeposit(address user, uint256 amount) internal virtual;

    // 抽象函數：提款策略由子合約決定
    function withdraw(uint256 amount) external virtual;
}

// 具體實作：簡單金庫
contract SimpleVault is BaseVault {
    mapping(address =&gt; uint256) public balances;

    function _onDeposit(address user, uint256 amount) internal override {
        balances[user] += amount;
    }

    function withdraw(uint256 amount) external override {
        require(balances[msg.sender] &gt;= amount);
        balances[msg.sender] -= amount;
        (bool ok, ) = msg.sender.call{value: amount}("");
        require(ok);
    }
}

// 具體實作：定期金庫（有鎖定期）
contract TimelockVault is BaseVault {
    mapping(address =&gt; uint256) public balances;
    mapping(address =&gt; uint256) public lockUntil;
    uint256 public lockDuration = 30 days;

    function _onDeposit(address user, uint256 amount) internal override {
        balances[user] += amount;
        lockUntil[user] = block.timestamp + lockDuration;
    }

    function withdraw(uint256 amount) external override {
        require(block.timestamp &gt;= lockUntil[msg.sender], "locked");
        require(balances[msg.sender] &gt;= amount);
        balances[msg.sender] -= amount;
        (bool ok, ) = msg.sender.call{value: amount}("");
        require(ok);
    }
}
</code></pre>
<p>Abstract contract 最適合用在「框架模式」——定義好通用的流程和介面，讓具體的實作由子合約來決定。這在 DeFi 協議中非常常見，例如一個借貸協議的 BasePool 可以定義通用的存款/提款流程，而不同的資產池（ETH Pool、USDC Pool）各自實作利率計算邏輯。</p>
<h2 id="75-章節回顧與工程思維整理"><a class="header" href="#75-章節回顧與工程思維整理">7.5 章節回顧與工程思維整理</a></h2>
<p>本章從智能合約的基本概念出發，涵蓋了 Solidity 語言的核心語法、資料結構、以及物件導向設計。以下是幾個需要銘記的工程原則：</p>
<p><strong>狀態建模是合約設計的核心。</strong> 在寫任何一行 Solidity 程式碼之前，先問自己：這個合約需要追蹤哪些狀態？這些狀態之間的轉換規則是什麼？誰有權觸發狀態轉換？把這些問題想清楚，合約的骨架就出來了。</p>
<p><strong>權限控制不是可選的。</strong> 每一個可以修改狀態的 external/public 函數，都需要考慮：誰應該被允許呼叫？在什麼條件下可以呼叫？呼叫的參數有什麼限制？遺漏任何一個檢查，都可能成為攻擊向量。</p>
<p><strong>錯誤處理決定了合約的健壯性。</strong> 使用 custom error 取代 require 字串，不僅省 gas，還能提供更好的錯誤資訊。為所有不變量（invariant）加上 assert 檢查，可以在早期發現邏輯錯誤。</p>
<p><strong>Gas 意識應該從第一天就建立。</strong> 不需要過早優化，但需要知道哪些操作是昂貴的（storage 寫入、大陣列遍歷、跨合約呼叫），哪些操作是便宜的（memory 操作、pure 計算）。在設計階段就做出正確的資料結構選擇，比後期優化有效得多。</p>
<p><strong>測試先行，部署謹慎。</strong> 智能合約不像 Web 應用可以隨時修補，一旦部署就很難修改。因此，完整的測試覆蓋率（包括 edge case、fuzz testing、invariant testing）不是奢侈品，而是必需品。先用 Foundry 或 Hardhat 在本地鏈上徹底測試，再部署到測試網，最後才上主網。</p>
<h2 id="白話總結-19"><a class="header" href="#白話總結-19">白話總結</a></h2>
<p>Solidity 就是寫在區塊鏈上的程式，跟你平常寫的後端程式最大的不同在於：一旦部署就改不了（或者說改的成本超高），而且每一行程式碼跑起來都要燒錢（gas fee）。所以你不能像寫 Web App 一樣「先上線再說、有 bug 明天修」，而是要在寫之前就把所有可能出包的情況想清楚。合約本質上就是一個狀態機，有三個核心元素：State 存資料、Function 改資料、Event 通知外面的人「資料改了」。寫函數的時候最重要的是先做各種檢查（誰有權限呼叫？參數合不合法？狀態對不對？），檢查完了再改資料，最後才做外部呼叫——這就是 CEI 模式。資料結構方面，mapping 是你的好朋友，但要記得它不能遍歷；陣列可以遍歷但別讓它無限增長。Storage 和 memory 的差異一定要搞懂，搞混了輕則浪費 gas，重則直接改到鏈上狀態。開發環境推薦用 Foundry，測試寫在 Solidity 裡面比較直覺，而且內建 fuzz testing 很實用。最後記住：OpenZeppelin 已經實作好的東西就直接用，不要自己重新發明輪子。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第8章-solidity智能合約開發進階"><a class="header" href="#第8章-solidity智能合約開發進階">第8章 Solidity智能合約開發進階</a></h1>
<p>本章目標是把合約能力提升到可上線等級：標準、升級、架構模式、安全最佳實踐與 Python 調用。</p>
<h2 id="81-solidity經典案例"><a class="header" href="#81-solidity經典案例">8.1 Solidity經典案例</a></h2>
<h3 id="811-智能合約開發的一般步驟-p1"><a class="header" href="#811-智能合約開發的一般步驟-p1">8.1.1 智能合約開發的一般步驟 <code>P1</code></a></h3>
<p>通用流程：</p>
<ol>
<li>寫規格與狀態機</li>
<li>先寫測試（unit/fuzz/invariant）</li>
<li>實作合約</li>
<li>審計與修補</li>
<li>部署與監控</li>
</ol>
<p>智能合約開發不同於傳統軟體開發的最大差異在於：<strong>部署後幾乎不可修改</strong>。這意味著整個開發流程必須「前置重」——在撰寫程式碼之前就投入大量時間在規格設計和威脅建模上。</p>
<p><strong>第一步：規格與狀態機設計</strong>。在動手寫任何 Solidity 程式碼之前，先用文字或圖表描述合約的狀態轉換。例如一個拍賣合約可以有 <code>Created -&gt; Bidding -&gt; Ended -&gt; Settled</code> 四個狀態，每個狀態轉換的條件（誰可以觸發、前置條件、後置條件）都要明確定義。這一步看似多餘，但實際上能避免 80% 的設計錯誤。</p>
<pre><code class="language-text">拍賣合約狀態機範例：

  ┌──────────┐   startAuction()   ┌──────────┐   endAuction()   ┌──────────┐
  │ Created  │ ─────────────────&gt; │ Bidding  │ ─────────────────&gt; │  Ended   │
  └──────────┘   (onlyOwner)      └──────────┘   (time expired)   └──────────┘
                                       │                               │
                                  bid()│                        settle()│
                                       │                               │
                                  [更新最高出價]                   ┌──────────┐
                                  [退還前一出價]                   │ Settled  │
                                                                  └──────────┘
                                                              [轉帳給賣家]
                                                              [退還未中標出價]
</code></pre>
<p><strong>第二步：先寫測試</strong>。TDD（Test-Driven Development）在智能合約開發中不是可選的，而是必要的。使用 Foundry 可以在 Solidity 中直接寫測試，包括：</p>
<ul>
<li><strong>Unit Test</strong>：測試單一函數的正確行為</li>
<li><strong>Fuzz Test</strong>：用隨機輸入測試函數在各種邊界條件下的行為</li>
<li><strong>Invariant Test</strong>：定義合約的不變量，讓測試框架在大量隨機操作後驗證不變量是否被破壞</li>
</ul>
<pre><code class="language-solidity">// Foundry 測試範例
contract AuctionTest is Test {
    Auction auction;

    function setUp() public {
        auction = new Auction();
    }

    // Unit test
    function test_bid_updates_highest_bidder() public {
        auction.startAuction();
        auction.bid{value: 1 ether}();
        assertEq(auction.highestBidder(), address(this));
    }

    // Fuzz test：用隨機金額測試
    function testFuzz_bid_amount(uint256 amount) public {
        vm.assume(amount &gt; 0 &amp;&amp; amount &lt; 100 ether);
        vm.deal(address(this), amount);
        auction.startAuction();
        auction.bid{value: amount}();
        assertEq(auction.highestBid(), amount);
    }

    // 測試預期 revert
    function test_cannot_bid_after_end() public {
        auction.startAuction();
        vm.warp(block.timestamp + 7 days + 1);  // 時間快轉
        vm.expectRevert(Auction.AuctionEnded.selector);
        auction.bid{value: 1 ether}();
    }
}
</code></pre>
<p><strong>第三步至第五步</strong>：實作合約後，必須經過至少一次外部審計（audit）。對於管理大量資金的合約，建議進行兩次以上的獨立審計。部署後還需要設置監控系統，即時偵測異常交易模式（如短時間內大量資金流出、非預期的函數呼叫等）。</p>
<h3 id="812-土豪發紅包-p2"><a class="header" href="#812-土豪發紅包-p2">8.1.2 土豪發紅包 <code>P2</code></a></h3>
<p>練習重點：</p>
<ul>
<li>批量分發</li>
<li>名單驗證</li>
<li>防重複領取</li>
</ul>
<p>「發紅包」是一個很好的入門練習案例，因為它涉及了智能合約開發的幾個核心問題：如何安全地向多個地址分發資金、如何防止同一個人重複領取、以及如何處理剩餘資金。</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract RedPacket {
    address public creator;
    uint256 public totalAmount;
    uint256 public remainingAmount;
    uint256 public maxRecipients;
    uint256 public claimedCount;
    bool public isRandom;

    mapping(address =&gt; bool) public hasClaimed;

    error AlreadyClaimed();
    error PacketEmpty();
    error NotEnoughFunds();

    event Claimed(address indexed recipient, uint256 amount);
    event Created(address indexed creator, uint256 total, uint256 count);

    constructor(uint256 _maxRecipients, bool _isRandom) payable {
        require(msg.value &gt; 0, "must send ETH");
        require(_maxRecipients &gt; 0, "must have recipients");

        creator = msg.sender;
        totalAmount = msg.value;
        remainingAmount = msg.value;
        maxRecipients = _maxRecipients;
        isRandom = _isRandom;

        emit Created(msg.sender, msg.value, _maxRecipients);
    }

    function claim() external {
        if (hasClaimed[msg.sender]) revert AlreadyClaimed();
        if (claimedCount &gt;= maxRecipients) revert PacketEmpty();
        if (remainingAmount == 0) revert PacketEmpty();

        hasClaimed[msg.sender] = true;
        claimedCount++;

        uint256 amount;
        if (claimedCount == maxRecipients) {
            // 最後一個人拿走剩餘全部
            amount = remainingAmount;
        } else if (isRandom) {
            // 隨機金額（注意：鏈上隨機不安全，僅做練習）
            amount = _pseudoRandom() % (remainingAmount * 2 / (maxRecipients - claimedCount + 1));
            if (amount == 0) amount = 1;
        } else {
            // 平均分配
            amount = totalAmount / maxRecipients;
        }

        remainingAmount -= amount;

        (bool ok, ) = msg.sender.call{value: amount}("");
        require(ok, "transfer failed");

        emit Claimed(msg.sender, amount);
    }

    function _pseudoRandom() private view returns (uint256) {
        // 不安全的隨機數，僅做練習用途
        return uint256(keccak256(abi.encodePacked(
            block.timestamp, block.prevrandao, msg.sender, claimedCount
        )));
    }
}
</code></pre>
<p><strong>工程要點</strong>：</p>
<ol>
<li><strong>防重複領取</strong>：使用 <code>mapping(address =&gt; bool)</code> 記錄已領取地址，在函數開頭就檢查</li>
<li><strong>最後一人清底</strong>：避免精度問題導致少量資金永久鎖定在合約中</li>
<li><strong>鏈上隨機數的局限</strong>：<code>block.prevrandao</code> 可以被驗證者操控，真正的隨機需要使用 Chainlink VRF 等 oracle 服務</li>
<li><strong>Gas 考量</strong>：批量操作（如一次發給 100 人）可能超過 gas 上限，應該改用 claim 模式（讓接收者主動領取）</li>
</ol>
<h3 id="813-我要開銀行-p1"><a class="header" href="#813-我要開銀行-p1">8.1.3 我要開銀行 <code>P1</code></a></h3>
<p>練習重點：</p>
<ul>
<li>存取款模型</li>
<li>權限與限額</li>
<li>事件記錄與對帳</li>
</ul>
<p>銀行合約是理解「狀態管理 + 權限控制 + 安全轉帳」的最佳練習。一個可靠的銀行合約需要處理存款、提款、利息計算、以及管理員操作等邏輯。</p>
<pre><code class="language-solidity">contract SimpleBank {
    struct Account {
        uint256 balance;
        uint256 lastDepositTime;
        bool isActive;
    }

    address public owner;
    mapping(address =&gt; Account) public accounts;
    uint256 public totalDeposits;

    uint256 public constant MAX_WITHDRAWAL = 10 ether;
    uint256 public constant WITHDRAWAL_COOLDOWN = 1 hours;

    mapping(address =&gt; uint256) public lastWithdrawalTime;

    error ExceedsLimit(uint256 requested, uint256 limit);
    error CooldownActive(uint256 nextAvailable);
    error InsufficientBalance(uint256 available, uint256 requested);

    event Deposited(address indexed user, uint256 amount, uint256 newBalance);
    event Withdrawn(address indexed user, uint256 amount, uint256 newBalance);

    function deposit() external payable {
        require(msg.value &gt; 0, "zero deposit");

        Account storage acct = accounts[msg.sender];
        acct.balance += msg.value;
        acct.lastDepositTime = block.timestamp;
        acct.isActive = true;

        totalDeposits += msg.value;
        emit Deposited(msg.sender, msg.value, acct.balance);
    }

    function withdraw(uint256 amount) external {
        Account storage acct = accounts[msg.sender];

        // 1. 檢查餘額
        if (acct.balance &lt; amount)
            revert InsufficientBalance(acct.balance, amount);

        // 2. 檢查單次限額
        if (amount &gt; MAX_WITHDRAWAL)
            revert ExceedsLimit(amount, MAX_WITHDRAWAL);

        // 3. 檢查冷卻期
        uint256 nextTime = lastWithdrawalTime[msg.sender] + WITHDRAWAL_COOLDOWN;
        if (block.timestamp &lt; nextTime)
            revert CooldownActive(nextTime);

        // 4. 更新狀態（CEI: Effects before Interactions）
        acct.balance -= amount;
        totalDeposits -= amount;
        lastWithdrawalTime[msg.sender] = block.timestamp;

        // 5. 轉帳
        (bool ok, ) = msg.sender.call{value: amount}("");
        require(ok, "transfer failed");

        emit Withdrawn(msg.sender, amount, acct.balance);
    }
}
</code></pre>
<p>這個案例的核心教學點在於：<strong>每一個可能修改資金的操作，都需要多層防護</strong>——餘額檢查、限額檢查、冷卻期檢查、CEI 模式、事件記錄。這些看似繁瑣的檢查，在真實的 DeFi 協議中是標準配備。</p>
<h3 id="814-智能拍賣-p1"><a class="header" href="#814-智能拍賣-p1">8.1.4 智能拍賣 <code>P1</code></a></h3>
<p>練習重點：</p>
<ul>
<li>出價排序</li>
<li>截止時間</li>
<li>未中標退款安全性</li>
</ul>
<p>拍賣合約是展示「外部呼叫安全性」的經典案例。核心挑戰在於：當有新的最高出價時，需要退還前一個出價者的資金。如果退款失敗（例如接收方是一個會 revert 的合約），整個出價操作都會失敗，導致拍賣被惡意阻塞。</p>
<pre><code class="language-solidity">contract Auction {
    address public seller;
    uint256 public endTime;
    address public highestBidder;
    uint256 public highestBid;

    // 使用 Pull Payment 模式避免退款失敗阻塞出價
    mapping(address =&gt; uint256) public pendingReturns;

    error AuctionEnded();
    error BidTooLow(uint256 current, uint256 minimum);
    error AuctionNotEnded();

    event NewBid(address indexed bidder, uint256 amount);
    event AuctionSettled(address winner, uint256 amount);

    constructor(uint256 duration) {
        seller = msg.sender;
        endTime = block.timestamp + duration;
    }

    function bid() external payable {
        if (block.timestamp &gt;= endTime) revert AuctionEnded();
        if (msg.value &lt;= highestBid) revert BidTooLow(highestBid, highestBid + 1);

        // 將前一個最高出價記入待退款（Pull Payment）
        if (highestBidder != address(0)) {
            pendingReturns[highestBidder] += highestBid;
        }

        highestBidder = msg.sender;
        highestBid = msg.value;

        emit NewBid(msg.sender, msg.value);
    }

    // Pull Payment：出價者主動提取被退回的資金
    function withdrawBid() external {
        uint256 amount = pendingReturns[msg.sender];
        require(amount &gt; 0, "nothing to withdraw");

        pendingReturns[msg.sender] = 0;  // CEI: 先清零再轉帳

        (bool ok, ) = msg.sender.call{value: amount}("");
        require(ok, "withdraw failed");
    }

    function settle() external {
        if (block.timestamp &lt; endTime) revert AuctionNotEnded();

        (bool ok, ) = seller.call{value: highestBid}("");
        require(ok, "settle failed");

        emit AuctionSettled(highestBidder, highestBid);
    }
}
</code></pre>
<pre><code class="language-text">Push vs Pull Payment 模式：

Push Payment（危險）：
  bid() -&gt; 直接退款給前一出價者 -&gt; 如果退款失敗，整個 bid 失敗
  攻擊者：部署一個 receive() 會 revert 的合約來阻塞拍賣

Pull Payment（安全）：
  bid() -&gt; 記錄待退款金額 -&gt; 出價正常完成
  withdrawBid() -&gt; 出價者自己來提取退款 -&gt; 失敗只影響自己

┌──────────────────────────────────────────┐
│ Pull Payment 是智能合約中處理退款的       │
│ 標準模式，避免外部呼叫失敗影響核心邏輯   │
└──────────────────────────────────────────┘
</code></pre>
<p><strong>真實案例教訓</strong>：2016 年的 King of the Ether 合約就是因為使用了 Push Payment 模式，被惡意合約阻塞退款導致拍賣無法繼續。這個事件推動了 Pull Payment 模式成為業界標準。</p>
<h2 id="82-erc標準-p0"><a class="header" href="#82-erc標準-p0">8.2 ERC標準 <code>P0</code></a></h2>
<h3 id="821-erc概述-p0"><a class="header" href="#821-erc概述-p0">8.2.1 ERC概述 <code>P0</code></a></h3>
<p>ERC 是互操作標準，讓錢包、交易所、DApp 可以一致整合。</p>
<p>ERC（Ethereum Request for Comments）是 Ethereum 社群制定的標準提案系統。ERC 標準的核心價值在於<strong>互操作性</strong>——當一個 token 合約遵循 ERC-20 標準時，任何支援 ERC-20 的錢包、交易所、DApp 都可以無縫整合它，不需要為每個 token 寫客製化的程式碼。</p>
<p>ERC 標準的制定流程是：任何人都可以在 Ethereum 的 GitHub 提交 EIP（Ethereum Improvement Proposal），經過社群討論、修改、審核後成為正式標準。並非所有 EIP 都會成為 ERC——ERC 特指應用層標準（如 token、NFT、帳戶抽象等），而 EIP 還包括核心協議變更、網路層變更等。</p>
<pre><code class="language-text">主要 ERC 標準一覽：

┌───────────┬─────────────────┬───────────────────────────────┐
│  標準      │  類型            │  用途                          │
├───────────┼─────────────────┼───────────────────────────────┤
│ ERC-20    │ Fungible Token  │ 同質化代幣（USDT, LINK 等）    │
│ ERC-721   │ Non-Fungible    │ NFT（BAYC, CryptoPunks）       │
│ ERC-1155  │ Multi Token     │ 批量 NFT + FT 混合             │
│ ERC-165   │ Interface       │ 合約能力探測                   │
│ ERC-2612  │ Permit          │ 免 approve 的 token 授權       │
│ ERC-4626  │ Tokenized Vault │ 標準化的收益金庫               │
│ ERC-4337  │ Account Abstact │ 帳戶抽象                       │
└───────────┴─────────────────┴───────────────────────────────┘
</code></pre>
<p>工程上的建議：<strong>永遠使用 OpenZeppelin 的標準實作作為基底</strong>，而不是自己從頭實作 ERC 標準。自行實作不僅容易有 bug，還可能與其他生態系統的實作產生不相容。</p>
<h3 id="822-erc-20標準-p0"><a class="header" href="#822-erc-20標準-p0">8.2.2 ERC-20標準 <code>P0</code></a></h3>
<p>核心函數：</p>
<ul>
<li><code>transfer</code></li>
<li><code>approve</code></li>
<li><code>transferFrom</code></li>
<li><code>balanceOf</code></li>
</ul>
<p>常見坑：</p>
<ul>
<li>allowance 覆蓋競態</li>
<li>decimals 顯示錯誤</li>
</ul>
<p>ERC-20 是最重要、使用最廣泛的 token 標準。幾乎所有的 DeFi 協議（Uniswap、Aave、Compound 等）都是圍繞 ERC-20 token 建構的。理解 ERC-20 的每一個函數和事件，是進入 DeFi 開發的門票。</p>
<p><strong>核心互動流程</strong>：ERC-20 的轉帳有兩種模式。第一種是直接轉帳——使用者呼叫 <code>transfer(to, amount)</code> 直接將 token 從自己的帳戶轉到目標地址。第二種是授權轉帳——使用者先呼叫 <code>approve(spender, amount)</code> 授權某個地址（通常是合約）可以花費自己的 token，然後被授權方呼叫 <code>transferFrom(from, to, amount)</code> 來執行轉帳。</p>
<pre><code class="language-text">ERC-20 兩種轉帳模式：

模式 1: 直接轉帳
User ──── transfer(to, amount) ────&gt; Token Contract
                                         │
                                    balances[user] -= amount
                                    balances[to]   += amount

模式 2: 授權轉帳（DeFi 常用）
Step 1: User ──── approve(DEX, amount) ────&gt; Token Contract
                                                 │
                                            allowance[user][DEX] = amount

Step 2: DEX ──── transferFrom(user, pool, amount) ────&gt; Token Contract
                                                            │
                                                    check: allowance[user][DEX] &gt;= amount
                                                    allowance[user][DEX] -= amount
                                                    balances[user] -= amount
                                                    balances[pool] += amount
</code></pre>
<p><strong>Allowance 覆蓋競態（Race Condition）</strong> 是 ERC-20 最著名的安全問題之一。假設 Alice 先 approve Bob 100 token，之後想改為 50 token。如果 Bob 在 Alice 修改之前搶先使用了 100 token 的 allowance，然後 Alice 的新 approve(50) 交易才上鏈，Bob 就能再使用 50 token，總共花了 150 token 而非預期的 50 token。</p>
<p>解決方案有兩個：一是先 approve(0)，再 approve(newAmount)；二是使用 <code>increaseAllowance</code> 和 <code>decreaseAllowance</code> 函數（OpenZeppelin 提供）。更好的做法是使用 ERC-2612 的 permit 機制，完全避開 approve 步驟。</p>
<p><strong>Decimals 陷阱</strong>：ERC-20 token 的 <code>decimals</code> 只是一個顯示屬性，不影響合約內部的數值運算。例如 USDT 的 decimals 是 6，意味著 1 USDT = 1,000,000（10^6）最小單位。但 DAI 的 decimals 是 18，1 DAI = 10^18 最小單位。在做 token 之間的兌換計算時，必須特別注意 decimals 的差異，否則金額會差好幾個數量級。</p>
<pre><code class="language-solidity">// Decimals 計算範例
// USDT: 6 decimals, DAI: 18 decimals

// 錯誤：直接比較不同 decimals 的數值
// 1 USDT = 1_000_000
// 1 DAI  = 1_000_000_000_000_000_000
// 這兩個數值完全不同！

// 正確：統一到相同精度後再比較
function normalizeAmount(
    uint256 amount,
    uint8 fromDecimals,
    uint8 toDecimals
) internal pure returns (uint256) {
    if (fromDecimals &gt; toDecimals) {
        return amount / 10**(fromDecimals - toDecimals);
    } else if (fromDecimals &lt; toDecimals) {
        return amount * 10**(toDecimals - fromDecimals);
    }
    return amount;
}
</code></pre>
<h3 id="823-erc-165標準-p0"><a class="header" href="#823-erc-165標準-p0">8.2.3 ERC-165標準 <code>P0</code></a></h3>
<p>用途：合約能力探測（<code>supportsInterface</code>）。</p>
<p>ERC-165 解決了一個實際問題：當你有一個合約地址時，如何知道這個合約實作了哪些介面？在傳統軟體中，你可以用反射（reflection）來檢查物件是否實作了某個介面；在 Solidity 中，ERC-165 提供了類似的機制。</p>
<pre><code class="language-solidity">// ERC-165 的核心介面
interface IERC165 {
    /// @notice 查詢合約是否支援某個介面
    /// @param interfaceId 介面識別碼（4 bytes）
    /// @return true 如果合約實作了該介面
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// 實際應用：NFT 市場在處理拍賣品之前，先檢查合約類型
contract NFTMarketplace {
    bytes4 constant ERC721_ID = 0x80ac58cd;
    bytes4 constant ERC1155_ID = 0xd9b67a26;

    function listItem(address tokenContract, uint256 tokenId) external {
        // 先檢查合約類型
        if (IERC165(tokenContract).supportsInterface(ERC721_ID)) {
            // 按 ERC-721 邏輯處理
            IERC721(tokenContract).transferFrom(msg.sender, address(this), tokenId);
        } else if (IERC165(tokenContract).supportsInterface(ERC1155_ID)) {
            // 按 ERC-1155 邏輯處理
            IERC1155(tokenContract).safeTransferFrom(
                msg.sender, address(this), tokenId, 1, ""
            );
        } else {
            revert("unsupported token standard");
        }
    }
}
</code></pre>
<p>ERC-165 的 gas 成本很低（只是一個 view 函數），但提供了重要的安全保障——避免盲目呼叫一個不支援預期介面的合約。在編寫需要與多種 token 標準互動的協議（如 NFT 市場、跨鏈橋）時，ERC-165 檢查是必要的前置步驟。</p>
<h3 id="824-erc-721nft標準-p1"><a class="header" href="#824-erc-721nft標準-p1">8.2.4 ERC-721（NFT標準） <code>P1</code></a></h3>
<p>重點：</p>
<ul>
<li>單 token 唯一性</li>
<li>metadata 管理</li>
<li>批量 mint 與授權策略</li>
</ul>
<p>ERC-721 是 NFT（Non-Fungible Token）的標準介面。與 ERC-20 不同，ERC-721 中的每個 token 都是獨一無二的，由一個唯一的 <code>tokenId</code> 來識別。這使得 ERC-721 適合代表獨特的數位資產，如數位藝術品、遊戲道具、域名、房地產證書等。</p>
<pre><code class="language-solidity">// ERC-721 的核心函數
interface IERC721 {
    function balanceOf(address owner) external view returns (uint256);
    function ownerOf(uint256 tokenId) external view returns (address);
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
    function transferFrom(address from, address to, uint256 tokenId) external;
    function approve(address to, uint256 tokenId) external;
    function setApprovalForAll(address operator, bool approved) external;
    function getApproved(uint256 tokenId) external view returns (address);
    function isApprovedForAll(address owner, address operator) external view returns (bool);
}
</code></pre>
<p><strong>Metadata 管理</strong> 是 ERC-721 的重要組成部分。每個 NFT 通常需要關聯名稱、描述、圖片等元資料。這些元資料通常不儲存在鏈上（太貴了），而是存放在 IPFS 或其他去中心化儲存系統上，鏈上只存一個 URI（透過 <code>tokenURI(uint256 tokenId)</code> 函數返回）。</p>
<pre><code class="language-text">NFT Metadata 架構：

┌──────────────┐     tokenURI()     ┌──────────────┐     ┌──────────────┐
│  ERC-721     │ ─────────────────&gt; │   IPFS /     │ ──&gt; │  JSON        │
│  Contract    │   返回 URI         │   Arweave    │     │  Metadata    │
│              │                    │              │     │              │
│ tokenId: 42  │                    │ ipfs://Qm... │     │ {            │
│ owner: 0x... │                    └──────────────┘     │   "name":    │
└──────────────┘                                         │   "image":   │
                                                         │   "attrs":[] │
                                                         │ }            │
                                                         └──────────────┘
</code></pre>
<p><strong>批量 Mint 優化</strong>：標準 ERC-721 的 mint 操作每次只能 mint 一個 token，每次都需要寫入 storage。ERC-721A（由 Azuki 團隊開發）通過批量 mint 優化大幅降低了 gas 成本——mint N 個 token 的 gas 成本幾乎等於 mint 1 個 token。其原理是延遲初始化：批量 mint 時只記錄起始 tokenId 和擁有者，在後續 transfer 時才逐一初始化。</p>
<p><strong>安全轉帳</strong>：<code>safeTransferFrom</code> 在轉帳前會檢查接收方是否實作了 <code>onERC721Received</code> 介面。這防止了 token 被意外發送到無法處理 NFT 的合約地址（導致 token 永久鎖定）。但同時也引入了重入風險——接收方的 <code>onERC721Received</code> callback 可能進行惡意操作。</p>
<h2 id="83-可升級合約-p0"><a class="header" href="#83-可升級合約-p0">8.3 可升級合約 <code>P0</code></a></h2>
<h3 id="831-不可篡改與可升級之間的矛盾-p0"><a class="header" href="#831-不可篡改與可升級之間的矛盾-p0">8.3.1 不可篡改與可升級之間的矛盾 <code>P0</code></a></h3>
<p>矛盾點：</p>
<ul>
<li>不可變保安全與可預期</li>
<li>可升級保可維護與修復</li>
</ul>
<p>平衡做法：</p>
<ul>
<li>Proxy + Timelock + 多簽治理</li>
</ul>
<p>區塊鏈的核心價值之一是「不可篡改」（immutability）——一旦部署的規則就無法被任何人修改，使用者可以信任程式碼就是規則。但現實中，合約可能有 bug 需要修復、功能需要擴展、或者外部依賴（如 oracle）需要更新。這就產生了一個根本性的矛盾。</p>
<p>業界的解決方案是 <strong>Proxy Pattern</strong>（代理模式）。基本原理是：使用者與一個不可變的 Proxy 合約互動，Proxy 合約透過 <code>delegatecall</code> 將邏輯執行委託給另一個可替換的 Implementation 合約。更換 Implementation 合約的地址就相當於「升級」了合約。</p>
<pre><code class="language-text">Proxy 升級模式架構：

使用者視角（地址不變）：
┌──────────┐     ┌──────────────────────┐
│  User    │────&gt;│  Proxy Contract      │  &lt;── 永久地址，使用者只跟它互動
│          │     │  (不可變)             │
└──────────┘     │  - storage 在這裡     │
                 │  - delegatecall ─────&gt;│──┐
                 └──────────────────────┘  │
                                           │
                 ┌──────────────────────┐  │    ┌──────────────────────┐
                 │  Implementation V1   │&lt;─┘    │  Implementation V2   │
                 │  (可替換)            │       │  (升級後的新版)       │
                 │  - 只有邏輯          │       │  - 新增功能 + 修 bug  │
                 │  - 無 storage        │       │  - storage layout 相容│
                 └──────────────────────┘       └──────────────────────┘

升級流程：
1. 部署 Implementation V2
2. 多簽提案：將 Proxy 指向 V2
3. Timelock 延遲（如 48 小時）
4. 執行升級
</code></pre>
<p>但升級能力本身就是一個攻擊面。如果升級的權限被單一私鑰控制，那麼持有這把私鑰的人可以將合約升級為惡意版本，把所有使用者的資金偷走。因此，升級權限必須有嚴格的治理機制：</p>
<ol>
<li><strong>多簽錢包（Multisig）</strong>：升級需要 M-of-N 的簽名，例如 3/5 的核心團隊成員同意</li>
<li><strong>時間鎖（Timelock）</strong>：升級提案需要等待一定時間（如 48 小時）才能執行，給社群審查的機會</li>
<li><strong>治理投票（Governance）</strong>：大型協議可能需要 token 持有者投票通過升級提案</li>
</ol>
<h3 id="832-跨合約調用-p0"><a class="header" href="#832-跨合約調用-p0">8.3.2 跨合約調用 <code>P0</code></a></h3>
<p>跨合約是組合能力來源，也是攻擊面來源。</p>
<p>要點：</p>
<ul>
<li>外部調用前先更新內部狀態</li>
<li>外部合約回傳值必檢查</li>
</ul>
<p>跨合約呼叫是 DeFi 「可組合性」（composability）的基礎——一個借貸合約可以呼叫 DEX 合約來清算抵押品，一個收益聚合器可以呼叫多個底層協議來尋找最佳收益。但每一次跨合約呼叫都是一次「控制權轉移」，被呼叫的合約可能執行任何程式碼，包括回呼呼叫方（重入攻擊）。</p>
<pre><code class="language-solidity">// 跨合約呼叫的正確方式
contract LendingPool {
    IERC20 public token;
    mapping(address =&gt; uint256) public deposits;

    function liquidate(address borrower, uint256 amount) external {
        // 1. 先更新內部狀態（CEI 的 Effects）
        deposits[borrower] -= amount;

        // 2. 再做外部呼叫（CEI 的 Interactions）
        // 呼叫 DEX 合約賣出抵押品
        bool success = token.transfer(msg.sender, amount);
        require(success, "transfer failed");

        // 3. 如果外部呼叫有返回值，必須檢查
        // 注意：有些 ERC-20 token 的 transfer 不返回 bool（如 USDT）
        // 使用 OpenZeppelin 的 SafeERC20 可以安全處理這種情況
    }
}
</code></pre>
<pre><code class="language-solidity">// 使用 SafeERC20 處理非標準 token
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

contract SafeVault {
    using SafeERC20 for IERC20;

    function deposit(IERC20 token, uint256 amount) external {
        // safeTransferFrom 會自動處理：
        // 1. 不返回值的 token（如 USDT）
        // 2. 返回 false 的 token
        token.safeTransferFrom(msg.sender, address(this), amount);
    }
}
</code></pre>
<h3 id="833-透過底層函數呼叫合約-p0"><a class="header" href="#833-透過底層函數呼叫合約-p0">8.3.3 透過底層函數呼叫合約 <code>P0</code></a></h3>
<p><code>call/delegatecall/staticcall</code> 使用要點：</p>
<ul>
<li>僅在必要時用底層調用</li>
<li>必須檢查 success 與返回資料</li>
</ul>
<p>Solidity 提供了三種底層呼叫方式，它們在不同場景下各有用途：</p>
<pre><code class="language-text">三種底層呼叫的差異：

┌─────────────┬────────────────────┬───────────────┬────────────────┐
│   方式       │   程式碼來源        │   storage     │   msg.sender   │
├─────────────┼────────────────────┼───────────────┼────────────────┤
│ call        │ 目標合約           │ 目標合約       │ 呼叫方合約      │
│ delegatecall│ 目標合約           │ 呼叫方合約     │ 原始呼叫者      │
│ staticcall  │ 目標合約           │ 只讀           │ 呼叫方合約      │
└─────────────┴────────────────────┴───────────────┴────────────────┘
</code></pre>
<p><strong><code>call</code></strong> 是最常用的底層呼叫方式。它在目標合約的 context 中執行程式碼，使用目標合約的 storage。適用場景：呼叫未知介面的外部合約、轉帳 ETH。</p>
<p><strong><code>delegatecall</code></strong> 是 Proxy 模式的核心。它從目標合約載入程式碼，但在呼叫方的 context 中執行，使用呼叫方的 storage 和 msg.sender。這就是為什麼 Proxy 可以「借用」Implementation 的邏輯但保留自己的狀態。</p>
<p><strong><code>staticcall</code></strong> 是只讀版的 call。它保證被呼叫的函數不會修改任何狀態。<code>view</code> 函數在外部呼叫時就是使用 staticcall。</p>
<pre><code class="language-solidity">contract LowLevelCalls {
    // call 範例：呼叫未知介面的合約
    function callExternal(address target, bytes calldata data)
        external returns (bool, bytes memory)
    {
        (bool success, bytes memory result) = target.call(data);

        // 必須檢查 success！
        // 不檢查 = 靜默失敗 = 資金損失
        require(success, "call failed");

        return (success, result);
    }

    // delegatecall 範例（Proxy 模式核心）
    fallback() external payable {
        address impl = _getImplementation();

        assembly {
            // 複製 calldata
            calldatacopy(0, 0, calldatasize())

            // delegatecall 到 implementation
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)

            // 複製返回資料
            returndatacopy(0, 0, returndatasize())

            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
}
</code></pre>
<p><strong>常見陷阱</strong>：底層呼叫失敗時不會自動 revert，而是返回 <code>success = false</code>。如果忘記檢查 success，合約會繼續執行後續邏輯，可能導致嚴重的狀態不一致。</p>
<h3 id="834-主從式可升級合約-p1"><a class="header" href="#834-主從式可升級合約-p1">8.3.4 主—從式可升級合約 <code>P1</code></a></h3>
<p>主從模式可隔離邏輯與配置，但需清楚權限邊界。</p>
<p>主從式（Master-Slave）升級模式是一種相對簡單的升級策略。主合約（Master）持有核心狀態和控制邏輯，從合約（Slave）實作具體的業務邏輯。升級時，部署新的從合約，然後更新主合約中的從合約地址即可。</p>
<pre><code class="language-solidity">// 主合約：持有狀態和路由邏輯
contract Master {
    address public owner;
    address public calculator;  // 可替換的從合約

    mapping(address =&gt; uint256) public balances;

    function setCalculator(address newCalc) external {
        require(msg.sender == owner);
        calculator = newCalc;
    }

    function calculateReward(address user) external view returns (uint256) {
        // 將計算邏輯委託給從合約
        return ICalculator(calculator).compute(balances[user]);
    }
}

// 從合約 V1
contract CalculatorV1 is ICalculator {
    function compute(uint256 balance) external pure returns (uint256) {
        return balance * 5 / 100;  // 5% 獎勵
    }
}

// 從合約 V2（升級後）
contract CalculatorV2 is ICalculator {
    function compute(uint256 balance) external pure returns (uint256) {
        if (balance &gt; 100 ether) return balance * 8 / 100;  // 大戶 8%
        return balance * 5 / 100;  // 一般 5%
    }
}
</code></pre>
<p>這種模式的優勢是簡單直觀，但缺點是只能升級被隔離出去的邏輯，無法修改主合約本身的程式碼。對於需要更靈活升級能力的場景，應該使用完整的 Proxy 模式。</p>
<h3 id="835-代理程式儲存式可升級合約-p0"><a class="header" href="#835-代理程式儲存式可升級合約-p0">8.3.5 代理程式—儲存式可升級合約 <code>P0</code></a></h3>
<p>Proxy 模式關鍵：</p>
<ul>
<li>storage layout 不可破壞</li>
<li>initializer 只能執行一次</li>
<li>升級權限需多簽與延遲</li>
</ul>
<p>Proxy 模式是目前業界最主流的合約升級方案。OpenZeppelin 提供了三種 Proxy 實作：Transparent Proxy、UUPS（Universal Upgradeable Proxy Standard）、和 Beacon Proxy。</p>
<p><strong>Transparent Proxy</strong> 是最早也最廣泛使用的 Proxy 模式。它的核心概念是：admin 呼叫 Proxy 時會執行管理函數（如 upgrade），其他人呼叫時會 delegatecall 到 implementation。</p>
<p><strong>UUPS</strong> 是更新的標準（ERC-1822），升級邏輯放在 implementation 合約中而非 proxy 中。優勢是 proxy 合約更簡單、部署更便宜。</p>
<pre><code class="language-solidity">// UUPS 可升級合約範例（使用 OpenZeppelin）
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";

contract VaultV1 is Initializable, UUPSUpgradeable, OwnableUpgradeable {
    mapping(address =&gt; uint256) public balances;
    uint256 public totalDeposits;

    // 不能用 constructor！用 initialize 代替
    function initialize() public initializer {
        __Ownable_init(msg.sender);
        __UUPSUpgradeable_init();
    }

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        totalDeposits += msg.value;
    }

    // UUPS: 升級授權函數
    function _authorizeUpgrade(address newImplementation)
        internal override onlyOwner {}
}

// 升級版本 V2
contract VaultV2 is Initializable, UUPSUpgradeable, OwnableUpgradeable {
    // 必須保留 V1 的所有狀態變數，順序不可變
    mapping(address =&gt; uint256) public balances;
    uint256 public totalDeposits;

    // 新增狀態變數只能加在最後面
    uint256 public withdrawalFee;  // 新功能：提款手續費

    function deposit() external payable {
        balances[msg.sender] += msg.value;
        totalDeposits += msg.value;
    }

    // 新增函數
    function setWithdrawalFee(uint256 fee) external onlyOwner {
        withdrawalFee = fee;
    }

    function _authorizeUpgrade(address newImplementation)
        internal override onlyOwner {}
}
</code></pre>
<p><strong>Storage Layout 的黃金規則</strong>：</p>
<ol>
<li>不能刪除已有的狀態變數</li>
<li>不能改變已有狀態變數的順序</li>
<li>不能改變已有狀態變數的型別</li>
<li>新增的狀態變數只能加在最後面</li>
<li>如果使用繼承，不能在父合約中插入新的狀態變數</li>
</ol>
<pre><code class="language-text">Storage Layout 正確升級範例：

V1 Layout:                    V2 Layout（正確）:
┌─── slot 0: balances ───┐    ┌─── slot 0: balances ───┐
├─── slot 1: totalDep ───┤    ├─── slot 1: totalDep ───┤
└────────────────────────┘    ├─── slot 2: fee ────────┤  &lt;── 新增在最後
                               └────────────────────────┘

V2 Layout（錯誤！）:
┌─── slot 0: fee ────────┐  &lt;── 插入在前面，破壞了原有佈局！
├─── slot 1: balances ───┤      balances 讀到的值是 totalDep
├─── slot 2: totalDep ───┤      totalDep 讀到的值是 0
└────────────────────────┘
</code></pre>
<p><strong>Initializer 只能執行一次</strong>：由於 Proxy 合約不能使用 constructor（constructor 是在部署時執行的，但 Proxy 的邏輯是 delegatecall 來的），初始化邏輯必須放在 <code>initialize</code> 函數中，並搭配 <code>initializer</code> modifier 確保它只能被呼叫一次。如果忘記加這個保護，任何人都可以重新初始化合約，奪取管理權限。</p>
<h2 id="84-合約開發最佳實踐-p0"><a class="header" href="#84-合約開發最佳實踐-p0">8.4 合約開發最佳實踐 <code>P0</code></a></h2>
<h3 id="841-最佳實務概述-p0"><a class="header" href="#841-最佳實務概述-p0">8.4.1 最佳實務概述 <code>P0</code></a></h3>
<ul>
<li>權限最小化</li>
<li>事件完整記錄</li>
<li>失敗可回滾</li>
<li>測試先行</li>
</ul>
<p>這四條原則看起來簡單，但在實際開發中經常被忽略。讓我們逐一深入探討。</p>
<p><strong>權限最小化（Principle of Least Privilege）</strong> 意味著每個函數、每個角色只應該擁有完成其任務所需的最小權限。不要給一個只需要暫停合約的 admin 同時擁有提取所有資金的權限。OpenZeppelin 的 AccessControl 合約提供了基於角色的權限管理，比單一的 <code>onlyOwner</code> 更靈活。</p>
<pre><code class="language-solidity">import "@openzeppelin/contracts/access/AccessControl.sol";

contract SecureVault is AccessControl {
    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
    bytes32 public constant WITHDRAWER_ROLE = keccak256("WITHDRAWER_ROLE");

    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        // 不同角色分開授權，避免單一私鑰掌控一切
    }

    function pause() external onlyRole(PAUSER_ROLE) { ... }
    function emergencyWithdraw() external onlyRole(WITHDRAWER_ROLE) { ... }
}
</code></pre>
<p><strong>事件完整記錄</strong> 是合約可審計性的基礎。每一個修改狀態的操作都應該 emit 對應的事件，包括操作者、操作內容、操作結果。這不僅是最佳實踐，在某些場景下（如 token 合約）甚至是標準要求。事件也是 DApp 前端和索引服務（The Graph、Dune Analytics）的資料來源。</p>
<p><strong>失敗可回滾</strong> 意味著合約的任何操作都應該是原子性的——要麼全部成功，要麼全部回滾。Solidity 的 revert 機制天然支持這一點，但在涉及多個外部呼叫的複雜操作中，需要特別注意部分成功的情況。</p>
<p><strong>測試先行（Test First）</strong> 在智能合約開發中比傳統軟體更加重要。一個好的測試套件應該包括正常路徑測試、邊界條件測試、權限測試（確認未授權用戶被拒絕）、以及 fuzz testing。</p>
<h3 id="842-工廠模式-p1"><a class="header" href="#842-工廠模式-p1">8.4.2 工廠模式 <code>P1</code></a></h3>
<p>用工廠合約批量部署同類合約，提高一致性。</p>
<p>工廠模式（Factory Pattern）是當你需要部署多個相同類型合約時的標準做法。例如，Uniswap 的 Factory 合約負責為每一個 token pair 部署一個獨立的 Pool 合約。</p>
<pre><code class="language-solidity">contract PoolFactory {
    mapping(address =&gt; mapping(address =&gt; address)) public getPool;
    address[] public allPools;

    event PoolCreated(address indexed token0, address indexed token1, address pool);

    function createPool(address tokenA, address tokenB) external returns (address) {
        require(tokenA != tokenB, "identical tokens");
        require(getPool[tokenA][tokenB] == address(0), "pool exists");

        // 使用 CREATE2 確保地址可預測
        bytes32 salt = keccak256(abi.encodePacked(tokenA, tokenB));
        Pool pool = new Pool{salt: salt}(tokenA, tokenB);

        getPool[tokenA][tokenB] = address(pool);
        getPool[tokenB][tokenA] = address(pool);
        allPools.push(address(pool));

        emit PoolCreated(tokenA, tokenB, address(pool));
        return address(pool);
    }
}
</code></pre>
<p>使用 <code>CREATE2</code> 的優勢是合約地址可以在部署前就計算出來，這在許多 DeFi 場景中很有用——例如，前端可以在 Pool 被創建之前就顯示預期的 Pool 地址。</p>
<h3 id="843-儲存註冊表模式-p1"><a class="header" href="#843-儲存註冊表模式-p1">8.4.3 儲存註冊表模式 <code>P1</code></a></h3>
<p>中心註冊表管理版本、地址與參數，利於治理。</p>
<p>Registry Pattern 適用於需要管理多個合約地址或配置參數的系統。一個中心化的 Registry 合約儲存所有相關合約的地址和版本資訊，其他合約透過查詢 Registry 來獲取最新的地址。</p>
<pre><code class="language-solidity">contract Registry {
    address public owner;

    // 名稱 -&gt; 版本 -&gt; 地址
    mapping(bytes32 =&gt; mapping(uint256 =&gt; address)) public contracts;
    mapping(bytes32 =&gt; uint256) public currentVersion;

    event ContractRegistered(bytes32 indexed name, uint256 version, address addr);

    function register(string calldata name, address addr) external {
        require(msg.sender == owner);
        bytes32 key = keccak256(abi.encodePacked(name));
        uint256 version = ++currentVersion[key];
        contracts[key][version] = addr;
        emit ContractRegistered(key, version, addr);
    }

    function getContract(string calldata name) external view returns (address) {
        bytes32 key = keccak256(abi.encodePacked(name));
        return contracts[key][currentVersion[key]];
    }
}

// 其他合約透過 Registry 獲取依賴
contract LendingPool {
    Registry public registry;

    function getPriceOracle() internal view returns (IPriceOracle) {
        address oracle = registry.getContract("PriceOracle");
        return IPriceOracle(oracle);
    }
}
</code></pre>
<p>Registry 模式的好處是：升級某個子系統時，只需要在 Registry 中更新地址，所有依賴它的合約都會自動使用新版本。但缺點是引入了中心化的依賴——如果 Registry 的 owner 被盜，攻擊者可以將合約指向惡意實作。因此 Registry 的管理權限也需要多簽和時間鎖保護。</p>
<h3 id="844-遍歷表疊代器-p1"><a class="header" href="#844-遍歷表疊代器-p1">8.4.4 遍歷表疊代器 <code>P1</code></a></h3>
<p>避免鏈上大迴圈，採分批與游標式遍歷。</p>
<p>在鏈上遍歷大型資料集是一個常見但危險的操作。如果資料集的大小不受限制，遍歷的 gas 消耗最終會超過區塊 gas 上限，導致函數永久無法執行。這是一種 DoS 攻擊向量。</p>
<pre><code class="language-solidity">contract PaginatedIterator {
    address[] public users;

    // 錯誤做法：無界迴圈
    function distributeRewardsBAD() external {
        // 如果 users 有 10000 個，可能超過 gas 上限
        for (uint256 i; i &lt; users.length; i++) {
            _sendReward(users[i]);
        }
    }

    // 正確做法：分批處理
    function distributeRewards(uint256 startIndex, uint256 batchSize) external {
        uint256 end = startIndex + batchSize;
        if (end &gt; users.length) end = users.length;

        for (uint256 i = startIndex; i &lt; end; i++) {
            _sendReward(users[i]);
        }
    }

    // 更好的做法：使用 Merkle Proof + Claim 模式
    // 不需要遍歷，使用者自己來領取
    bytes32 public merkleRoot;

    function claimReward(
        uint256 amount,
        bytes32[] calldata proof
    ) external {
        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amount));
        require(MerkleProof.verify(proof, merkleRoot, leaf), "invalid proof");
        // 發放獎勵...
    }
}
</code></pre>
<p><strong>Merkle Proof + Claim 模式</strong> 是大規模空投或獎勵分發的最佳實踐。運營方在鏈下計算好每個使用者的獎勵金額，構建 Merkle Tree，將 root 存到鏈上。使用者提供 Merkle Proof 來領取自己的獎勵。這種模式完全避免了鏈上遍歷，gas 成本固定且低廉。</p>
<h3 id="845-避免重入攻擊-p0"><a class="header" href="#845-避免重入攻擊-p0">8.4.5 避免重入攻擊 <code>P0</code></a></h3>
<p>防禦組合：</p>
<ul>
<li>CEI</li>
<li>reentrancy guard</li>
<li>pull payment</li>
</ul>
<p>重入攻擊（Reentrancy Attack）是智能合約最著名的安全漏洞，2016 年的 The DAO 被盜事件就是因為這個漏洞。理解重入攻擊的原理和防禦方法，是每個智能合約開發者的必修課。</p>
<p><strong>攻擊原理</strong>：當合約 A 呼叫合約 B（例如轉帳 ETH）時，B 的 <code>receive</code> 或 <code>fallback</code> 函數會被觸發。如果 B 在這個函數中回呼 A 的某個函數（例如再次提款），而 A 在第一次呼叫中還沒有更新狀態（如扣除餘額），B 就可以重複提款。</p>
<pre><code class="language-text">重入攻擊流程：

Attacker                          Vulnerable Contract
   │                                     │
   │  1. withdraw(1 ETH)                 │
   │ ──────────────────────────────────&gt; │
   │                                     │ check: balance[attacker] &gt;= 1 ETH ✓
   │                                     │ send 1 ETH to attacker
   │  2. receive() { withdraw(1 ETH) }  │ &lt;── 還沒扣除餘額！
   │ ──────────────────────────────────&gt; │
   │                                     │ check: balance[attacker] &gt;= 1 ETH ✓（還沒扣！）
   │                                     │ send 1 ETH to attacker
   │  3. receive() { withdraw(1 ETH) }  │ &lt;── 還是沒扣！
   │ ──────────────────────────────────&gt; │
   │                                     │ ... 重複直到合約餘額為零
</code></pre>
<p><strong>三層防禦組合</strong>：</p>
<pre><code class="language-solidity">contract SecureVault {
    mapping(address =&gt; uint256) public balances;
    bool private _locked;

    // 防禦 1: Reentrancy Guard
    modifier nonReentrant() {
        require(!_locked, "reentrant");
        _locked = true;
        _;
        _locked = false;
    }

    // 防禦 2: CEI (Checks-Effects-Interactions)
    function withdraw(uint256 amount) external nonReentrant {
        // Checks
        require(balances[msg.sender] &gt;= amount, "insufficient");

        // Effects（先更新狀態）
        balances[msg.sender] -= amount;

        // Interactions（最後才做外部呼叫）
        (bool ok, ) = msg.sender.call{value: amount}("");
        require(ok, "transfer failed");
    }

    // 防禦 3: Pull Payment（最安全）
    mapping(address =&gt; uint256) public pendingWithdrawals;

    function requestWithdrawal(uint256 amount) external {
        require(balances[msg.sender] &gt;= amount);
        balances[msg.sender] -= amount;
        pendingWithdrawals[msg.sender] += amount;
    }

    function claimWithdrawal() external nonReentrant {
        uint256 amount = pendingWithdrawals[msg.sender];
        require(amount &gt; 0);
        pendingWithdrawals[msg.sender] = 0;
        (bool ok, ) = msg.sender.call{value: amount}("");
        require(ok);
    }
}
</code></pre>
<p><strong>實務建議</strong>：在大多數場景中，CEI + ReentrancyGuard 的組合就足夠了。Pull Payment 主要用在拍賣、空投等需要向多人退款的場景。</p>
<h3 id="846-警惕外部合約調用-p0"><a class="header" href="#846-警惕外部合約調用-p0">8.4.6 警惕外部合約調用 <code>P0</code></a></h3>
<p>外部調用要當成不可信：</p>
<ul>
<li>可能回滾</li>
<li>可能耗盡 gas</li>
<li>可能惡意 callback</li>
</ul>
<p>外部合約呼叫是智能合約安全的重災區。每一次呼叫外部合約，都相當於把控制權暫時交給了一段你不知道內容的程式碼。</p>
<p><strong>可能回滾</strong>：被呼叫的合約可能無條件 revert，導致呼叫方的整個交易失敗。如果你的邏輯依賴外部呼叫的成功，需要有備用方案。</p>
<p><strong>可能耗盡 gas</strong>：被呼叫的合約可能執行大量計算，消耗掉分配給它的所有 gas。在 Solidity 中，外部呼叫預設會轉發除 1/64 外的所有剩餘 gas。</p>
<p><strong>可能惡意 callback</strong>：如前面討論的重入攻擊，被呼叫的合約可能在 callback 中回呼你的合約。</p>
<pre><code class="language-solidity">// 安全的外部呼叫模式
contract SafeExternalCall {
    // 1. 使用 try/catch 處理可能失敗的呼叫
    function safeTokenTransfer(IERC20 token, address to, uint256 amount)
        internal returns (bool)
    {
        try token.transfer(to, amount) returns (bool success) {
            return success;
        } catch {
            // 記錄失敗，不讓整個交易 revert
            emit TransferFailed(address(token), to, amount);
            return false;
        }
    }

    // 2. 限制外部呼叫的 gas
    function limitedGasCall(address target, bytes calldata data)
        external returns (bool)
    {
        // 只給 50000 gas，防止被消耗太多
        (bool ok, ) = target.call{gas: 50000}(data);
        return ok;
    }

    // 3. 使用 deadline 防止交易被延遲執行
    function swapWithDeadline(
        address pool,
        uint256 amountIn,
        uint256 minAmountOut,
        uint256 deadline
    ) external {
        require(block.timestamp &lt;= deadline, "expired");
        // ... 執行 swap
    }
}
</code></pre>
<h2 id="85-python與智能合約調用-p0"><a class="header" href="#85-python與智能合約調用-p0">8.5 Python與智能合約調用 <code>P0</code></a></h2>
<h3 id="851-rpc原理分析-p0"><a class="header" href="#851-rpc原理分析-p0">8.5.1 RPC原理分析 <code>P0</code></a></h3>
<p>RPC 是節點對外接口，典型方法：</p>
<ul>
<li><code>eth_call</code></li>
<li><code>eth_estimateGas</code></li>
<li><code>eth_sendRawTransaction</code></li>
</ul>
<p>JSON-RPC 是 Ethereum 節點對外提供服務的標準協議。理解 RPC 的工作原理，是使用任何 SDK（包括 web3.py）的基礎。</p>
<pre><code class="language-text">RPC 請求/回應流程：

Client (Python)                    Ethereum Node
     │                                 │
     │  POST /                         │
     │  {                              │
     │    "jsonrpc": "2.0",            │
     │    "method": "eth_getBalance",  │
     │    "params": ["0x...", "latest"]│
     │    "id": 1                      │
     │  }                              │
     │ ──────────────────────────────&gt; │
     │                                 │  查詢鏈上狀態
     │                                 │
     │  {                              │
     │    "jsonrpc": "2.0",            │
     │    "result": "0xDE0B6B3A...",   │
     │    "id": 1                      │
     │  }                              │
     │ &lt;────────────────────────────── │
</code></pre>
<p><strong>三種核心 RPC 方法的差異</strong>：</p>
<ol>
<li>
<p><strong><code>eth_call</code></strong>：模擬執行一個交易但不實際提交到鏈上。用於讀取合約狀態（view/pure 函數）或模擬寫入操作的結果。不消耗 gas，不需要簽名。</p>
</li>
<li>
<p><strong><code>eth_estimateGas</code></strong>：估算一筆交易需要多少 gas。節點會模擬執行交易並返回所需的 gas 量。注意：估算值可能不準確，因為鏈上狀態在估算和實際執行之間可能發生變化。</p>
</li>
<li>
<p><strong><code>eth_sendRawTransaction</code></strong>：將一筆已簽名的交易提交到節點，由節點廣播到網路。這是唯一會實際修改鏈上狀態的 RPC 方法。</p>
</li>
</ol>
<pre><code class="language-python">import requests
import json

# 原始 RPC 呼叫範例（通常不需要手動做，SDK 會封裝）
def raw_rpc_call(rpc_url, method, params):
    payload = {
        "jsonrpc": "2.0",
        "method": method,
        "params": params,
        "id": 1
    }
    response = requests.post(rpc_url, json=payload)
    result = response.json()

    if "error" in result:
        raise Exception(f"RPC Error: {result['error']}")
    return result["result"]

# 查詢餘額
balance_hex = raw_rpc_call(
    "https://mainnet.infura.io/v3/YOUR_KEY",
    "eth_getBalance",
    ["0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045", "latest"]
)
balance_wei = int(balance_hex, 16)
print(f"Balance: {balance_wei / 1e18} ETH")
</code></pre>
<h3 id="852-python-sdk簡介-p1"><a class="header" href="#852-python-sdk簡介-p1">8.5.2 Python-SDK簡介 <code>P1</code></a></h3>
<p>常用 <code>web3.py</code>：</p>
<ul>
<li>連節點</li>
<li>載 ABI</li>
<li>發交易</li>
<li>查回執</li>
</ul>
<p>web3.py 是 Python 生態中最成熟的 Ethereum 互動庫。它封裝了 JSON-RPC 呼叫，提供了高階 API 來與節點互動、部署合約、呼叫合約函數。</p>
<pre><code class="language-python">from web3 import Web3
from web3.middleware import ExtraDataToPOAMiddleware

# 連接節點（支援 HTTP、WebSocket、IPC）
w3 = Web3(Web3.HTTPProvider("https://mainnet.infura.io/v3/YOUR_KEY"))

# 如果連接 PoA 鏈（如 BSC），需要注入 middleware
# w3.middleware_onion.inject(ExtraDataToPOAMiddleware, layer=0)

# 檢查連線狀態
print(f"Connected: {w3.is_connected()}")
print(f"Chain ID: {w3.eth.chain_id}")
print(f"Latest Block: {w3.eth.block_number}")

# 查詢 ETH 餘額
address = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"
balance = w3.eth.get_balance(address)
print(f"Balance: {w3.from_wei(balance, 'ether')} ETH")

# 載入合約（需要 ABI 和地址）
import json
with open("MyContract.json") as f:
    abi = json.load(f)["abi"]

contract = w3.eth.contract(
    address="0x1234567890abcdef...",
    abi=abi
)

# 讀取合約狀態（view 函數，不需簽名）
total_supply = contract.functions.totalSupply().call()
print(f"Total Supply: {total_supply}")
</code></pre>
<h3 id="853-python呼叫智能合約步驟-p0"><a class="header" href="#853-python呼叫智能合約步驟-p0">8.5.3 Python呼叫智能合約步驟 <code>P0</code></a></h3>
<ol>
<li>建立 provider</li>
<li>載入 ABI + address</li>
<li>建 call/tx</li>
<li>簽名與發送</li>
</ol>
<p>完整的合約呼叫流程可以分為「讀取」和「寫入」兩種場景，寫入需要額外的簽名和 gas 處理。</p>
<pre><code class="language-python">from web3 import Web3
import json

# === 設定 ===
RPC_URL = "https://sepolia.infura.io/v3/YOUR_KEY"
PRIVATE_KEY = "0x..."  # 永遠不要硬編碼在程式中！
CONTRACT_ADDRESS = "0x..."

w3 = Web3(Web3.HTTPProvider(RPC_URL))
account = w3.eth.account.from_key(PRIVATE_KEY)

# 載入 ABI
with open("ERC20.json") as f:
    abi = json.load(f)

contract = w3.eth.contract(address=CONTRACT_ADDRESS, abi=abi)

# === 讀取操作（不需 gas）===
def read_balance(address: str) -&gt; int:
    """查詢 token 餘額"""
    return contract.functions.balanceOf(address).call()

# === 寫入操作（需要 gas 和簽名）===
def transfer_token(to: str, amount: int) -&gt; str:
    """轉帳 token"""
    # 1. 構建交易
    tx = contract.functions.transfer(to, amount).build_transaction({
        "from": account.address,
        "nonce": w3.eth.get_transaction_count(account.address),
        "gas": 100000,  # 預估 gas
        "maxFeePerGas": w3.to_wei("30", "gwei"),
        "maxPriorityFeePerGas": w3.to_wei("2", "gwei"),
        "chainId": w3.eth.chain_id,
    })

    # 2. 簽名
    signed_tx = account.sign_transaction(tx)

    # 3. 發送
    tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)

    # 4. 等待確認
    receipt = w3.eth.wait_for_transaction_receipt(tx_hash, timeout=120)

    # 5. 檢查狀態
    if receipt["status"] != 1:
        raise Exception(f"Transaction failed: {tx_hash.hex()}")

    return tx_hash.hex()

# === 使用範例 ===
balance = read_balance("0xABCDEF...")
print(f"Balance: {balance}")

tx_hash = transfer_token("0xABCDEF...", 1000 * 10**18)
print(f"Transfer TX: {tx_hash}")
</code></pre>
<h3 id="854-節點連接-p0"><a class="header" href="#854-節點連接-p0">8.5.4 節點連接 <code>P0</code></a></h3>
<p>建議：</p>
<ul>
<li>主備 RPC</li>
<li>請求重試與超時</li>
<li>連線健康檢查</li>
</ul>
<p>在生產環境中，RPC 節點的可靠性直接影響到整個系統的穩定性。單一節點可能因為維護、過載、或網路問題而暫時不可用，因此必須實作容錯機制。</p>
<pre><code class="language-python">from web3 import Web3
import time
from typing import List, Optional

class ResilientProvider:
    """帶有故障轉移和重試的 RPC Provider"""

    def __init__(self, rpc_urls: List[str], timeout: int = 10, max_retries: int = 3):
        self.providers = [Web3.HTTPProvider(url, request_kwargs={"timeout": timeout})
                          for url in rpc_urls]
        self.current_index = 0
        self.max_retries = max_retries

    def get_web3(self) -&gt; Web3:
        """獲取可用的 Web3 實例"""
        for attempt in range(self.max_retries):
            for i in range(len(self.providers)):
                idx = (self.current_index + i) % len(self.providers)
                w3 = Web3(self.providers[idx])
                try:
                    if w3.is_connected():
                        self.current_index = idx
                        return w3
                except Exception:
                    continue
            time.sleep(1)  # 等待後重試
        raise ConnectionError("All RPC endpoints unavailable")

    def health_check(self) -&gt; dict:
        """檢查所有節點的健康狀態"""
        results = {}
        for i, provider in enumerate(self.providers):
            w3 = Web3(provider)
            try:
                block = w3.eth.block_number
                results[f"node_{i}"] = {"status": "ok", "block": block}
            except Exception as e:
                results[f"node_{i}"] = {"status": "error", "error": str(e)}
        return results

# 使用範例
provider = ResilientProvider([
    "https://mainnet.infura.io/v3/KEY1",     # 主節點
    "https://eth-mainnet.alchemyapi.io/KEY2", # 備用節點
    "https://rpc.ankr.com/eth",               # 公共節點（備援）
])

w3 = provider.get_web3()
</code></pre>
<h3 id="855-abi分析與編譯-p0"><a class="header" href="#855-abi分析與編譯-p0">8.5.5 ABI分析與編譯 <code>P0</code></a></h3>
<p>ABI 是調用契約，版本漂移會導致調用錯誤。</p>
<p>ABI（Application Binary Interface）定義了合約的外部介面——包括函數名稱、參數型別、返回值型別、事件定義等。SDK 透過 ABI 來編碼 calldata（將人類可讀的函數呼叫轉換為 EVM 可理解的 bytes）和解碼返回值。</p>
<pre><code class="language-python"># ABI 的結構範例
abi = [
    {
        "type": "function",
        "name": "transfer",
        "inputs": [
            {"name": "to", "type": "address"},
            {"name": "amount", "type": "uint256"}
        ],
        "outputs": [
            {"name": "", "type": "bool"}
        ],
        "stateMutability": "nonpayable"
    },
    {
        "type": "event",
        "name": "Transfer",
        "inputs": [
            {"name": "from", "type": "address", "indexed": True},
            {"name": "to", "type": "address", "indexed": True},
            {"name": "value", "type": "uint256", "indexed": False}
        ]
    }
]
</code></pre>
<p><strong>ABI 版本漂移</strong> 是一個容易被忽略的風險。如果合約升級了（透過 Proxy），新版本可能新增或修改了函數簽名。如果 SDK 端還在使用舊版的 ABI，呼叫新增的函數會失敗，或者解碼返回值會出錯。</p>
<p><strong>最佳實踐</strong>：</p>
<ol>
<li>將 ABI 與合約版本號一起管理</li>
<li>從 Etherscan 或合約倉庫自動獲取最新 ABI</li>
<li>在 SDK 端加入 ABI 版本檢查機制</li>
</ol>
<pre><code class="language-python"># 從已驗證的合約自動獲取 ABI
import requests

def get_abi_from_etherscan(contract_address: str, api_key: str) -&gt; list:
    """從 Etherscan 獲取已驗證合約的 ABI"""
    url = f"https://api.etherscan.io/api"
    params = {
        "module": "contract",
        "action": "getabi",
        "address": contract_address,
        "apikey": api_key
    }
    resp = requests.get(url, params=params)
    data = resp.json()
    if data["status"] != "1":
        raise Exception(f"Failed to get ABI: {data['message']}")
    return json.loads(data["result"])
</code></pre>
<h3 id="856-透過python調用智能合約-p0"><a class="header" href="#856-透過python調用智能合約-p0">8.5.6 透過Python調用智能合約 <code>P0</code></a></h3>
<p>工程要點：</p>
<ul>
<li>nonce 競態控制</li>
<li>gas 估算與上限保護</li>
<li>交易狀態追蹤（pending -&gt; confirmed）</li>
</ul>
<p>在生產環境中，透過 Python 呼叫智能合約需要處理很多邊界情況。以下是一個完整的生產級交易發送模組：</p>
<pre><code class="language-python">from web3 import Web3
from web3.exceptions import TransactionNotFound
import threading
import time

class TransactionManager:
    """生產級交易管理器"""

    def __init__(self, w3: Web3, private_key: str):
        self.w3 = w3
        self.account = w3.eth.account.from_key(private_key)
        self._nonce_lock = threading.Lock()
        self._local_nonce = None

    def _get_nonce(self) -&gt; int:
        """線程安全的 nonce 管理"""
        with self._nonce_lock:
            chain_nonce = self.w3.eth.get_transaction_count(
                self.account.address, "pending"
            )
            if self._local_nonce is None or chain_nonce &gt; self._local_nonce:
                self._local_nonce = chain_nonce
            else:
                self._local_nonce += 1
            return self._local_nonce

    def _estimate_gas_with_buffer(self, tx: dict) -&gt; int:
        """估算 gas 並加上 20% 安全緩衝"""
        estimated = self.w3.eth.estimate_gas(tx)
        return int(estimated * 1.2)

    def send_transaction(self, tx: dict, timeout: int = 300) -&gt; dict:
        """發送交易並等待確認"""
        # 填充缺少的欄位
        tx["from"] = self.account.address
        tx["nonce"] = self._get_nonce()
        tx["chainId"] = self.w3.eth.chain_id

        if "gas" not in tx:
            tx["gas"] = self._estimate_gas_with_buffer(tx)

        if "maxFeePerGas" not in tx:
            base_fee = self.w3.eth.get_block("latest")["baseFeePerGas"]
            tx["maxFeePerGas"] = base_fee * 2
            tx["maxPriorityFeePerGas"] = self.w3.to_wei("2", "gwei")

        # 簽名並發送
        signed = self.account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed.raw_transaction)

        # 等待確認
        receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=timeout)

        if receipt["status"] != 1:
            raise Exception(
                f"Transaction reverted: {tx_hash.hex()}, "
                f"gas used: {receipt['gasUsed']}"
            )

        return {
            "tx_hash": tx_hash.hex(),
            "block_number": receipt["blockNumber"],
            "gas_used": receipt["gasUsed"],
            "status": "confirmed"
        }

    def call_contract_function(self, contract, func_name: str, *args, **kwargs):
        """呼叫合約函數（寫入操作）"""
        func = getattr(contract.functions, func_name)
        tx = func(*args).build_transaction({
            "from": self.account.address,
            "value": kwargs.get("value", 0),
        })
        return self.send_transaction(tx)

# 使用範例
tx_mgr = TransactionManager(w3, PRIVATE_KEY)

# 呼叫合約函數
result = tx_mgr.call_contract_function(
    contract, "transfer",
    "0xRecipient...", 1000 * 10**18
)
print(f"TX confirmed in block {result['block_number']}")
</code></pre>
<p><strong>Nonce 管理</strong> 是多線程/多進程環境中最容易出問題的地方。如果兩個交易使用了相同的 nonce，只有一個會被接受。上面的 <code>TransactionManager</code> 使用了線程鎖來確保 nonce 的遞增是原子的。在更高並發的場景中，可能需要使用 Redis 等外部存儲來管理全局 nonce。</p>
<h2 id="86-章節回顧與工程實戰心法"><a class="header" href="#86-章節回顧與工程實戰心法">8.6 章節回顧與工程實戰心法</a></h2>
<p>本章涵蓋了從 ERC 標準到可升級架構、從安全模式到 Python SDK 整合的進階主題。以下是需要內化的核心要點：</p>
<p><strong>標準優先</strong>。ERC 標準不是建議，而是互操作性的基石。使用 OpenZeppelin 的實作作為基底，只覆寫真正需要自訂的部分。自行從頭實作標準不僅浪費時間，還會引入相容性和安全問題。</p>
<p><strong>升級是一把雙刃劍</strong>。可升級合約解決了「不可變但有 bug」的困境，但同時引入了新的攻擊面。升級權限必須有嚴格的治理機制（多簽 + 時間鎖 + 社群審查）。Storage layout 的兼容性問題是最常見的升級事故原因，務必使用 OpenZeppelin 的升級安全插件來檢查。</p>
<p><strong>安全是層層疊加的</strong>。重入攻擊不是只靠 ReentrancyGuard 就能防住的——CEI 模式、Pull Payment、外部呼叫最小化，這些都需要同時運用。安全不是一個 checkbox，而是一種貫穿整個開發流程的思維方式。</p>
<p><strong>SDK 端也是攻擊面</strong>。很多安全分析只關注合約端，但 Python SDK 端同樣存在風險：私鑰管理、nonce 競態、RPC 節點劫持、交易回執驗證等。一個完整的安全策略必須涵蓋從 SDK 到合約到鏈上的整個鏈路。</p>
<p><strong>監控和審計不是可選的</strong>。合約部署只是開始，持續的鏈上監控（異常交易偵測、大額轉帳告警、治理操作追蹤）和定期的安全審計同樣重要。</p>
<h2 id="白話總結-20"><a class="header" href="#白話總結-20">白話總結</a></h2>
<p>這一章就是把你從「會寫合約」帶到「能上線合約」的距離。首先，ERC 標準就像是區塊鏈世界的 USB 接口，你的 token 只有遵守 ERC-20 標準，錢包和交易所才認得它，所以不要自己亂搞。然後是可升級合約，原理就是把邏輯和資料分開放——Proxy 存資料，Implementation 跑邏輯，升級就是換 Implementation。但是千萬注意 storage layout 不能亂動，新變數只能加在最後面，不然整個狀態就亂掉了。安全方面最重要的就是防重入：先改狀態再呼叫外部合約（CEI 模式），加上 ReentrancyGuard 雙重保險。至於用 Python 呼叫合約，web3.py 幫你搞定了大部分的事情，但你需要特別注意 nonce 管理（多線程下會打架）和 gas 估算（記得加 buffer）。總結來說，能寫出能跑的合約只是第一步，真正的挑戰是安全性、可升級性和可維護性，這些才是決定你的合約能不能真正上線的關鍵。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第9章-python語言離線錢包開發"><a class="header" href="#第9章-python語言離線錢包開發">第9章 Python語言離線錢包開發</a></h1>
<p>本章目標是做出安全可用的離線錢包方案：私鑰隔離、交易可驗證、查詢可追蹤。</p>
<h2 id="91-區塊鏈錢包原理-p0"><a class="header" href="#91-區塊鏈錢包原理-p0">9.1 區塊鏈錢包原理 <code>P0</code></a></h2>
<h3 id="911-區塊鏈錢包的核心原理-p0"><a class="header" href="#911-區塊鏈錢包的核心原理-p0">9.1.1 區塊鏈錢包的核心原理 <code>P0</code></a></h3>
<p>錢包本質：</p>
<ul>
<li>管理私鑰與地址</li>
<li>對交易做簽名</li>
<li>提供查詢與廣播流程</li>
</ul>
<p>不是功能：</p>
<ul>
<li>鏈上資產保管（資產在鏈上）</li>
</ul>
<pre><code class="language-text">Intent -&gt; Build Tx -&gt; Offline Sign -&gt; Online Broadcast -&gt; Track Status
</code></pre>
<p>區塊鏈錢包是一個經常被誤解的概念。很多人以為錢包「儲存」了加密貨幣，就像銀行帳戶儲存了法幣一樣。但事實上，錢包只是一個<strong>私鑰管理工具</strong>。你的資產永遠存在區塊鏈上（由全球數千個節點共同維護），錢包只是持有能夠控制這些資產的私鑰。如果類比現實世界，錢包更像是一把鑰匙而非保險箱——鑰匙丟了，保險箱裡的東西你就再也拿不到了。</p>
<p>從工程角度來看，一個完整的錢包系統需要處理以下核心功能：</p>
<pre><code class="language-text">錢包系統架構：

┌─────────────────────────────────────────────────────┐
│                    Wallet System                     │
│                                                      │
│  ┌─────────────┐   ┌──────────────┐   ┌───────────┐ │
│  │ Key Manager │   │ TX Builder   │   │  Query    │ │
│  │             │   │              │   │  Service  │ │
│  │ - 生成私鑰  │   │ - 構建交易   │   │ - 餘額    │ │
│  │ - 助記詞    │   │ - 估算 gas   │   │ - 歷史    │ │
│  │ - 派生地址  │   │ - 編碼 data  │   │ - 狀態    │ │
│  │ - 加密存儲  │   │ - 設定 nonce │   │ - 事件    │ │
│  └──────┬──────┘   └──────┬───────┘   └─────┬─────┘ │
│         │                 │                  │       │
│         v                 v                  │       │
│  ┌──────────────────────────────┐            │       │
│  │      Signer (離線)           │            │       │
│  │  - ECDSA 簽名               │            │       │
│  │  - 交易序列化 (RLP)         │            │       │
│  └──────────────┬───────────────┘            │       │
│                 │                            │       │
│                 v                            v       │
│  ┌──────────────────────────────────────────────┐   │
│  │         Broadcaster (線上)                    │   │
│  │  - 發送 raw transaction                       │   │
│  │  - 等待確認                                   │   │
│  │  - 追蹤狀態                                   │   │
│  └──────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────┘
</code></pre>
<p><strong>離線錢包的核心設計原則</strong>是「氣隙隔離」（air-gapped）。私鑰只存在於離線環境中，永遠不接觸網路。交易的構建可以在線上完成，但簽名必須在離線環境中進行。簽名後的交易（raw transaction）透過安全通道（如 QR code、USB）傳回線上環境進行廣播。這種設計確保了即使線上環境被入侵，攻擊者也無法取得私鑰。</p>
<pre><code class="language-text">離線錢包工作流：

  Online Machine                    Offline Machine
  (有網路連接)                      (無網路連接)
  ┌──────────────┐                  ┌──────────────┐
  │ 1. 構建未簽名│                  │              │
  │    交易      │                  │              │
  │              │  USB / QR code   │              │
  │ 2. 傳輸 ────│─────────────────&gt;│ 3. 載入交易  │
  │    未簽名 TX │                  │              │
  │              │                  │ 4. 檢視交易  │
  │              │                  │    內容      │
  │              │                  │              │
  │              │                  │ 5. 私鑰簽名  │
  │              │                  │              │
  │              │  USB / QR code   │              │
  │ 6. 接收 &lt;───│&lt;─────────────────│ 7. 傳回已簽  │
  │    已簽名 TX │                  │    名交易    │
  │              │                  │              │
  │ 8. 廣播交易  │                  │              │
  │              │                  │              │
  │ 9. 追蹤狀態  │                  │              │
  └──────────────┘                  └──────────────┘
</code></pre>
<h3 id="912-助記詞如何產生與驗證-p0"><a class="header" href="#912-助記詞如何產生與驗證-p0">9.1.2 助記詞如何產生與驗證 <code>P0</code></a></h3>
<p>建議採用：</p>
<ul>
<li>BIP-39 助記詞</li>
<li>BIP-32/44 派生路徑</li>
</ul>
<p>安全要點：</p>
<ul>
<li>助記詞離線保存</li>
<li>passphrase 與助記詞分開保管</li>
<li>驗證 checksum</li>
</ul>
<p>助記詞（mnemonic phrase）是私鑰的人類可讀表示形式。一組 12 或 24 個英文單詞就代表了一組完整的密碼學密鑰。助記詞的產生和使用遵循 BIP-39 標準，這個標準確保了不同錢包之間的相容性——同一組助記詞在 MetaMask、Ledger、Trust Wallet 中都會生成相同的地址。</p>
<p><strong>BIP-39 助記詞生成流程</strong>：</p>
<pre><code class="language-text">BIP-39 助記詞生成過程：

1. 生成隨機熵 (entropy)
   128 bits (12 words) 或 256 bits (24 words)
   ┌────────────────────────────────────────────┐
   │ 10011010 11100111 01001100 ... (128 bits)   │
   └────────────────────────────────────────────┘

2. 計算校驗碼 (checksum)
   SHA256(entropy) 取前 N bits (N = entropy_bits / 32)
   128 bits entropy -&gt; 4 bits checksum -&gt; 132 bits total
   ┌────────────────────────────────────┬────┐
   │         entropy (128 bits)         │ CS │
   └────────────────────────────────────┴────┘

3. 分割為 11-bit 段
   132 bits / 11 = 12 segments
   每個 segment 對應 BIP-39 單詞表中的一個單詞 (2048 個)
   ┌─────┬─────┬─────┬─────┬─ ... ─┬─────┐
   │ 10011│01011│10011│10100│       │01100│
   │=1235 │=731 │=1235│=1316│       │=588 │
   │=option│=galaxy│=option│=rack│  │=enough│
   └─────┴─────┴─────┴─────┴─ ... ─┴─────┘

4. 最終結果
   "option galaxy option rack ... enough"
</code></pre>
<pre><code class="language-python">from mnemonic import Mnemonic
from eth_account import Account
from eth_keys import keys
import hashlib
import hmac

# BIP-39 助記詞生成
def generate_mnemonic(strength: int = 128) -&gt; str:
    """
    生成 BIP-39 助記詞
    strength: 128 = 12 words, 256 = 24 words
    """
    m = Mnemonic("english")
    mnemonic = m.generate(strength=strength)
    return mnemonic

# 驗證助記詞的校驗碼
def validate_mnemonic(mnemonic: str) -&gt; bool:
    """驗證助記詞是否合法（包括 checksum）"""
    m = Mnemonic("english")
    return m.check(mnemonic)

# 從助記詞派生私鑰（BIP-44 路徑）
def derive_account(mnemonic: str, passphrase: str = "",
                   account_index: int = 0) -&gt; dict:
    """
    從助記詞派生 Ethereum 帳戶
    BIP-44 路徑: m/44'/60'/0'/0/{index}
    """
    Account.enable_unaudited_hdwallet_features()

    # 從助記詞 + passphrase 生成 seed
    acct = Account.from_mnemonic(
        mnemonic,
        passphrase=passphrase,
        account_path=f"m/44'/60'/0'/0/{account_index}"
    )

    return {
        "address": acct.address,
        "private_key": acct.key.hex(),
        "path": f"m/44'/60'/0'/0/{account_index}"
    }

# 使用範例
mnemonic = generate_mnemonic(128)
print(f"Mnemonic: {mnemonic}")
print(f"Valid: {validate_mnemonic(mnemonic)}")

# 派生前 5 個帳戶
for i in range(5):
    acct = derive_account(mnemonic, account_index=i)
    print(f"  [{i}] {acct['address']}  path={acct['path']}")
</code></pre>
<p><strong>BIP-32/44 派生路徑</strong> 允許從一組助記詞派生出無限多個地址。BIP-44 定義了標準的路徑格式：<code>m/purpose'/coin_type'/account'/change/address_index</code>。對於 Ethereum，標準路徑是 <code>m/44'/60'/0'/0/0</code>。理解派生路徑的含義很重要，因為不同的路徑會生成完全不同的地址。</p>
<pre><code class="language-text">BIP-44 派生路徑結構：

m / 44' / 60' / 0' / 0 / 0
│    │     │     │    │   │
│    │     │     │    │   └── address_index: 第幾個地址
│    │     │     │    └────── change: 0=外部, 1=找零（UTXO 鏈用）
│    │     │     └─────────── account: 帳戶編號
│    │     └───────────────── coin_type: 60=ETH, 0=BTC, 966=MATIC
│    └─────────────────────── purpose: 44=BIP-44 標準
└──────────────────────────── master: 主密鑰
</code></pre>
<p><strong>安全最佳實踐</strong>：</p>
<ol>
<li><strong>助記詞必須離線生成</strong>：在斷網的電腦上生成，生成後立即抄寫到紙上或金屬板上</li>
<li><strong>Passphrase 是第二層保護</strong>：即使助記詞洩露，沒有 passphrase 也無法派生出正確的私鑰</li>
<li><strong>分散備份</strong>：將助記詞分為多份（如使用 Shamir's Secret Sharing），分別存放在不同的物理位置</li>
<li><strong>永遠不要數位化助記詞</strong>：不要拍照、不要存檔、不要透過網路傳輸</li>
</ol>
<h3 id="913-如何儲存私鑰-p0"><a class="header" href="#913-如何儲存私鑰-p0">9.1.3 如何儲存私鑰 <code>P0</code></a></h3>
<p>推薦做法：</p>
<ul>
<li>keystore 加密（口令 + KDF）</li>
<li>硬體錢包或 HSM</li>
<li>交易簽名與網路隔離</li>
</ul>
<p>禁忌：</p>
<ul>
<li>私鑰明文存檔</li>
<li>私鑰進日誌</li>
<li>未授權備份</li>
</ul>
<p>私鑰的安全儲存是錢包系統最關鍵的環節。私鑰一旦洩露，對應地址中的所有資產都可以被任何人轉走，而且這個過程是不可逆的——沒有客服、沒有凍結、沒有追回機制。</p>
<p><strong>Keystore 加密</strong> 是 Ethereum 官方推薦的私鑰儲存方式。它使用 AES-128-CTR 加密私鑰，並使用 KDF（Key Derivation Function，如 scrypt 或 pbkdf2）從使用者的密碼派生加密金鑰。即使 keystore 檔案被盜，攻擊者仍然需要暴力破解密碼才能取得私鑰。</p>
<pre><code class="language-python">from eth_account import Account
import json
import os
import getpass

class KeystoreManager:
    """Keystore 私鑰管理器"""

    def __init__(self, keystore_dir: str = "./keystores"):
        self.keystore_dir = keystore_dir
        os.makedirs(keystore_dir, exist_ok=True)

    def create_account(self, password: str) -&gt; dict:
        """創建新帳戶並加密保存"""
        # 生成新的私鑰
        acct = Account.create()

        # 加密為 keystore 格式
        # scrypt 參數越大，暴力破解越難，但開鎖也越慢
        keystore = Account.encrypt(
            acct.key,
            password,
            kdf="scrypt",
            iterations=None  # 使用預設值
        )

        # 保存到檔案
        filename = f"UTC--{keystore['address']}.json"
        filepath = os.path.join(self.keystore_dir, filename)
        with open(filepath, "w") as f:
            json.dump(keystore, f, indent=2)

        return {
            "address": acct.address,
            "keystore_path": filepath
        }

    def load_private_key(self, keystore_path: str, password: str) -&gt; bytes:
        """從 keystore 解密私鑰"""
        with open(keystore_path) as f:
            keystore = json.load(f)
        return Account.decrypt(keystore, password)

    def sign_transaction(self, keystore_path: str, password: str,
                        tx: dict) -&gt; bytes:
        """使用 keystore 簽名交易"""
        private_key = self.load_private_key(keystore_path, password)
        signed = Account.sign_transaction(tx, private_key)

        # 立即清除記憶體中的私鑰（Python 的限制：無法保證完全清除）
        del private_key

        return signed.raw_transaction

# 使用範例
km = KeystoreManager()

# 創建帳戶（密碼不要硬編碼！）
password = getpass.getpass("Enter password: ")
result = km.create_account(password)
print(f"New account: {result['address']}")
print(f"Keystore: {result['keystore_path']}")
</code></pre>
<pre><code class="language-text">Keystore 檔案結構：

{
  "address": "0x742d35Cc6634C0532925a3b844Bc9e7595f2bD2e",
  "crypto": {
    "cipher": "aes-128-ctr",           // 加密演算法
    "ciphertext": "...",                // 加密後的私鑰
    "cipherparams": {
      "iv": "..."                       // 初始化向量
    },
    "kdf": "scrypt",                    // 密鑰派生函數
    "kdfparams": {
      "dklen": 32,                      // 派生金鑰長度
      "n": 262144,                      // CPU/記憶體成本參數
      "p": 1,                           // 平行化參數
      "r": 8,                           // 區塊大小參數
      "salt": "..."                     // 鹽值
    },
    "mac": "..."                        // 訊息認證碼（驗證密碼正確性）
  },
  "version": 3
}

解密流程：
password + salt ──[scrypt]──&gt; derived_key
derived_key[16:32] + ciphertext ──[keccak256]──&gt; mac (比對驗證)
derived_key[0:16] + iv + ciphertext ──[AES-CTR]──&gt; private_key
</code></pre>
<p><strong>硬體錢包</strong> 是目前最安全的私鑰管理方案。Ledger、Trezor 等硬體錢包將私鑰保存在安全晶片（Secure Element）中，私鑰永遠不會離開裝置。交易在硬體裝置內部完成簽名，電腦只能看到已簽名的交易，看不到私鑰。對於管理大額資產的機構，HSM（Hardware Security Module）是更專業的選擇。</p>
<p><strong>絕對禁忌</strong>：</p>
<ul>
<li>私鑰明文寫在程式碼或配置檔中</li>
<li>私鑰出現在日誌（log）中——很多新手會在 debug 時 print 私鑰</li>
<li>私鑰透過 HTTP（非 HTTPS）傳輸</li>
<li>私鑰存在雲端筆記、即時通訊軟體、或 email 中</li>
<li>未清理的記憶體中殘留私鑰（C/Rust 可以做到，Python 較困難）</li>
</ul>
<h2 id="92-區塊鏈錢包核心功能實現-p0"><a class="header" href="#92-區塊鏈錢包核心功能實現-p0">9.2 區塊鏈錢包核心功能實現 <code>P0</code></a></h2>
<h3 id="921-錢包如何支援coin轉移-p0"><a class="header" href="#921-錢包如何支援coin轉移-p0">9.2.1 錢包如何支援Coin轉移 <code>P0</code></a></h3>
<p>UTXO 鏈：</p>
<ul>
<li>選 UTXO</li>
<li>建 inputs/outputs</li>
<li>離線簽名</li>
<li>上線廣播</li>
</ul>
<p>Account 鏈：</p>
<ul>
<li>查 nonce/gas</li>
<li>建交易</li>
<li>離線簽名</li>
<li>上線廣播</li>
</ul>
<p>區塊鏈有兩種主流的帳戶模型：UTXO（Unspent Transaction Output，比特幣使用）和 Account（帳戶模型，Ethereum 使用）。錢包在支援 Coin 轉移時，需要根據不同的模型採用不同的實作方式。</p>
<p><strong>UTXO 模型</strong> 的核心概念是：你的「餘額」實際上是散布在區塊鏈上的一堆「未花費的交易輸出」。要花費資金時，你需要選擇一個或多個 UTXO 作為輸入，然後創建新的輸出（包括給接收方的金額和找零給自己的金額）。</p>
<p><strong>Account 模型</strong> 更直覺——每個地址有一個明確的餘額，轉帳就是從一個帳戶扣款、另一個帳戶加款。Ethereum 使用的就是 Account 模型。</p>
<pre><code class="language-python">from web3 import Web3
from eth_account import Account

class EthTransfer:
    """Ethereum Coin 轉移實作"""

    def __init__(self, rpc_url: str):
        self.w3 = Web3(Web3.HTTPProvider(rpc_url))

    def build_transfer_tx(self, from_addr: str, to_addr: str,
                          amount_eth: float) -&gt; dict:
        """
        構建 ETH 轉帳交易（線上步驟）
        """
        # 1. 查詢 nonce（防止交易重放）
        nonce = self.w3.eth.get_transaction_count(from_addr, "pending")

        # 2. 估算 gas 費用
        base_fee = self.w3.eth.get_block("latest")["baseFeePerGas"]
        max_fee = int(base_fee * 2)
        priority_fee = self.w3.to_wei("2", "gwei")

        # 3. 構建交易（EIP-1559 格式）
        tx = {
            "type": 2,  # EIP-1559
            "chainId": self.w3.eth.chain_id,
            "nonce": nonce,
            "to": Web3.to_checksum_address(to_addr),
            "value": self.w3.to_wei(amount_eth, "ether"),
            "gas": 21000,  # ETH 轉帳固定 21000 gas
            "maxFeePerGas": max_fee,
            "maxPriorityFeePerGas": priority_fee,
        }

        return tx

    def sign_offline(self, tx: dict, private_key: str) -&gt; str:
        """
        離線簽名（在斷網機器上執行）
        """
        signed = Account.sign_transaction(tx, private_key)
        return signed.raw_transaction.hex()

    def broadcast(self, raw_tx_hex: str) -&gt; str:
        """
        廣播已簽名的交易（線上步驟）
        """
        raw_tx = bytes.fromhex(raw_tx_hex.replace("0x", ""))
        tx_hash = self.w3.eth.send_raw_transaction(raw_tx)
        return tx_hash.hex()

    def wait_confirmation(self, tx_hash: str, timeout: int = 300) -&gt; dict:
        """
        等待交易確認並返回收據
        """
        receipt = self.w3.eth.wait_for_transaction_receipt(
            tx_hash, timeout=timeout
        )

        return {
            "tx_hash": tx_hash,
            "status": "success" if receipt["status"] == 1 else "failed",
            "block_number": receipt["blockNumber"],
            "gas_used": receipt["gasUsed"],
            "effective_gas_price": receipt["effectiveGasPrice"],
        }

# 使用範例
eth = EthTransfer("https://mainnet.infura.io/v3/YOUR_KEY")

# Step 1: 線上構建交易
tx = eth.build_transfer_tx(
    from_addr="0xYourAddress",
    to_addr="0xRecipient",
    amount_eth=0.1
)
print(f"Unsigned TX: {tx}")

# Step 2: 離線簽名（在斷網機器上執行）
raw_tx = eth.sign_offline(tx, "0xYourPrivateKey")
print(f"Signed TX: {raw_tx}")

# Step 3: 線上廣播
tx_hash = eth.broadcast(raw_tx)
print(f"TX Hash: {tx_hash}")

# Step 4: 等待確認
result = eth.wait_confirmation(tx_hash)
print(f"Result: {result}")
</code></pre>
<p><strong>EIP-1559 交易格式</strong> 是目前 Ethereum 推薦的交易格式。與傳統的 gasPrice 模式不同，EIP-1559 引入了 <code>maxFeePerGas</code>（你願意支付的最高 gas 價格）和 <code>maxPriorityFeePerGas</code>（給驗證者的小費）。實際支付的費用 = min(maxFeePerGas, baseFee + maxPriorityFeePerGas)。這種機制讓 gas 費用更可預測，減少了超額支付。</p>
<h3 id="922-錢包如何支援coin查詢-p0"><a class="header" href="#922-錢包如何支援coin查詢-p0">9.2.2 錢包如何支援Coin查詢 <code>P0</code></a></h3>
<p>查詢來源：</p>
<ul>
<li>節點 RPC</li>
<li>索引服務</li>
</ul>
<p>查詢類型：</p>
<ul>
<li>可用餘額</li>
<li>已確認餘額</li>
<li>交易歷史</li>
</ul>
<p>餘額查詢看似簡單，但在生產環境中需要考慮很多細節。首先是「餘額」的定義——「可用餘額」和「已確認餘額」可能不同。一筆剛發出但尚未被確認的交易會減少你的可用餘額，但已確認餘額不會改變直到交易被打包進區塊。</p>
<pre><code class="language-python">from web3 import Web3
from typing import List, Optional
from dataclasses import dataclass
from datetime import datetime

@dataclass
class BalanceInfo:
    address: str
    balance_wei: int
    balance_eth: float
    pending_balance_wei: int
    pending_balance_eth: float
    block_number: int
    timestamp: datetime

@dataclass
class TransactionRecord:
    tx_hash: str
    block_number: int
    timestamp: int
    from_addr: str
    to_addr: str
    value_wei: int
    gas_used: int
    status: str
    direction: str  # "in" or "out"

class CoinQuery:
    """Coin 查詢服務"""

    def __init__(self, rpc_url: str):
        self.w3 = Web3(Web3.HTTPProvider(rpc_url))

    def get_balance(self, address: str) -&gt; BalanceInfo:
        """查詢地址的 ETH 餘額（含 pending）"""
        address = Web3.to_checksum_address(address)

        # 最新確認餘額
        confirmed = self.w3.eth.get_balance(address, "latest")

        # 包含 pending 交易的餘額
        pending = self.w3.eth.get_balance(address, "pending")

        block = self.w3.eth.get_block("latest")

        return BalanceInfo(
            address=address,
            balance_wei=confirmed,
            balance_eth=float(Web3.from_wei(confirmed, "ether")),
            pending_balance_wei=pending,
            pending_balance_eth=float(Web3.from_wei(pending, "ether")),
            block_number=block["number"],
            timestamp=datetime.fromtimestamp(block["timestamp"])
        )

    def get_recent_transactions(self, address: str,
                                 start_block: int,
                                 end_block: Optional[int] = None,
                                 ) -&gt; List[TransactionRecord]:
        """
        查詢地址的近期交易
        注意：標準 RPC 不直接支援按地址查歷史交易
        生產環境應使用 Etherscan API 或 The Graph
        """
        if end_block is None:
            end_block = self.w3.eth.block_number

        records = []
        address = Web3.to_checksum_address(address)

        for block_num in range(start_block, end_block + 1):
            block = self.w3.eth.get_block(block_num, full_transactions=True)
            for tx in block["transactions"]:
                if tx["from"] == address or tx["to"] == address:
                    receipt = self.w3.eth.get_transaction_receipt(tx["hash"])
                    records.append(TransactionRecord(
                        tx_hash=tx["hash"].hex(),
                        block_number=block_num,
                        timestamp=block["timestamp"],
                        from_addr=tx["from"],
                        to_addr=tx["to"] or "",
                        value_wei=tx["value"],
                        gas_used=receipt["gasUsed"],
                        status="success" if receipt["status"] == 1 else "failed",
                        direction="out" if tx["from"] == address else "in"
                    ))

        return records

# 使用範例
query = CoinQuery("https://mainnet.infura.io/v3/YOUR_KEY")

# 查詢餘額
balance = query.get_balance("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045")
print(f"Address: {balance.address}")
print(f"Balance: {balance.balance_eth} ETH")
print(f"Pending: {balance.pending_balance_eth} ETH")
print(f"Block: {balance.block_number}")
</code></pre>
<p><strong>生產環境建議</strong>：直接使用 RPC 的 <code>eth_getBalance</code> 來逐塊掃描交易歷史是非常低效的。生產環境應該使用專門的索引服務：</p>
<ul>
<li><strong>Etherscan API</strong>：提供完整的交易歷史查詢，免費配額足夠小型專案使用</li>
<li><strong>The Graph</strong>：去中心化的鏈下索引協議，可以自訂查詢的資料結構</li>
<li><strong>Alchemy / Infura Enhanced API</strong>：提供額外的查詢能力（如 <code>alchemy_getAssetTransfers</code>）</li>
</ul>
<h3 id="923-erc-20標準實現與部署-p0"><a class="header" href="#923-erc-20標準實現與部署-p0">9.2.3 ERC-20標準實現與部署 <code>P0</code></a></h3>
<p>核心：</p>
<ul>
<li>實作標準函數與事件</li>
<li>部署後驗證合約</li>
<li>配置 token metadata</li>
</ul>
<p>部署注意：</p>
<ul>
<li>decimals 一次定義</li>
<li>mint 權限治理（多簽/時鎖）</li>
</ul>
<p>在錢包開發的語境中，理解 ERC-20 的部署和配置流程非常重要，因為錢包需要支援任意的 ERC-20 token。</p>
<pre><code class="language-python">from web3 import Web3
import json
import solcx

class TokenDeployer:
    """ERC-20 Token 部署工具"""

    # 最小 ERC-20 合約原始碼
    ERC20_SOURCE = """
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.20;

    import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
    import "@openzeppelin/contracts/access/Ownable.sol";

    contract MyToken is ERC20, Ownable {
        uint8 private _decimals;

        constructor(
            string memory name_,
            string memory symbol_,
            uint8 decimals_,
            uint256 initialSupply
        ) ERC20(name_, symbol_) Ownable(msg.sender) {
            _decimals = decimals_;
            _mint(msg.sender, initialSupply * 10 ** decimals_);
        }

        function decimals() public view override returns (uint8) {
            return _decimals;
        }

        function mint(address to, uint256 amount) external onlyOwner {
            _mint(to, amount);
        }
    }
    """

    def __init__(self, w3: Web3, private_key: str):
        self.w3 = w3
        self.account = w3.eth.account.from_key(private_key)

    def deploy(self, name: str, symbol: str, decimals: int,
               initial_supply: int, abi: list, bytecode: str) -&gt; dict:
        """部署 ERC-20 token 合約"""
        contract = self.w3.eth.contract(abi=abi, bytecode=bytecode)

        # 構建部署交易
        tx = contract.constructor(
            name, symbol, decimals, initial_supply
        ).build_transaction({
            "from": self.account.address,
            "nonce": self.w3.eth.get_transaction_count(self.account.address),
            "gas": 2000000,
            "maxFeePerGas": self.w3.eth.get_block("latest")["baseFeePerGas"] * 2,
            "maxPriorityFeePerGas": self.w3.to_wei("2", "gwei"),
        })

        # 簽名並發送
        signed = self.account.sign_transaction(tx)
        tx_hash = self.w3.eth.send_raw_transaction(signed.raw_transaction)

        # 等待部署完成
        receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)

        return {
            "tx_hash": tx_hash.hex(),
            "contract_address": receipt["contractAddress"],
            "block_number": receipt["blockNumber"],
            "gas_used": receipt["gasUsed"],
        }
</code></pre>
<p><strong>部署檢查清單</strong>：</p>
<ol>
<li><code>decimals</code> 一旦設定就不可更改，USDT 用 6、大多數 token 用 18</li>
<li><code>initialSupply</code> 計算時要考慮 decimals：如果 decimals=18，initialSupply=1000 代表 1000 * 10^18 最小單位</li>
<li>部署後在 Etherscan 上驗證合約原始碼，讓使用者可以閱讀和驗證合約邏輯</li>
<li>Mint 權限不要給單一 EOA，使用多簽錢包或 DAO 治理</li>
</ol>
<h3 id="924-錢包如何支援token轉移-p0"><a class="header" href="#924-錢包如何支援token轉移-p0">9.2.4 錢包如何支援Token轉移 <code>P0</code></a></h3>
<p>流程：</p>
<ol>
<li>載入 ABI</li>
<li><code>transfer(to, amount)</code> 打包 data</li>
<li>建交易並簽名</li>
<li>發送交易並追 receipt</li>
</ol>
<p>Token 轉移與 ETH 轉移的核心差異在於：Token 轉移是對 token 合約的函數呼叫，而非直接的 value transfer。交易的 <code>to</code> 欄位是 token 合約地址，<code>value</code> 為 0，<code>data</code> 欄位包含了 <code>transfer(address,uint256)</code> 的 ABI 編碼。</p>
<pre><code class="language-python">from web3 import Web3
from eth_account import Account

class TokenTransfer:
    """ERC-20 Token 轉移"""

    # ERC-20 最小 ABI（只需要 transfer 和 balanceOf）
    ERC20_ABI = [
        {
            "inputs": [
                {"name": "to", "type": "address"},
                {"name": "amount", "type": "uint256"}
            ],
            "name": "transfer",
            "outputs": [{"name": "", "type": "bool"}],
            "stateMutability": "nonpayable",
            "type": "function"
        },
        {
            "inputs": [{"name": "account", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"name": "", "type": "uint256"}],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "decimals",
            "outputs": [{"name": "", "type": "uint8"}],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "symbol",
            "outputs": [{"name": "", "type": "string"}],
            "stateMutability": "view",
            "type": "function"
        }
    ]

    def __init__(self, w3: Web3, token_address: str):
        self.w3 = w3
        self.contract = w3.eth.contract(
            address=Web3.to_checksum_address(token_address),
            abi=self.ERC20_ABI
        )

    def get_token_info(self) -&gt; dict:
        """查詢 token 基本資訊"""
        return {
            "address": self.contract.address,
            "symbol": self.contract.functions.symbol().call(),
            "decimals": self.contract.functions.decimals().call(),
        }

    def build_transfer_tx(self, from_addr: str, to_addr: str,
                           amount_human: float) -&gt; dict:
        """
        構建 token 轉帳交易
        amount_human: 人類可讀金額（如 100.5 USDT）
        """
        decimals = self.contract.functions.decimals().call()
        amount_raw = int(amount_human * 10**decimals)

        # 檢查餘額
        balance = self.contract.functions.balanceOf(
            Web3.to_checksum_address(from_addr)
        ).call()

        if balance &lt; amount_raw:
            raise ValueError(
                f"Insufficient balance: "
                f"have {balance / 10**decimals}, "
                f"need {amount_human}"
            )

        # 構建交易
        tx = self.contract.functions.transfer(
            Web3.to_checksum_address(to_addr),
            amount_raw
        ).build_transaction({
            "from": Web3.to_checksum_address(from_addr),
            "nonce": self.w3.eth.get_transaction_count(from_addr, "pending"),
            "gas": 100000,  # ERC-20 transfer 通常需要 50k-70k gas
            "maxFeePerGas": self.w3.eth.get_block("latest")["baseFeePerGas"] * 2,
            "maxPriorityFeePerGas": self.w3.to_wei("2", "gwei"),
            "chainId": self.w3.eth.chain_id,
        })

        return tx

    def sign_and_send(self, tx: dict, private_key: str) -&gt; dict:
        """簽名並發送交易"""
        signed = Account.sign_transaction(tx, private_key)
        tx_hash = self.w3.eth.send_raw_transaction(signed.raw_transaction)
        receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)

        return {
            "tx_hash": tx_hash.hex(),
            "status": "success" if receipt["status"] == 1 else "failed",
            "gas_used": receipt["gasUsed"],
        }

# 使用範例
w3 = Web3(Web3.HTTPProvider("https://mainnet.infura.io/v3/YOUR_KEY"))

# USDT 合約
usdt = TokenTransfer(w3, "0xdAC17F958D2ee523a2206206994597C13D831ec7")

info = usdt.get_token_info()
print(f"Token: {info['symbol']}, Decimals: {info['decimals']}")

# 構建交易
tx = usdt.build_transfer_tx(
    from_addr="0xYourAddress",
    to_addr="0xRecipient",
    amount_human=100.0  # 轉 100 USDT
)

# 簽名並發送
result = usdt.sign_and_send(tx, "0xYourPrivateKey")
print(f"Result: {result}")
</code></pre>
<p><strong>常見陷阱</strong>：</p>
<ol>
<li><strong>Gas 估算</strong>：不同的 token 合約 transfer 函數消耗的 gas 不同（例如有些 token 有轉帳稅、有些有黑名單檢查），建議使用 <code>eth_estimateGas</code> 動態估算而非硬編碼</li>
<li><strong>Approval 流程</strong>：如果是透過第三方合約（如 DEX）轉帳，需要先 approve 再 transferFrom</li>
<li><strong>Fee-on-Transfer Token</strong>：有些 token 在轉帳時會扣手續費，實際到帳金額會少於發送金額</li>
</ol>
<h3 id="925-錢包如何支援token查詢-p0"><a class="header" href="#925-錢包如何支援token查詢-p0">9.2.5 錢包如何支援Token查詢 <code>P0</code></a></h3>
<p>必要查詢：</p>
<ul>
<li><code>balanceOf</code></li>
<li><code>allowance</code></li>
<li>Token 清單與價格映射（可選）</li>
</ul>
<p>工程要點：</p>
<ul>
<li>多鏈多 token 用統一主鍵管理</li>
<li>對 decimals/symbol 做快取</li>
</ul>
<p>Token 查詢是錢包使用者體驗的重要組成部分。使用者期望看到自己持有的所有 token 的餘額、價格、以及總資產價值。</p>
<pre><code class="language-python">from web3 import Web3
from dataclasses import dataclass
from typing import List, Dict, Optional
import json

@dataclass
class TokenBalance:
    contract_address: str
    symbol: str
    decimals: int
    balance_raw: int
    balance_human: float

class TokenQueryService:
    """Token 查詢服務"""

    ERC20_BALANCE_ABI = [
        {
            "inputs": [{"name": "account", "type": "address"}],
            "name": "balanceOf",
            "outputs": [{"name": "", "type": "uint256"}],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "symbol",
            "outputs": [{"name": "", "type": "string"}],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [],
            "name": "decimals",
            "outputs": [{"name": "", "type": "uint8"}],
            "stateMutability": "view",
            "type": "function"
        },
        {
            "inputs": [
                {"name": "owner", "type": "address"},
                {"name": "spender", "type": "address"}
            ],
            "name": "allowance",
            "outputs": [{"name": "", "type": "uint256"}],
            "stateMutability": "view",
            "type": "function"
        }
    ]

    def __init__(self, w3: Web3):
        self.w3 = w3
        self._token_cache: Dict[str, dict] = {}  # 快取 token metadata

    def _get_token_metadata(self, token_address: str) -&gt; dict:
        """獲取 token 的 metadata（帶快取）"""
        addr = Web3.to_checksum_address(token_address)
        if addr not in self._token_cache:
            contract = self.w3.eth.contract(address=addr, abi=self.ERC20_BALANCE_ABI)
            try:
                self._token_cache[addr] = {
                    "symbol": contract.functions.symbol().call(),
                    "decimals": contract.functions.decimals().call(),
                }
            except Exception:
                self._token_cache[addr] = {"symbol": "???", "decimals": 18}
        return self._token_cache[addr]

    def get_token_balance(self, user_address: str,
                          token_address: str) -&gt; TokenBalance:
        """查詢單一 token 餘額"""
        addr = Web3.to_checksum_address(token_address)
        user = Web3.to_checksum_address(user_address)
        contract = self.w3.eth.contract(address=addr, abi=self.ERC20_BALANCE_ABI)

        meta = self._get_token_metadata(token_address)
        balance = contract.functions.balanceOf(user).call()

        return TokenBalance(
            contract_address=addr,
            symbol=meta["symbol"],
            decimals=meta["decimals"],
            balance_raw=balance,
            balance_human=balance / 10**meta["decimals"]
        )

    def get_all_balances(self, user_address: str,
                         token_list: List[str]) -&gt; List[TokenBalance]:
        """批量查詢多個 token 的餘額"""
        results = []
        for token_addr in token_list:
            try:
                bal = self.get_token_balance(user_address, token_addr)
                if bal.balance_raw &gt; 0:
                    results.append(bal)
            except Exception as e:
                print(f"Error querying {token_addr}: {e}")
                continue
        return results

    def get_allowance(self, owner: str, spender: str,
                      token_address: str) -&gt; float:
        """查詢授權額度"""
        contract = self.w3.eth.contract(
            address=Web3.to_checksum_address(token_address),
            abi=self.ERC20_BALANCE_ABI
        )
        meta = self._get_token_metadata(token_address)
        raw = contract.functions.allowance(
            Web3.to_checksum_address(owner),
            Web3.to_checksum_address(spender)
        ).call()
        return raw / 10**meta["decimals"]

# 使用範例
w3 = Web3(Web3.HTTPProvider("https://mainnet.infura.io/v3/YOUR_KEY"))
service = TokenQueryService(w3)

# 常見 token 地址
TOKENS = {
    "USDT": "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    "USDC": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    "DAI": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
    "WETH": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
}

# 查詢所有 token 餘額
balances = service.get_all_balances(
    "0xYourAddress",
    list(TOKENS.values())
)

for bal in balances:
    print(f"  {bal.symbol}: {bal.balance_human}")
</code></pre>
<p><strong>多鏈支援</strong> 是現代錢包的標準需求。使用者可能同時使用 Ethereum、Polygon、Arbitrum、BSC 等多條鏈。工程上建議用 <code>(chain_id, token_address)</code> 作為 token 的唯一主鍵，因為同一個 token 在不同鏈上的合約地址通常不同。</p>
<h3 id="926-事件訂閱-p0"><a class="header" href="#926-事件訂閱-p0">9.2.6 事件訂閱 <code>P0</code></a></h3>
<p>用途：</p>
<ul>
<li>實時更新交易狀態</li>
<li>觸發通知與風控</li>
<li>事後審計</li>
</ul>
<p>訂閱策略：</p>
<ul>
<li>websocket 實時訂閱</li>
<li>定時補塊避免漏事件</li>
<li>重組時回滾本地狀態</li>
</ul>
<p>事件訂閱是錢包系統中最容易出問題的環節之一。鏈上事件可能因為網路延遲、節點故障、區塊重組等原因被遺漏或重複，必須有完善的補償機制。</p>
<pre><code class="language-python">import asyncio
from web3 import Web3
from web3.logs import DISCARD
import json
import time
from typing import Callable, List

class EventSubscriber:
    """事件訂閱服務"""

    def __init__(self, ws_url: str, http_url: str):
        self.ws_w3 = Web3(Web3.WebsocketProvider(ws_url))
        self.http_w3 = Web3(Web3.HTTPProvider(http_url))
        self.last_processed_block = 0
        self._handlers = {}

    def register_handler(self, event_name: str,
                         handler: Callable):
        """註冊事件處理函數"""
        self._handlers[event_name] = handler

    def subscribe_transfer_events(self, token_address: str,
                                   watched_addresses: List[str]):
        """
        訂閱 ERC-20 Transfer 事件
        使用 polling 方式（更可靠）
        """
        token = Web3.to_checksum_address(token_address)
        addresses = [Web3.to_checksum_address(a) for a in watched_addresses]

        # Transfer 事件的 topic
        transfer_topic = Web3.keccak(text="Transfer(address,address,uint256)")

        while True:
            try:
                current_block = self.http_w3.eth.block_number

                # 避免處理還不穩定的區塊（可能重組）
                safe_block = current_block - 3  # 3 blocks 確認

                if safe_block &lt;= self.last_processed_block:
                    time.sleep(2)
                    continue

                # 查詢事件日誌
                logs = self.http_w3.eth.get_logs({
                    "fromBlock": self.last_processed_block + 1,
                    "toBlock": safe_block,
                    "address": token,
                    "topics": [transfer_topic.hex()],
                })

                for log in logs:
                    from_addr = "0x" + log["topics"][1].hex()[-40:]
                    to_addr = "0x" + log["topics"][2].hex()[-40:]

                    # 只處理關注的地址
                    from_checksum = Web3.to_checksum_address(from_addr)
                    to_checksum = Web3.to_checksum_address(to_addr)

                    if from_checksum in addresses or to_checksum in addresses:
                        amount = int(log["data"].hex(), 16)
                        self._process_transfer(
                            log["transactionHash"].hex(),
                            log["blockNumber"],
                            from_checksum,
                            to_checksum,
                            amount
                        )

                self.last_processed_block = safe_block
                print(f"Processed up to block {safe_block}")

            except Exception as e:
                print(f"Error in event loop: {e}")
                time.sleep(5)  # 出錯後等待重試

    def _process_transfer(self, tx_hash, block, from_addr, to_addr, amount):
        """處理 Transfer 事件"""
        handler = self._handlers.get("transfer")
        if handler:
            handler({
                "tx_hash": tx_hash,
                "block": block,
                "from": from_addr,
                "to": to_addr,
                "amount": amount,
            })

    def backfill(self, token_address: str, from_block: int,
                 to_block: int, watched_addresses: List[str]):
        """
        補塊掃描：檢查遺漏的事件
        應該定期執行，確保沒有漏單
        """
        print(f"Backfilling blocks {from_block} to {to_block}...")
        self.last_processed_block = from_block - 1
        # 臨時設定為需要補掃的範圍
        # 複用 subscribe 的邏輯但只掃一次

# 使用範例
def on_transfer(event):
    print(f"Transfer detected!")
    print(f"  TX: {event['tx_hash']}")
    print(f"  From: {event['from']}")
    print(f"  To: {event['to']}")
    print(f"  Amount: {event['amount']}")

subscriber = EventSubscriber(
    ws_url="wss://mainnet.infura.io/ws/v3/YOUR_KEY",
    http_url="https://mainnet.infura.io/v3/YOUR_KEY"
)

subscriber.register_handler("transfer", on_transfer)

# 監控 USDT 轉帳
subscriber.subscribe_transfer_events(
    token_address="0xdAC17F958D2ee523a2206206994597C13D831ec7",
    watched_addresses=["0xYourAddress1", "0xYourAddress2"]
)
</code></pre>
<pre><code class="language-text">事件訂閱的可靠性策略：

┌───────────────────────────────────────────────────┐
│               Event Processing Pipeline           │
│                                                    │
│  1. Real-time Polling (主通道)                     │
│     ┌─────┐  每 2 秒  ┌─────────────┐            │
│     │Timer│ ─────────&gt; │ get_logs()  │            │
│     └─────┘            └──────┬──────┘            │
│                               │                    │
│  2. Confirmation Delay (安全延遲)                  │
│     等待 3-12 個區塊確認後才處理                    │
│     避免因區塊重組而處理到被回滾的事件               │
│                               │                    │
│  3. Backfill Scanner (補塊掃描)                    │
│     ┌──────────┐  定期  ┌──────────────┐          │
│     │ Cron Job │ ─────&gt; │ 掃描已處理的  │          │
│     └──────────┘        │ 區塊範圍     │          │
│                         └──────┬───────┘          │
│                                │                   │
│  4. Deduplication (去重)                           │
│     使用 (tx_hash, log_index) 作為唯一鍵           │
│     避免重複處理同一個事件                          │
│                                │                   │
│                                v                   │
│  5. Persistent Storage (持久化)                    │
│     記錄 last_processed_block                      │
│     服務重啟後可以從斷點繼續                        │
└───────────────────────────────────────────────────┘
</code></pre>
<p><strong>區塊重組（Reorg）</strong> 是事件訂閱中最棘手的問題。當兩個驗證者幾乎同時提出有效區塊時，網路會暫時分叉。最終只有一條分叉會被接受，另一條會被丟棄。如果你已經處理了被丟棄分叉上的事件，就需要回滾本地狀態。解決方案是等待足夠的確認數（Ethereum 通常 12 個區塊就很安全了）再處理事件。</p>
<h2 id="python-工程實作骨架"><a class="header" href="#python-工程實作骨架">Python 工程實作骨架</a></h2>
<pre><code class="language-python">from web3 import Web3

w3 = Web3(Web3.HTTPProvider(RPC_URL))
acct = w3.eth.account.from_key(PRIVATE_KEY)

tx = {
    "to": to_addr,
    "value": amount_wei,
    "nonce": w3.eth.get_transaction_count(acct.address),
    "gas": 21000,
    "maxFeePerGas": w3.to_wei("30", "gwei"),
    "maxPriorityFeePerGas": w3.to_wei("2", "gwei"),
    "chainId": chain_id,
}

signed = acct.sign_transaction(tx)
tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction)
</code></pre>
<p>以上是最精簡的交易發送骨架。在此基礎上，一個完整的生產級錢包系統還需要加上以下元件：</p>
<pre><code class="language-python">"""
完整的離線錢包系統骨架
"""
from web3 import Web3
from eth_account import Account
import json
import os
from typing import Optional
from dataclasses import dataclass

@dataclass
class WalletConfig:
    rpc_url: str
    chain_id: int
    keystore_dir: str
    gas_buffer: float = 1.2  # gas 估算的安全係數

class OfflineWallet:
    """
    離線錢包完整實作骨架

    使用流程：
    1. 離線生成錢包（generate_wallet）
    2. 線上構建交易（build_transaction）
    3. 離線簽名（sign_transaction）
    4. 線上廣播（broadcast_transaction）
    """

    def __init__(self, config: WalletConfig):
        self.config = config
        self.w3 = Web3(Web3.HTTPProvider(config.rpc_url))
        os.makedirs(config.keystore_dir, exist_ok=True)

    # ========== 離線操作 ==========

    def generate_wallet(self, password: str) -&gt; dict:
        """生成新錢包（離線操作）"""
        acct = Account.create()
        keystore = Account.encrypt(acct.key, password)

        filepath = os.path.join(
            self.config.keystore_dir,
            f"UTC--{acct.address}.json"
        )
        with open(filepath, "w") as f:
            json.dump(keystore, f)

        return {"address": acct.address, "keystore": filepath}

    def sign_transaction(self, unsigned_tx: dict,
                         keystore_path: str, password: str) -&gt; str:
        """
        簽名交易（離線操作）
        輸入：未簽名的交易 JSON
        輸出：已簽名的 raw transaction (hex)
        """
        with open(keystore_path) as f:
            keystore = json.load(f)
        private_key = Account.decrypt(keystore, password)
        signed = Account.sign_transaction(unsigned_tx, private_key)
        del private_key  # 清理私鑰
        return signed.raw_transaction.hex()

    # ========== 線上操作 ==========

    def build_eth_transfer(self, from_addr: str, to_addr: str,
                            amount_wei: int) -&gt; dict:
        """構建 ETH 轉帳交易（線上操作）"""
        base_fee = self.w3.eth.get_block("latest")["baseFeePerGas"]

        return {
            "type": 2,
            "chainId": self.config.chain_id,
            "nonce": self.w3.eth.get_transaction_count(from_addr, "pending"),
            "to": Web3.to_checksum_address(to_addr),
            "value": amount_wei,
            "gas": 21000,
            "maxFeePerGas": int(base_fee * 2),
            "maxPriorityFeePerGas": self.w3.to_wei("2", "gwei"),
        }

    def build_token_transfer(self, from_addr: str, token_addr: str,
                              to_addr: str, amount_raw: int,
                              abi: list) -&gt; dict:
        """構建 Token 轉帳交易（線上操作）"""
        contract = self.w3.eth.contract(
            address=Web3.to_checksum_address(token_addr),
            abi=abi
        )

        tx = contract.functions.transfer(
            Web3.to_checksum_address(to_addr),
            amount_raw
        ).build_transaction({
            "from": Web3.to_checksum_address(from_addr),
            "nonce": self.w3.eth.get_transaction_count(from_addr, "pending"),
            "chainId": self.config.chain_id,
        })

        # 估算 gas 並加上安全係數
        estimated_gas = self.w3.eth.estimate_gas(tx)
        tx["gas"] = int(estimated_gas * self.config.gas_buffer)

        base_fee = self.w3.eth.get_block("latest")["baseFeePerGas"]
        tx["maxFeePerGas"] = int(base_fee * 2)
        tx["maxPriorityFeePerGas"] = self.w3.to_wei("2", "gwei")

        return tx

    def broadcast_transaction(self, raw_tx_hex: str) -&gt; dict:
        """廣播交易（線上操作）"""
        raw_tx = bytes.fromhex(raw_tx_hex.replace("0x", ""))
        tx_hash = self.w3.eth.send_raw_transaction(raw_tx)

        receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)

        return {
            "tx_hash": tx_hash.hex(),
            "status": "success" if receipt["status"] == 1 else "failed",
            "block": receipt["blockNumber"],
            "gas_used": receipt["gasUsed"],
        }

    def get_balance(self, address: str) -&gt; dict:
        """查詢餘額（線上操作）"""
        addr = Web3.to_checksum_address(address)
        balance = self.w3.eth.get_balance(addr)
        return {
            "address": addr,
            "balance_wei": balance,
            "balance_eth": float(Web3.from_wei(balance, "ether")),
        }
</code></pre>
<h2 id="常見坑與修正"><a class="header" href="#常見坑與修正">常見坑與修正</a></h2>
<ul>
<li>nonce 衝突：引入 nonce manager</li>
<li>gas 估算偏低：加安全係數 + 模擬</li>
<li>盲簽風險：簽名前展示可讀交易摘要</li>
<li>事件漏單：補塊掃描 + 去重存儲</li>
</ul>
<p>讓我們深入探討每一個常見問題的根因和解決方案。</p>
<p><strong>Nonce 衝突</strong> 是最頻繁遇到的問題。Nonce 是一個遞增的計數器，每筆交易都必須有唯一的 nonce。如果兩筆交易使用了相同的 nonce，只有一筆會被接受。在多線程或多進程環境中，如果兩個線程同時查詢 nonce 並各自發送交易，就會出現 nonce 衝突。</p>
<pre><code class="language-python">import threading
import redis

class NonceManager:
    """線程安全的 Nonce 管理器"""

    def __init__(self, w3: Web3, address: str,
                 redis_client: redis.Redis = None):
        self.w3 = w3
        self.address = Web3.to_checksum_address(address)
        self._lock = threading.Lock()
        self._redis = redis_client
        self._local_nonce = None

    def get_next_nonce(self) -&gt; int:
        """獲取下一個可用的 nonce"""
        if self._redis:
            return self._get_nonce_redis()
        return self._get_nonce_local()

    def _get_nonce_local(self) -&gt; int:
        """本地鎖方案（單進程）"""
        with self._lock:
            chain_nonce = self.w3.eth.get_transaction_count(
                self.address, "pending"
            )
            if self._local_nonce is None or chain_nonce &gt; self._local_nonce:
                self._local_nonce = chain_nonce
            else:
                self._local_nonce += 1
            return self._local_nonce

    def _get_nonce_redis(self) -&gt; int:
        """Redis 方案（多進程/多機器）"""
        key = f"nonce:{self.address}"

        # 使用 Redis INCR 保證原子性
        chain_nonce = self.w3.eth.get_transaction_count(
            self.address, "pending"
        )

        # 確保 Redis 中的 nonce 不低於鏈上 nonce
        while True:
            current = self._redis.get(key)
            if current is None or int(current) &lt; chain_nonce:
                self._redis.set(key, chain_nonce)
            break

        return self._redis.incr(key) - 1

    def reset(self):
        """重置 nonce（當交易卡住時使用）"""
        chain_nonce = self.w3.eth.get_transaction_count(
            self.address, "latest"
        )
        with self._lock:
            self._local_nonce = chain_nonce
        if self._redis:
            self._redis.set(f"nonce:{self.address}", chain_nonce)
</code></pre>
<p><strong>Gas 估算偏低</strong> 會導致交易 revert（Out of Gas），但 gas 已經被消耗了。解決方案是在 <code>eth_estimateGas</code> 的結果上加 20-50% 的安全係數，同時設定一個合理的上限避免支付天價 gas。</p>
<pre><code class="language-python">def safe_estimate_gas(w3, tx, buffer=1.2, max_gas=500000):
    """安全的 gas 估算"""
    try:
        estimated = w3.eth.estimate_gas(tx)
        gas = min(int(estimated * buffer), max_gas)
        return gas
    except Exception as e:
        # 如果估算失敗（交易會 revert），提前報錯
        raise ValueError(f"Transaction will revert: {e}")
</code></pre>
<p><strong>盲簽風險</strong> 是指使用者在不了解交易內容的情況下簽名。攻擊者可能構造一個看似正常的交易，但實際上包含惡意的 data 欄位。解決方案是在簽名前解析並展示交易的完整內容。</p>
<pre><code class="language-python">def decode_transaction(w3, tx, abi=None):
    """解碼交易內容為人類可讀格式"""
    result = {
        "to": tx.get("to", "Contract Creation"),
        "value": f"{Web3.from_wei(tx.get('value', 0), 'ether')} ETH",
        "gas": tx.get("gas", "unknown"),
        "nonce": tx.get("nonce"),
        "chain_id": tx.get("chainId"),
    }

    data = tx.get("data", "0x")
    if data and data != "0x" and abi:
        contract = w3.eth.contract(abi=abi)
        try:
            func, params = contract.decode_function_input(data)
            result["function"] = func.fn_name
            result["params"] = dict(params)
        except Exception:
            result["raw_data"] = data[:66] + "..."

    return result
</code></pre>
<p><strong>事件漏單</strong> 在網路不穩定或服務重啟時最容易發生。解決方案是持久化記錄已處理的最新區塊號，服務重啟後從該區塊繼續掃描。同時定期進行補塊掃描，用 <code>(tx_hash, log_index)</code> 組合作為唯一鍵去重，避免重複處理。</p>
<h2 id="93-章節回顧與安全工程原則"><a class="header" href="#93-章節回顧與安全工程原則">9.3 章節回顧與安全工程原則</a></h2>
<p>離線錢包不是功能集合，而是安全流程：</p>
<ul>
<li>密鑰隔離</li>
<li>簽名可信</li>
<li>交易可追</li>
<li>事故可回應</li>
</ul>
<p>本章的核心訊息是：<strong>錢包的安全性取決於最薄弱的環節</strong>。即使私鑰管理做得再好，如果交易構建有漏洞（例如沒有驗證 <code>to</code> 地址），或者事件訂閱有遺漏（導致使用者看不到某筆轉帳），整個系統的可信度都會受損。</p>
<p><strong>密鑰隔離</strong> 是第一原則。私鑰永遠不應該出現在有網路連接的環境中。即使是在開發和測試階段，也應該養成使用 keystore 加密而非明文私鑰的習慣。</p>
<p><strong>簽名可信</strong> 意味著使用者必須能夠在簽名前看到完整且可理解的交易內容。「盲簽」是大量資產被盜的根源。</p>
<p><strong>交易可追</strong> 要求錢包系統必須完整記錄所有交易的生命週期：從構建、簽名、廣播、到確認。任何異常（如交易長時間 pending、gas 費異常高、轉帳到未知地址）都應該觸發告警。</p>
<p><strong>事故可回應</strong> 是最後的防線。當安全事件發生時（如私鑰洩露），系統必須能夠快速做出反應：暫停所有待處理的交易、通知相關人員、啟動資產轉移預案。在設計錢包系統時，就應該事先規劃好事故響應流程（incident response plan）。</p>
<h2 id="白話總結-21"><a class="header" href="#白話總結-21">白話總結</a></h2>
<p>離線錢包說白了就是把「保管鑰匙」和「開門」這兩件事情分開做。你的私鑰（鑰匙）放在一台完全斷網的電腦上，永遠不碰網路；要轉帳的時候，先在有網路的電腦上把交易內容準備好，用 USB 或 QR code 傳到離線電腦上簽名，簽完再傳回線上電腦廣播出去。助記詞就是私鑰的「人話版」，12 或 24 個英文單詞就能恢復你的所有帳戶，所以助記詞的安全性等於你全部資產的安全性——抄在紙上、鎖在保險箱裡，千萬別存手機或雲端。工程上最容易踩的坑有三個：nonce 衝突（多線程同時發交易會打架，要用鎖來管）、gas 估算偏低（預估值要加 20% buffer，不然交易會 revert 但錢照扣）、事件漏單（節點可能斷線，要有補塊掃描機制確保沒有遺漏）。Token 轉帳跟 ETH 轉帳不同，它本質上是對 token 合約發一筆函數呼叫，所以你需要知道合約的 ABI 和地址。最重要的一句話：錢包的安全性取決於最弱的環節，不管私鑰保管多安全，只要簽名環節或交易追蹤有漏洞，整個系統就不可信。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第4篇-go語言區塊鏈實作篇"><a class="header" href="#第4篇-go語言區塊鏈實作篇">第4篇 Go語言區塊鏈實作篇</a></h1>
<p>這一篇是偏工程落地的 Go 路線，從原理到實作一條龍。</p>
<h2 id="重要度分級-2"><a class="header" href="#重要度分級-2">重要度分級</a></h2>
<ul>
<li><code>P0</code> 必修：直接影響你是否能寫出可運行鏈/錢包</li>
<li><code>P1</code> 重要：提升架構品質與擴展能力</li>
<li><code>P2</code> 補充：行業背景與案例延伸</li>
</ul>
<h2 id="建議學習路徑"><a class="header" href="#建議學習路徑">建議學習路徑</a></h2>
<ol>
<li>先讀第3章建立底層概念</li>
<li>再做第4章合約與 Go 調用</li>
<li>接第5章從零實作鏈核心</li>
<li>最後第6章完成離線錢包</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第3章-區塊鏈原理發展與應用"><a class="header" href="#第3章-區塊鏈原理發展與應用">第3章 區塊鏈原理、發展與應用</a></h1>
<p>本章目標是建立能落地開發的底層心智模型：你要知道鏈為何存在、如何達成一致、資料怎麼驗證、系統如何選型。</p>
<h2 id="31-區塊鏈基本原理"><a class="header" href="#31-區塊鏈基本原理">3.1 區塊鏈基本原理</a></h2>
<h3 id="311-區塊鏈技術為什麼會產生-p0"><a class="header" href="#311-區塊鏈技術為什麼會產生-p0">3.1.1 區塊鏈技術為什麼會產生 <code>P0</code></a></h3>
<p>在傳統中心化系統裡，資料正確性來自單一權威（銀行、平台、政府資料庫）。
區塊鏈的核心問題是：</p>
<ul>
<li>如果沒有中心機構，如何讓所有節點相信「同一本帳」？</li>
<li>如果人人可發交易，如何防止同一筆資產被重複花費（雙花）？</li>
</ul>
<p>工程上可把區塊鏈理解為三件事的組合：</p>
<ol>
<li><code>資料結構</code>：用 hash 鏈接區塊，保證歷史難以篡改。</li>
<li><code>網路協議</code>：用 P2P 傳播交易與區塊。</li>
<li><code>共識機制</code>：決定哪條鏈是全網接受的正確歷史。</li>
</ol>
<p>要理解區塊鏈為什麼會產生，可以從「拜占庭將軍問題」說起。想像有多個將軍需要協調進攻，但彼此之間只能靠信使溝通，而且有些將軍可能是叛徒。傳統做法是設一個總司令（中心化權威），但如果總司令本身不可信或者倒下了，系統就崩潰了。區塊鏈的方案是：讓所有將軍透過一套數學規則自行達成一致，不需要信任任何單一個體。</p>
<p>從工程實務來看，中心化系統的瓶頸不僅是信任問題，更是單點故障問題。2016 年 Bangladesh Bank 被駭客透過 SWIFT 系統盜走 8100 萬美元，正是因為所有授權都集中在單一節點。區塊鏈透過分散驗證，讓攻擊成本從「攻破一個點」變成「攻破多數節點」，這在密碼學保證下幾乎不可行。</p>
<pre><code class="language-text">傳統中心化架構：                     區塊鏈去中心化架構：

     ┌─────────┐                    ┌──────┐    ┌──────┐
     │ 中心DB  │                    │Node A│&lt;──&gt;│Node B│
     └────┬────┘                    └──┬───┘    └──┬───┘
    ┌─────┼─────┐                     │            │
    │     │     │                  ┌──┴───┐    ┌──┴───┐
  User  User  User                │Node C│&lt;──&gt;│Node D│
                                  └──────┘    └──────┘
  單點故障 / 單點信任               每個節點持有完整帳本副本
</code></pre>
<p>真實案例：2008 年金融危機後，人們對銀行系統的信任降到冰點。Satoshi Nakamoto 在 Bitcoin 白皮書中明確寫道：「A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution.」這不只是技術選擇，更是對信任模型的根本重設。</p>
<h3 id="312-什麼是-hash-函數-p0"><a class="header" href="#312-什麼是-hash-函數-p0">3.1.2 什麼是 hash 函數 <code>P0</code></a></h3>
<p>hash 函數把任意長度輸入映射成固定長度輸出，典型特性：</p>
<ul>
<li>不可逆：難以從 hash 反推出原文</li>
<li>抗碰撞：難找兩份不同資料得到同 hash</li>
<li>雪崩效應：輸入改一點，輸出大幅改變</li>
</ul>
<p>在區塊鏈中，hash 用於：</p>
<ul>
<li>交易 ID</li>
<li>區塊 ID</li>
<li>區塊鏈接（前一區塊 hash）</li>
<li>Merkle Root（交易集合摘要）</li>
</ul>
<p>hash 函數是區塊鏈最基礎的密碼學工具，理解它的運作方式對後續所有章節都至關重要。以 SHA-256 為例，無論輸入是 1 byte 還是 1 GB，輸出永遠是 32 bytes（256 bits）。這個特性讓我們可以用固定大小的「指紋」來代表任意大小的資料。</p>
<p>雪崩效應是 hash 函數最驚人的特性之一。把 "hello" 的 SHA-256 和 "hello!" 的 SHA-256 對比，兩者完全不同，沒有任何統計相關性。這意味著你無法透過觀察 hash 值的變化來推斷輸入的變化。在區塊鏈中，這保證了只要交易內容被改動一個 bit，整個區塊的 hash 就會完全不同，從而破壞鏈的連續性。</p>
<p>抗碰撞性的實務意義在於：如果兩筆不同的交易可以產生相同的 hash，攻擊者就能用一筆合法交易的 hash 替換成惡意交易。SHA-256 的碰撞空間是 2^256，大約是宇宙中原子數量的平方，在可預見的計算能力下不可能暴力碰撞。</p>
<p>Go 實作要點：</p>
<ul>
<li>使用 <code>crypto/sha256</code></li>
<li>輸入要先序列化成穩定格式</li>
<li>相同資料必須得到相同 hash</li>
</ul>
<pre><code class="language-go">package main

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
)

func main() {
	data := []byte("hello blockchain")
	sum := sha256.Sum256(data)
	hexID := hex.EncodeToString(sum[:])
	fmt.Println(hexID) // 固定產出相同結果
}

// 區塊 hash 計算範例
func HashBlock(prevHash []byte, merkleRoot []byte, timestamp int64, nonce int64) []byte {
	// 用 binary 序列化確保欄位順序固定
	headers := bytes.Join([][]byte{
		prevHash,
		merkleRoot,
		IntToHex(timestamp),
		IntToHex(nonce),
	}, []byte{})
	hash := sha256.Sum256(headers)
	return hash[:]
}
</code></pre>
<p>常見坑：</p>
<ul>
<li>直接 <code>fmt.Sprintf</code> 拼字串做 hash，格式不穩定</li>
<li>忘記固定欄位順序導致 hash 不一致</li>
<li>在不同平台上使用不同 endianness 序列化整數，導致跨平台 hash 結果不同</li>
<li>把 hash 結果當字串比較而非 bytes 比較，浪費效能且可能出現大小寫問題</li>
</ul>
<p>最佳實踐：</p>
<ul>
<li>永遠使用 binary encoding（big endian）來序列化整數欄位</li>
<li>建立一個統一的 <code>serialize()</code> 函數，所有需要 hash 的結構都走同一條路</li>
<li>為 hash 計算寫單元測試，用已知輸入驗證輸出（regression test）</li>
</ul>
<h3 id="313-p2p-網絡簡介-p0"><a class="header" href="#313-p2p-網絡簡介-p0">3.1.3 P2P 網絡簡介 <code>P0</code></a></h3>
<p>P2P 是節點對等連線：每個節點同時是 client 與 server。</p>
<p>最小網路流程：</p>
<ol>
<li>節點發現（bootstrap / DNS / seed）</li>
<li>建立連線（TCP/QUIC）</li>
<li>握手（版本、鏈高度、能力）</li>
<li>訊息傳播（交易、區塊、請求/回應）</li>
</ol>
<pre><code class="language-text">Node A &lt;----&gt; Node B &lt;----&gt; Node C
   ^            |             |
   +------------+-------------+
</code></pre>
<p>P2P 網路是區塊鏈去中心化的基礎設施層。不同於傳統 client-server 模型，P2P 網路中每個節點都平等地參與資料傳播和驗證。Bitcoin 的 P2P 網路設計精巧地解決了幾個核心問題：如何發現新節點、如何高效傳播資料、如何抵禦惡意節點。</p>
<p>節點發現是 P2P 網路的第一步。Bitcoin 使用了多重機制：硬編碼的 seed nodes 作為初始引導，DNS seeds 提供動態節點列表，以及 addr 訊息讓節點彼此交換已知的其他節點地址。一個新節點加入網路時，會先連上幾個 seed nodes，然後通過它們認識更多節點，逐步建立自己的 peer list。</p>
<pre><code class="language-text">新節點加入流程：

┌─────────┐  1. 連接 seed    ┌───────────┐
│ New Node │ ──────────────&gt; │ Seed Node │
└────┬────┘                  └─────┬─────┘
     │                              │
     │  2. 版本握手                  │
     │ &lt;───────────────────────────&gt; │
     │                              │
     │  3. 請求 addr 列表            │
     │ ────────────────────────────&gt; │
     │                              │
     │  4. 回覆已知節點列表          │
     │ &lt;──────────────────────────── │
     │                              │
     │  5. 連接更多節點              │
     │ ──────&gt; Node B, C, D...      │
     │                              │
     │  6. 同步區塊資料              │
     │ &lt;────── getblocks/inv/block   │
</code></pre>
<p>訊息傳播採用 gossip protocol：當一個節點收到新交易或區塊時，會通知它所有的 peers。這種「八卦式」傳播雖然會產生冗餘，但保證了資料能快速覆蓋全網。Bitcoin 主網大約 8 秒就能讓一筆交易傳播到全球大部分節點。</p>
<p>Go 實作要點：</p>
<ul>
<li>先做單一消息協議（<code>version</code>, <code>inv</code>, <code>getdata</code>, <code>block</code>）</li>
<li>每個連線獨立 goroutine</li>
<li>設計 message envelope：<code>type + payload + checksum</code></li>
</ul>
<pre><code class="language-go">// 消息封裝格式
type Message struct {
	Command  [12]byte // 消息類型，如 "version", "block"
	Length   uint32   // payload 長度
	Checksum [4]byte  // payload 前 4 bytes 的雙重 SHA256
	Payload  []byte   // 實際資料
}

// 每個 peer 連線的處理 goroutine
func handlePeer(conn net.Conn, blockchain *Blockchain) {
	defer conn.Close()
	for {
		msg, err := readMessage(conn)
		if err != nil {
			log.Printf("peer disconnected: %v", err)
			return
		}
		switch string(bytes.TrimRight(msg.Command[:], "\x00")) {
		case "version":
			handleVersion(conn, msg.Payload)
		case "getblocks":
			handleGetBlocks(conn, msg.Payload, blockchain)
		case "block":
			handleBlock(conn, msg.Payload, blockchain)
		}
	}
}
</code></pre>
<p>常見坑：</p>
<ul>
<li>沒有重放保護，收到同樣資料無限轉發</li>
<li>沒有節流，易被垃圾訊息打爆</li>
<li>沒有設定連線上限，一台機器被幾千個連線壓垮</li>
<li>握手超時沒處理，卡住的連線占用 goroutine 不釋放</li>
<li>同步區塊時沒有流量控制，一次請求太多區塊導致 OOM</li>
</ul>
<p>最佳實踐：</p>
<ul>
<li>為每個已知 txid/block hash 維護一個 seen set（用 LRU cache），避免重複轉發</li>
<li>設定 per-peer 和全局的訊息速率限制</li>
<li>實作 ban score 機制：行為異常的節點累加懲罰分數，超過閾值斷開</li>
</ul>
<h3 id="314-pow-共識算法-p0"><a class="header" href="#314-pow-共識算法-p0">3.1.4 PoW 共識算法 <code>P0</code></a></h3>
<p>PoW（Proof of Work）透過計算成本競爭出塊權：</p>
<ul>
<li>礦工調整 nonce，尋找符合難度目標的 hash</li>
<li>全網接受「累積工作量最高」的鏈</li>
</ul>
<p>核心公式（概念）：</p>
<ul>
<li>找到 <code>hash(block_header) &lt; target</code></li>
<li><code>target</code> 越小，難度越高</li>
</ul>
<p>PoW 的本質是用物理世界的能量消耗來換取數位世界的信任。這個設計的天才之處在於：計算 hash 需要消耗真實的電力，但驗證 hash 只需要一次計算。這種「做起來難、查起來容易」的非對稱性，正是 PoW 的安全基礎。</p>
<p>要理解難度調整，可以想像一個抽獎遊戲。target 就是中獎號碼的上限——如果 target 是 1000，那麼從 0 到 999 的號碼都算中獎，中獎率很高；如果 target 是 10，只有 0 到 9 能中獎，中獎率就低了很多。Bitcoin 每 2016 個區塊（大約兩週）調整一次 target，目標是讓平均出塊時間維持在 10 分鐘左右。如果過去兩週出塊太快，說明算力增加了，就把 target 調小讓難度升高。</p>
<pre><code class="language-text">難度調整機制：

出塊時間 &lt; 預期    ───&gt;  target 調小  ───&gt;  難度增加
                                              │
                        ┌─────────────────────┘
                        v
              維持平均出塊時間穩定
                        ^
                        └─────────────────────┐
                                              │
出塊時間 &gt; 預期    ───&gt;  target 調大  ───&gt;  難度降低

Bitcoin: 每 2016 blocks 調整一次，目標 10 min/block
</code></pre>
<p>工程視角：</p>
<ul>
<li>PoW 提供的是機率最終性，不是絕對最終性</li>
<li>確認數越高，被回滾機率越低</li>
<li>Bitcoin 慣例是 6 confirmations（約 1 小時）視為足夠安全</li>
</ul>
<p>在 Bitcoin 歷史上，最長的鏈重組（chain reorganization）發生在 2010 年，深度達到 53 個區塊，但那是因為一個嚴重的 bug 被修復後導致的。正常運行下，超過 6 個確認的區塊被回滾的機率極低（假設攻擊者沒有超過 50% 算力，回滾 6 blocks 的機率低於 0.1%）。</p>
<p>Go 實作要點：</p>
<ul>
<li>用 <code>math/big</code> 比較 hash 與 target</li>
<li>難度調整與區塊時間要解耦</li>
<li>驗證端一定要重算 header hash</li>
</ul>
<pre><code class="language-go">// PoW 挖礦核心邏輯
func (pow *ProofOfWork) Mine() (int64, []byte) {
	var hashInt big.Int
	var hash [32]byte
	nonce := int64(0)

	for nonce &lt; math.MaxInt64 {
		data := pow.prepareData(nonce)
		hash = sha256.Sum256(data)
		hashInt.SetBytes(hash[:])

		// hash &lt; target 表示找到了有效的 nonce
		if hashInt.Cmp(pow.target) == -1 {
			break
		}
		nonce++
	}
	return nonce, hash[:]
}

// 驗證 PoW —— 任何節點收到區塊後都必須執行
func (pow *ProofOfWork) Validate() bool {
	var hashInt big.Int
	data := pow.prepareData(pow.block.Nonce)
	hash := sha256.Sum256(data)
	hashInt.SetBytes(hash[:])
	return hashInt.Cmp(pow.target) == -1
}
</code></pre>
<p>常見坑：</p>
<ul>
<li>只驗 nonce 不驗完整 header</li>
<li>難度固定不調整，導致出塊失衡</li>
<li>沒有限制 nonce 搜索範圍，導致無限迴圈（應設合理上限或加入 extraNonce 機制）</li>
<li>用 <code>int32</code> 存 nonce 導致溢位（Bitcoin 用 uint32，但實務上會結合 extraNonce）</li>
</ul>
<h3 id="315-utxo-模型-p0"><a class="header" href="#315-utxo-模型-p0">3.1.5 UTXO 模型 <code>P0</code></a></h3>
<p>UTXO（未花費輸出）模型不是改餘額，而是消耗舊輸出、產生新輸出：</p>
<pre><code class="language-text">Inputs(引用舊UTXO) -&gt; Validation -&gt; Outputs(新UTXO + 找零)
</code></pre>
<p>交易費用：
<code>fee = sum(inputs) - sum(outputs)</code></p>
<p>UTXO 模型是 Bitcoin 最核心的設計之一，也是很多工程師最容易搞混的概念。我們習慣了銀行帳戶模型：你有一個餘額，轉帳就是從你的餘額扣掉一部分。但 UTXO 模型完全不同——你的「餘額」其實是散落在區塊鏈上、屬於你的所有未花費輸出的總和。</p>
<p>用現金來類比最直觀。你錢包裡有一張 100 元和兩張 50 元，你的「餘額」是 200 元，但實際上你持有的是三個獨立的「資金單位」。當你要付 120 元時，你不能把 100 元鈔票撕成 80 和 20，你必須拿出 100 + 50 = 150 元，然後收回 30 元找零。UTXO 就是這樣運作的：你選擇足夠的 inputs（舊鈔票），產生新的 outputs（給收款人的金額 + 找零給自己的金額）。</p>
<pre><code class="language-text">UTXO 交易範例：

Alice 持有的 UTXO:
  ┌───────────────┐
  │ UTXO-1: 5 BTC │  (來自之前某筆交易)
  └───────────────┘
  ┌───────────────┐
  │ UTXO-2: 3 BTC │  (來自之前某筆交易)
  └───────────────┘

Alice 想轉 6 BTC 給 Bob:

  ┌───────────────┐
  │ Input: UTXO-1 │──┐
  │ (5 BTC)       │  │     ┌────────────────────┐
  └───────────────┘  ├────&gt;│ Output-0: 6 BTC    │ → Bob
  ┌───────────────┐  │     │  (to Bob)           │
  │ Input: UTXO-2 │──┘     ├────────────────────┤
  │ (3 BTC)       │        │ Output-1: 1.999 BTC│ → Alice (找零)
  └───────────────┘        │  (to Alice change)  │
                           └────────────────────┘
                           fee = 8 - 7.999 = 0.001 BTC
</code></pre>
<p>為什麼 UTXO 重要：</p>
<ul>
<li>天然可追溯資產來源</li>
<li>不同 UTXO 可並行驗證</li>
<li>有利於審計與安全邊界設計</li>
<li>隱私性較好：每次找零可以用新地址</li>
</ul>
<p>UTXO 模型 vs Account 模型（Ethereum）的工程差異非常顯著。UTXO 模型天然支持並行驗證，因為每個 UTXO 是獨立的，不存在共享狀態。兩筆花費不同 UTXO 的交易可以同時驗證，不需要擔心順序問題。而 Account 模型中，同一個帳戶的多筆交易必須按 nonce 順序處理，這在高並發場景下會成為瓶頸。</p>
<p>Go 實作要點：</p>
<ul>
<li>建立 <code>TXInput</code>, <code>TXOutput</code>, <code>Transaction</code></li>
<li>維護 UTXO 集索引</li>
<li>coin selection 與 change address 分離</li>
</ul>
<pre><code class="language-go">// UTXO 集合查找
func (u *UTXOSet) FindSpendableOutputs(pubKeyHash []byte, amount int) (int, map[string][]int) {
	unspentOutputs := make(map[string][]int)
	accumulated := 0

	u.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte(utxoBucket))
		c := b.Cursor()
		for k, v := c.First(); k != nil; k, v = c.Next() {
			txID := hex.EncodeToString(k)
			outs := DeserializeOutputs(v)
			for outIdx, out := range outs.Outputs {
				if out.IsLockedWithKey(pubKeyHash) &amp;&amp; accumulated &lt; amount {
					accumulated += out.Value
					unspentOutputs[txID] = append(unspentOutputs[txID], outIdx)
				}
			}
		}
		return nil
	})
	return accumulated, unspentOutputs
}
</code></pre>
<p>常見坑：</p>
<ul>
<li>找零輸出漏建，資金等於白燒（這是真實發生過的事故，有人因此損失大量 BTC）</li>
<li>多輸入簽名只簽了一部分輸入</li>
<li>coin selection 演算法太貪心，產生大量碎片 UTXO，導致後續交易手續費過高</li>
<li>沒有考慮 dust limit（太小的 UTXO 沒有實用價值，因為花費它的手續費可能超過它的金額）</li>
</ul>
<p>最佳實踐：</p>
<ul>
<li>永遠在建立交易後檢查 <code>sum(inputs) &gt;= sum(outputs) + fee</code></li>
<li>coin selection 優先使用接近目標金額的 UTXO，減少碎片</li>
<li>找零地址與收款地址分開管理，提升隱私性</li>
</ul>
<h2 id="32-區塊鏈發展歷程"><a class="header" href="#32-區塊鏈發展歷程">3.2 區塊鏈發展歷程</a></h2>
<h3 id="321-區塊鏈發展現狀-p1"><a class="header" href="#321-區塊鏈發展現狀-p1">3.2.1 區塊鏈發展現狀 <code>P1</code></a></h3>
<p>現況是多鏈並行：</p>
<ul>
<li>L1 提供安全與結算</li>
<li>L2 提供擴容與低費</li>
<li>應用端分化為 DeFi、支付、RWA、遊戲、社交</li>
</ul>
<p>區塊鏈產業從 2009 年 Bitcoin 誕生至今，已經經歷了多次典範轉移。早期的「區塊鏈 1.0」時代以 Bitcoin 為代表，主要解決點對點電子現金問題。2015 年 Ethereum 上線後，「區塊鏈 2.0」時代開啟，智能合約讓鏈上可程式化成為現實。到了 2020 年代，產業進入多鏈並行時代，L1（如 Ethereum、Solana、Avalanche）提供底層安全和結算，L2（如 Arbitrum、Optimism、zkSync）提供擴容和低手續費。</p>
<p>從工程師的角度，現況的關鍵變化是：開發者不再只面對一條鏈。一個 DeFi 協議可能同時部署在 Ethereum mainnet、Arbitrum、Polygon 和 Base 上。這意味著後端系統需要處理多鏈索引、跨鏈訊息、以及不同鏈的確認時間差異。這對錢包和交易所的工程架構提出了更高的要求。</p>
<h3 id="322-區塊鏈-20-時代-p1"><a class="header" href="#322-區塊鏈-20-時代-p1">3.2.2 區塊鏈 2.0 時代 <code>P1</code></a></h3>
<p>2.0 一般指智能合約時代：</p>
<ul>
<li>不只轉帳，而是鏈上程式</li>
<li>出現可組合協議（借貸、交易、衍生品）</li>
</ul>
<p>Ethereum 最大的創新在於引入了圖靈完備的虛擬機（EVM）。Bitcoin 的 Script 語言是故意設計成非圖靈完備的——它只能做有限的條件判斷，無法實現循環和複雜邏輯。Ethereum 打破了這個限制，讓開發者可以在鏈上部署任意程式。這催生了 DeFi（去中心化金融）生態系統：Uniswap 用 AMM 演算法實現了無需做市商的代幣交易、Aave 實現了無需銀行的借貸、MakerDAO 創造了去中心化穩定幣。</p>
<p>可組合性（Composability）是區塊鏈 2.0 時代最有價值的特性之一。因為所有智能合約都部署在同一個 EVM 上，一個合約可以無許可地呼叫另一個合約。這被稱為「DeFi 樂高」——開發者可以像拼樂高一樣，把不同協議的功能組合起來，創造新的金融產品。例如，一筆交易可以同時在 Uniswap 換幣、在 Aave 借貸、在 Yearn 理財，全部在一個原子交易中完成。</p>
<h3 id="323-區塊鏈行業未來展望-p1"><a class="header" href="#323-區塊鏈行業未來展望-p1">3.2.3 區塊鏈行業未來展望 <code>P1</code></a></h3>
<p>主要方向：</p>
<ul>
<li>ZK 証明普及</li>
<li>Account Abstraction 提升錢包 UX</li>
<li>合規與鏈上身份整合</li>
<li>跨鏈互操作標準化</li>
</ul>
<p>ZK（Zero-Knowledge）證明是目前區塊鏈技術發展最重要的方向之一。ZK-Rollup 可以將數百筆交易壓縮成一個證明，在 L1 上驗證這個證明就等於驗證了所有交易。這不僅大幅提升了吞吐量，還保留了 L1 的安全性。zkSync、StarkNet、Polygon zkEVM 都是這個方向的代表項目。對後端工程師來說，理解 ZK 證明的生成和驗證流程，將成為未來幾年的核心競爭力。</p>
<p>Account Abstraction（AA，帳戶抽象）是另一個重要趨勢。傳統以太坊錢包的 UX 非常差：用戶需要管理私鑰、理解 gas、手動設定 nonce。ERC-4337 標準讓智能合約錢包成為一等公民，支持社交恢復、批量交易、gas 代付等功能。這對錢包開發工程師來說，意味著架構設計需要從「管理 EOA 私鑰」轉向「管理智能合約錢包」。</p>
<h2 id="33-區塊鏈開發技術選型"><a class="header" href="#33-區塊鏈開發技術選型">3.3 區塊鏈開發技術選型</a></h2>
<h3 id="331-dapp-架構分析-p0"><a class="header" href="#331-dapp-架構分析-p0">3.3.1 DApp 架構分析 <code>P0</code></a></h3>
<p>標準 DApp 分層：</p>
<pre><code class="language-text">Frontend -&gt; API/Backend -&gt; Wallet/Signer -&gt; RPC/Node -&gt; Smart Contract
                                     |
                                     +-&gt; Indexer/DB/Monitoring
</code></pre>
<p>一個生產級 DApp 的架構遠比上面的圖複雜。讓我們展開來看每一層的職責和選型考量：</p>
<pre><code class="language-text">┌─────────────────────────────────────────────────────┐
│                   Frontend Layer                     │
│  React/Next.js + wagmi/viem + WalletConnect          │
└───────────────────────┬─────────────────────────────┘
                        │ REST/GraphQL/WebSocket
┌───────────────────────┴─────────────────────────────┐
│                   Backend Layer                       │
│  ┌──────────┐  ┌──────────┐  ┌───────────────────┐  │
│  │ API 服務  │  │ 交易組裝  │  │ 風控引擎          │  │
│  │ Gateway   │  │ Tx Build  │  │ Rate Limit/ACL   │  │
│  └────┬─────┘  └────┬─────┘  └────────┬──────────┘  │
│       │              │                 │              │
│  ┌────┴──────────────┴─────────────────┴──────────┐  │
│  │              Message Queue (Kafka/NATS)         │  │
│  └────────────────────┬───────────────────────────┘  │
└───────────────────────┬─────────────────────────────┘
                        │
     ┌──────────────────┼──────────────────┐
     │                  │                  │
┌────┴─────┐   ┌───────┴──────┐   ┌──────┴───────┐
│ 自建節點  │   │ 第三方 RPC   │   │  Indexer     │
│ geth/op  │   │ Alchemy/Infura│   │ TheGraph/DB  │
└──────────┘   └──────────────┘   └──────────────┘
</code></pre>
<p>選型檢查：</p>
<ul>
<li>鏈：成本、最終性、開發工具、生態流動性</li>
<li>節點：自建 + 第三方雙路</li>
<li>索引：即時查詢與歷史分析分離</li>
<li>風控：交易模擬、限額、名單、告警</li>
</ul>
<p>節點選型是工程決策中最關鍵的環節之一。自建節點（如 geth、op-geth）給你完全控制權，但需要持續維護、同步、和監控。以 Ethereum 全節點為例，截至 2024 年，archive node 需要超過 15 TB 的 SSD 空間。第三方 RPC 服務（如 Alchemy、Infura、QuickNode）省去維護成本，但引入了外部依賴。最佳策略是雙路：業務關鍵路徑走自建節點，備援走第三方服務，兩者之間做健康檢查和自動切換。</p>
<p>索引層決定了你的查詢能力。鏈上資料是按區塊線性儲存的，要做「查某個地址的所有交易」這類查詢非常低效。Indexer 的工作是監聽鏈上事件，將資料轉換成適合查詢的格式存入資料庫。The Graph 提供了去中心化的索引方案，但很多團隊選擇自建索引服務，用 PostgreSQL + 事件監聽來實現。</p>
<h3 id="332-公鏈與聯盟鏈之爭-p1"><a class="header" href="#332-公鏈與聯盟鏈之爭-p1">3.3.2 公鏈與聯盟鏈之爭 <code>P1</code></a></h3>
<ul>
<li>公鏈：開放、抗審查、治理慢</li>
<li>聯盟鏈：可控、性能高、信任假設較集中</li>
</ul>
<p>決策原則：</p>
<ul>
<li>對外資產流通與可組合性 -&gt; 公鏈優先</li>
<li>企業內部多方協作與合規 -&gt; 聯盟鏈可行</li>
</ul>
<p>這不是一個二選一的問題，而是根據業務場景做出的工程決策。公鏈的核心價值是開放性和抗審查性——任何人都可以參與，沒有人可以單方面修改規則。這對於 DeFi、NFT 等需要全球流動性的場景是必需的。聯盟鏈（如 Hyperledger Fabric、FISCO BCOS）的價值在於可控性和合規性——參與節點身份已知，可以實現隱私保護和權限管理，適合銀行間結算、供應鏈金融等 B2B 場景。</p>
<p>從工程師的角度，兩者的技術棧差異不大。核心的密碼學、共識、P2P 概念是共通的。但具體到開發工具、部署流程、監控方式上有顯著不同。公鏈開發通常使用 Solidity + Hardhat/Foundry，部署到公開測試網再到主網；聯盟鏈開發可能使用 Go/Java 寫鏈碼（Chaincode），部署到組織自建的網路中。</p>
<h2 id="34-區塊鏈行業應用示例"><a class="header" href="#34-區塊鏈行業應用示例">3.4 區塊鏈行業應用示例</a></h2>
<h3 id="341-數字金融-p1"><a class="header" href="#341-數字金融-p1">3.4.1 數字金融 <code>P1</code></a></h3>
<ul>
<li>支付結算</li>
<li>借貸與抵押</li>
<li>資產代幣化</li>
</ul>
<p>數位金融是區塊鏈目前最成熟的應用領域。跨境支付是一個典型場景：傳統 SWIFT 轉帳需要 1-5 個工作天，中間經過多個代理銀行，每一層都收取手續費。使用穩定幣（如 USDC）在鏈上轉帳，可以在幾分鐘內完成結算，手續費低於 1 美元。Visa 已經開始在 Solana 和 Ethereum 上結算 USDC 支付。</p>
<p>資產代幣化（Real World Assets, RWA）是另一個快速增長的方向。把國債、房地產、藝術品等傳統資產代幣化，讓它們可以在鏈上自由交易和分割。BlackRock 的 BUIDL 基金就是一個將美國國債代幣化的產品，允許投資者以更低的門檻和更高的流動性投資國債。</p>
<h3 id="342-電子存證-p2"><a class="header" href="#342-電子存證-p2">3.4.2 電子存證 <code>P2</code></a></h3>
<ul>
<li>文件 hash 上鏈</li>
<li>時間戳與證據鏈</li>
</ul>
<p>電子存證是區塊鏈最簡單直接的應用之一。核心思路是：不需要把完整文件存上鏈（那樣太貴了），只需要把文件的 hash 存上鏈。當需要驗證時，重新計算文件的 hash，與鏈上記錄比對即可。因為區塊鏈的不可篡改性，這相當於在某個時間點對文件做了一次公證。</p>
<p>在中國，多個法院已經認可區塊鏈存證的法律效力。杭州互聯網法院在 2018 年首次採納了區塊鏈存證作為有效證據。技術實現上，通常會將文件 hash、時間戳、存證人資訊打包成一筆交易發送到鏈上，同時在鏈下保存完整文件和索引關係。</p>
<h3 id="343-食品安全-p2"><a class="header" href="#343-食品安全-p2">3.4.3 食品安全 <code>P2</code></a></h3>
<ul>
<li>供應鏈節點上傳批次資料</li>
<li>以不可篡改日誌提供追溯</li>
</ul>
<p>食品供應鏈追溯是聯盟鏈最典型的應用場景之一。Walmart 與 IBM 合作的 Food Trust 平台，將食品從農場到餐桌的每個環節記錄上鏈。當出現食品安全問題時，追溯時間從幾天縮短到幾秒。</p>
<pre><code class="language-text">食品供應鏈追溯流程：

┌──────┐   ┌──────┐   ┌──────┐   ┌──────┐   ┌──────┐
│ 農場 │──&gt;│ 加工 │──&gt;│ 物流 │──&gt;│ 倉儲 │──&gt;│ 零售 │
└──┬───┘   └──┬───┘   └──┬───┘   └──┬───┘   └──┬───┘
   │          │          │          │          │
   v          v          v          v          v
┌──────────────────────────────────────────────────┐
│              區塊鏈（不可篡改記錄）                │
│  batch-001: 種植日期, 農藥檢測, 加工溫度,         │
│             運輸溫度, 到店時間, ...                │
└──────────────────────────────────────────────────┘
</code></pre>
<p>技術挑戰在於「鏈上資料的可信度取決於鏈下資料的輸入品質」。區塊鏈能保證資料一旦寫入就不可篡改，但無法保證寫入的資料本身是真實的。這就是所謂的「garbage in, garbage out」問題。解決方案通常是結合 IoT 設備自動採集資料（如溫度感測器、GPS 追蹤），減少人為介入。</p>
<h2 id="實訓區塊鏈理論在線-demo-演示-p1"><a class="header" href="#實訓區塊鏈理論在線-demo-演示-p1">實訓：區塊鏈理論在線 demo 演示 <code>P1</code></a></h2>
<p>建議做一個最小 demo：</p>
<ol>
<li>上傳一段文字，計算 hash</li>
<li>模擬打包到區塊，生成前後鏈接</li>
<li>模擬 PoW 挖礦（低難度）</li>
<li>模擬 UTXO 交易與找零</li>
</ol>
<p>驗收點：</p>
<ul>
<li>任意改動歷史交易會讓後續區塊校驗失敗</li>
<li>UTXO 花費後不可再次花費</li>
</ul>
<p>以下是一個完整的 Go demo 骨架，涵蓋上述所有功能：</p>
<pre><code class="language-go">package main

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"math/big"
	"time"
)

// 簡化區塊結構
type Block struct {
	Timestamp    int64
	Data         []byte
	PrevHash     []byte
	Hash         []byte
	Nonce        int64
}

// 簡化區塊鏈
type Blockchain struct {
	Blocks []*Block
}

// 計算區塊 hash
func (b *Block) SetHash() {
	data := append(b.PrevHash, b.Data...)
	hash := sha256.Sum256(data)
	b.Hash = hash[:]
}

// 簡化 PoW（目標：hash 前 n bits 為 0）
func (b *Block) Mine(targetBits int) {
	target := big.NewInt(1)
	target.Lsh(target, uint(256-targetBits))

	for b.Nonce = 0; ; b.Nonce++ {
		data := append(b.PrevHash, b.Data...)
		data = append(data, IntToBytes(b.Nonce)...)
		hash := sha256.Sum256(data)

		var hashInt big.Int
		hashInt.SetBytes(hash[:])
		if hashInt.Cmp(target) == -1 {
			b.Hash = hash[:]
			break
		}
	}
}

// 驗證鏈完整性
func (bc *Blockchain) Validate() bool {
	for i := 1; i &lt; len(bc.Blocks); i++ {
		prev := bc.Blocks[i-1]
		curr := bc.Blocks[i]
		if !bytes.Equal(curr.PrevHash, prev.Hash) {
			fmt.Printf("Block %d: PrevHash mismatch!\n", i)
			return false
		}
	}
	return true
}
</code></pre>
<p>這個 demo 的重點不在於完整性，而在於讓學習者親手體驗幾個核心概念：改動一個區塊的資料後，重新計算 hash，會發現後續所有區塊的 PrevHash 都不匹配了。這就是區塊鏈「不可篡改」的直觀體驗。</p>
<h2 id="章節回顧與工程要點"><a class="header" href="#章節回顧與工程要點">章節回顧與工程要點</a></h2>
<p>這章覆蓋了區塊鏈開發者必須掌握的四個基礎支柱，每一個都對應著真實系統中的關鍵工程決策：</p>
<p><strong>hash 函數解決資料完整性</strong>。在實際開發中，你會在交易 ID 計算、區塊鏈接、Merkle Tree 構建、地址生成等幾乎所有環節用到 hash。掌握序列化的穩定性、欄位順序一致性、以及 endianness 問題，是避免「同樣的資料算出不同 hash」這類 bug 的關鍵。</p>
<p><strong>P2P 網路解決資料傳播</strong>。去中心化系統沒有中央伺服器來分發資料，必須依靠節點之間的 gossip protocol。理解節點發現、握手、訊息去重、速率限制這些機制，才能設計出既高效又抗攻擊的網路層。</p>
<p><strong>PoW/共識解決誰是正確歷史</strong>。共識機制是區塊鏈最核心的創新。PoW 用物理世界的能量消耗來換取數位世界的信任，而難度調整機制確保了系統在算力變化時仍能穩定運行。理解「機率最終性」和「確認數」的概念，對設計交易確認流程至關重要。</p>
<p><strong>UTXO 解決價值轉移與可追蹤</strong>。UTXO 模型和 Account 模型是兩種截然不同的狀態管理方式。UTXO 的並行驗證能力和可追溯性是它的核心優勢，但 coin selection 和找零管理增加了工程複雜度。</p>
<h2 id="白話總結-22"><a class="header" href="#白話總結-22">白話總結</a></h2>
<p>簡單來說，區塊鏈就是一群互不信任的人，靠著數學和密碼學達成共識的系統。hash 是整個系統的「指紋機」，讓你能用一小段固定長度的資料代表任意大小的東西，而且改一個字就會完全不同。P2P 網路讓每個節點都平等地傳播資料，不需要一個「總管」來分發。PoW 共識就像是用燒電來投票——你投入的算力越多，你的「話語權」越大，但驗證別人的投票結果只需要一秒鐘。UTXO 模型把你的餘額拆成一張一張的「鈔票」，每次交易就是收舊鈔、找零錢的過程。搞懂這四個東西，你就掌握了區塊鏈開發最底層的心智模型，後面不管是寫合約還是做錢包，都是在這個基礎上蓋房子。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第4章-go-語言區塊鏈初級應用開發"><a class="header" href="#第4章-go-語言區塊鏈初級應用開發">第4章 Go 語言區塊鏈初級應用開發</a></h1>
<p>本章目標是打通「寫合約 -&gt; 部署 -&gt; 用 Go 調用 -&gt; 簽名送交易 -&gt; 訂閱事件」完整路徑。</p>
<h2 id="41-智能合約開發"><a class="header" href="#41-智能合約開發">4.1 智能合約開發</a></h2>
<h3 id="411-合約開發環境搭建-p0"><a class="header" href="#411-合約開發環境搭建-p0">4.1.1 合約開發環境搭建 <code>P0</code></a></h3>
<p>建議工具鏈：</p>
<ul>
<li>編譯與測試：<code>Foundry</code> 或 <code>Hardhat</code></li>
<li>本地鏈：<code>anvil</code> 或 <code>hardhat node</code></li>
<li>Go SDK：<code>go-ethereum</code></li>
<li>錢包：測試私鑰/助記詞（僅測試用途）</li>
</ul>
<p>最小流程：</p>
<ol>
<li>建立專案與合約目錄</li>
<li>安裝 Solidity 編譯器</li>
<li>跑單元測試</li>
<li>部署到本地鏈並保存 ABI/Bytecode</li>
</ol>
<p>環境搭建是智能合約開發的第一步，也是很多新手花費最多時間除錯的環節。推薦使用 Foundry 作為主力工具鏈，原因很直接：它用 Rust 寫的，速度快；測試用 Solidity 寫，不需要切換語言；<code>forge test</code> 內建 fuzz testing 支援。Hardhat 則適合需要大量 JavaScript 插件生態的場景。</p>
<p>本地鏈的選擇直接影響開發效率。<code>anvil</code>（Foundry 內建）和 <code>hardhat node</code> 都提供即時出塊的本地 Ethereum 節點。兩者的關鍵差異在於：anvil 啟動更快、支持 fork 主網狀態（可以在本地測試與主網合約的互動），hardhat node 則有更豐富的 console.log 除錯能力。</p>
<pre><code class="language-text">開發環境架構：

┌─────────────────────────────────────────────────┐
│                 開發者工作站                       │
│                                                   │
│  ┌──────────┐   ┌──────────┐   ┌──────────────┐ │
│  │ Foundry  │   │ Go App   │   │ 測試私鑰     │ │
│  │ forge    │   │ go-ethereum│  │ (僅開發用)   │ │
│  │ cast     │   │ abigen   │   │              │ │
│  └────┬─────┘   └────┬─────┘   └──────────────┘ │
│       │              │                            │
│       v              v                            │
│  ┌────────────────────────────┐                  │
│  │    anvil (本地鏈)           │                  │
│  │    RPC: http://127.0.0.1:8545                 │
│  │    Chain ID: 31337          │                  │
│  └────────────────────────────┘                  │
└─────────────────────────────────────────────────┘
</code></pre>
<p>Go 與 Solidity 之間的橋樑是 <code>abigen</code>。它讀取合約的 ABI 和 Bytecode，自動生成類型安全的 Go binding。這比手動解析 ABI JSON 可靠得多。生成的 Go 程式碼包含所有合約函數和事件的型別定義，編譯期就能檢查參數類型是否正確。</p>
<pre><code class="language-bash"># 安裝 Foundry
curl -L https://foundry.paradigm.xyz | bash
foundryup

# 建立合約專案
forge init my-contract
cd my-contract

# 編譯合約
forge build

# 產生 Go binding
abigen --abi out/Counter.sol/Counter.abi.json \
       --bin out/Counter.sol/Counter.bin \
       --pkg counter \
       --out counter/counter.go
</code></pre>
<p>常見坑：</p>
<ul>
<li>Solidity 版本與 OpenZeppelin 套件版本不匹配</li>
<li>本地鏈 chain id 與簽名 chain id 不一致（anvil 預設 31337，hardhat 預設 31337）</li>
<li>abigen 版本與 go-ethereum 版本不一致，導致產生的程式碼無法編譯</li>
<li>忘記在 foundry.toml 設定 optimizer runs，導致部署 gas 過高</li>
</ul>
<h3 id="412-初識-solidity-p0"><a class="header" href="#412-初識-solidity-p0">4.1.2 初識 Solidity <code>P0</code></a></h3>
<p>關鍵語法：</p>
<ul>
<li><code>contract</code>、<code>state variable</code></li>
<li><code>constructor</code></li>
<li><code>function</code>（<code>view</code>/<code>pure</code>/<code>payable</code>）</li>
<li><code>event</code> 與 <code>emit</code></li>
</ul>
<pre><code class="language-solidity">pragma solidity ^0.8.24;

contract Counter {
    uint256 public value;
    event Increased(address indexed caller, uint256 newValue);

    function inc() external {
        value += 1;
        emit Increased(msg.sender, value);
    }
}
</code></pre>
<p>Solidity 是目前 EVM 生態系統的主流智能合約語言。它的語法看起來像 JavaScript 和 C++ 的混合體，但其執行環境與傳統程式語言截然不同。最關鍵的差異在於：每一行程式碼都有成本（gas），而且一旦部署就無法修改（除非用 proxy 模式）。這意味著合約程式碼的品質要求比一般後端程式碼高很多——bug 修復的代價是部署新合約並遷移所有狀態。</p>
<p><code>event</code> 是 Solidity 中非常重要但容易被忽略的特性。event 不儲存在合約狀態中，而是寫入交易的 log（收據）。這意味著它比 storage 便宜很多（大約是 storage 的 1/5 gas），而且可以被鏈下的 Go 程式透過 <code>SubscribeFilterLogs</code> 監聽。設計合約時，任何鏈下系統需要知道的狀態變更都應該 emit 對應的 event。</p>
<p><code>indexed</code> 關鍵字讓事件參數可以被過濾。例如上面的 <code>Increased</code> 事件中，<code>caller</code> 被標記為 <code>indexed</code>，這意味著你可以在 Go 端只監聽特定地址觸發的事件，而不是所有事件。每個事件最多可以有 3 個 indexed 參數。</p>
<pre><code class="language-solidity">// 更完整的合約範例：包含建構子、修飾符、事件
pragma solidity ^0.8.24;

contract SimpleBank {
    mapping(address =&gt; uint256) private balances;
    address public owner;

    event Deposited(address indexed account, uint256 amount);
    event Withdrawn(address indexed account, uint256 amount);

    constructor() {
        owner = msg.sender;
    }

    function deposit() external payable {
        require(msg.value &gt; 0, "must send ETH");
        balances[msg.sender] += msg.value;
        emit Deposited(msg.sender, msg.value);
    }

    function withdraw(uint256 amount) external {
        require(balances[msg.sender] &gt;= amount, "insufficient balance");
        balances[msg.sender] -= amount;
        // Checks-Effects-Interactions: 先改狀態，再轉帳
        (bool ok, ) = msg.sender.call{value: amount}("");
        require(ok, "transfer failed");
        emit Withdrawn(msg.sender, amount);
    }

    function balanceOf(address account) external view returns (uint256) {
        return balances[account];
    }
}
</code></pre>
<h3 id="413-智能合約有哪些數據類型-p0"><a class="header" href="#413-智能合約有哪些數據類型-p0">4.1.3 智能合約有哪些數據類型 <code>P0</code></a></h3>
<p>基礎型別：</p>
<ul>
<li><code>uint/int</code></li>
<li><code>bool</code></li>
<li><code>address</code></li>
<li><code>bytesN</code> / <code>bytes</code></li>
<li><code>string</code></li>
</ul>
<p>設計準則：</p>
<ul>
<li>能用 <code>uint256</code> 就先用 <code>uint256</code></li>
<li>需省 gas 才考慮 packing</li>
<li>會擴容的集合用 mapping + index</li>
</ul>
<p>Solidity 的型別系統表面上簡單，但隱藏了很多 gas 優化的細節。EVM 的原生字長是 256 bits，所有低於 256 bits 的型別（如 <code>uint8</code>、<code>uint128</code>）在運算時都需要額外的 masking 操作。這意味著單獨使用 <code>uint8</code> 反而比 <code>uint256</code> 更耗 gas。只有當多個小型別能被打包（packing）到同一個 32 bytes 的 storage slot 時，使用小型別才有意義。</p>
<pre><code class="language-solidity">// storage packing 範例
// 好的設計：3 個變數打包在同一個 slot (20 + 1 + 8 = 29 bytes &lt; 32 bytes)
contract GoodPacking {
    address public owner;      // 20 bytes
    bool public active;        // 1 byte
    uint64 public timestamp;   // 8 bytes
    // 以上共用一個 storage slot
}

// 壞的設計：每個變數各占一個 slot
contract BadPacking {
    address public owner;      // slot 0
    uint256 public value;      // slot 1 (打斷了 packing)
    bool public active;        // slot 2
    uint64 public timestamp;   // slot 3
}
</code></pre>
<p><code>address</code> 型別是 Solidity 特有的，代表 20 bytes 的 Ethereum 地址。在 Go 端對應 <code>common.Address</code>。<code>address payable</code> 是可以接收 ETH 的地址。兩者的區別在於 <code>address payable</code> 有 <code>.transfer()</code> 和 <code>.send()</code> 方法（不過現在推薦用 <code>.call{value: amount}("")</code>）。</p>
<p><code>mapping</code> 是 Solidity 中最常用的資料結構，它是一個 hash table，key 被 hash 後決定 storage 位置。需要注意的是：mapping 不支持遍歷（因為沒有儲存 key 列表），如果需要遍歷，必須額外維護一個 array 存放所有 key。</p>
<h3 id="414-什麼是內建對象-p1"><a class="header" href="#414-什麼是內建對象-p1">4.1.4 什麼是內建對象 <code>P1</code></a></h3>
<p>常見內建上下文：</p>
<ul>
<li><code>msg.sender</code>, <code>msg.value</code>, <code>msg.data</code></li>
<li><code>tx.origin</code>（通常不建議用於授權）</li>
<li><code>block.timestamp</code>, <code>block.number</code></li>
</ul>
<p>內建對象提供了交易和區塊的上下文資訊。<code>msg.sender</code> 是最常用的，代表直接呼叫此函數的地址。注意「直接」兩字：如果 User A 呼叫合約 B，合約 B 再呼叫合約 C，那麼在合約 C 中 <code>msg.sender</code> 是合約 B 的地址，而不是 User A。</p>
<p><code>tx.origin</code> 永遠是最初發起交易的 EOA（Externally Owned Account）。很多新手用 <code>tx.origin</code> 做權限檢查，這是一個嚴重的安全漏洞。攻擊者可以建立一個惡意合約，誘導 owner 呼叫，然後惡意合約再去呼叫目標合約。此時 <code>tx.origin</code> 是 owner，但 <code>msg.sender</code> 是惡意合約。</p>
<pre><code class="language-solidity">// 危險：使用 tx.origin 做權限檢查
contract Vulnerable {
    address public owner;
    function withdraw() external {
        require(tx.origin == owner); // 可被釣魚攻擊！
        payable(msg.sender).transfer(address(this).balance);
    }
}

// 安全：使用 msg.sender 做權限檢查
contract Safe {
    address public owner;
    function withdraw() external {
        require(msg.sender == owner); // 只允許 owner 直接呼叫
        payable(msg.sender).transfer(address(this).balance);
    }
}
</code></pre>
<p><code>block.timestamp</code> 是礦工/驗證者設定的區塊時間戳，有大約 12-15 秒的誤差範圍。不要用它做精確計時，但用於「24 小時鎖定期」這類粗粒度的時間控制是安全的。</p>
<h3 id="415-智能合約的函數-p0"><a class="header" href="#415-智能合約的函數-p0">4.1.5 智能合約的函數 <code>P0</code></a></h3>
<p>函數可見性：</p>
<ul>
<li><code>public</code>, <code>external</code>, <code>internal</code>, <code>private</code></li>
</ul>
<p>函數狀態修飾：</p>
<ul>
<li><code>view</code>: 不改狀態</li>
<li><code>pure</code>: 不讀不改狀態</li>
<li><code>payable</code>: 可收 ETH</li>
</ul>
<p>函數可見性是合約安全的第一道防線。<code>external</code> 和 <code>public</code> 的區別在於：<code>external</code> 函數的參數從 calldata 讀取（便宜），<code>public</code> 函數的參數從 memory 讀取（因為內部也可能呼叫）。如果一個函數只會被外部呼叫，用 <code>external</code> 更省 gas。</p>
<p><code>view</code> 和 <code>pure</code> 不只是標記，它們也影響呼叫方式。在 Go 端，呼叫 <code>view</code>/<code>pure</code> 函數時使用 <code>eth_call</code>，不需要發交易、不需要付 gas、不需要簽名。而呼叫非 view 函數需要發交易（<code>eth_sendRawTransaction</code>），需要 gas 和簽名。</p>
<pre><code class="language-solidity">contract FunctionExample {
    uint256 public value;

    // external: 只能從外部呼叫，calldata 傳參，最省 gas
    function setValue(uint256 _v) external {
        value = _v;
    }

    // public: 內外部都可呼叫
    function getValue() public view returns (uint256) {
        return value;
    }

    // internal: 只能本合約和繼承合約呼叫
    function _validate(uint256 _v) internal pure returns (bool) {
        return _v &gt; 0 &amp;&amp; _v &lt; 1000;
    }

    // private: 只有本合約能呼叫
    function _secret() private view returns (uint256) {
        return value * 2;
    }
}
</code></pre>
<p>工程建議：</p>
<ul>
<li>對外函數先做參數驗證</li>
<li>使用 custom error 降 gas（比 require string 省約 50% gas）</li>
<li>函數命名用動詞開頭（<code>deposit</code>, <code>withdraw</code>, <code>approve</code>）</li>
<li>internal/private 函數用底線前綴（<code>_validate</code>, <code>_transfer</code>）</li>
</ul>
<h3 id="416-函數修飾符-p0"><a class="header" href="#416-函數修飾符-p0">4.1.6 函數修飾符 <code>P0</code></a></h3>
<p>modifier 用來封裝前置檢查：</p>
<ul>
<li>權限檢查</li>
<li>狀態檢查</li>
<li>重入鎖</li>
</ul>
<pre><code class="language-solidity">modifier onlyOwner() {
    require(msg.sender == owner, "not owner");
    _;
}
</code></pre>
<p>modifier 是 Solidity 中非常強大的程式碼重用機制。<code>_;</code> 代表被修飾函數的本體——modifier 中 <code>_;</code> 之前的程式碼在函數執行前運行，之後的程式碼在函數執行後運行。這個設計讓「前置條件檢查」和「後置狀態驗證」可以被乾淨地封裝和重用。</p>
<p>重入鎖（reentrancy guard）是最重要的 modifier 之一。重入攻擊是 Solidity 最經典的安全漏洞，2016 年 DAO hack 就是因為重入漏洞導致 6000 萬美元被盜。OpenZeppelin 的 <code>ReentrancyGuard</code> 提供了標準實作，建議所有涉及 ETH 或 token 轉帳的函數都加上這個 modifier。</p>
<pre><code class="language-solidity">// 重入鎖的簡化實作
contract ReentrancyGuard {
    bool private _locked;

    modifier nonReentrant() {
        require(!_locked, "reentrant call");
        _locked = true;
        _;
        _locked = false;
    }
}

// 多重修飾符的組合使用
contract Vault is ReentrancyGuard {
    address public owner;
    mapping(address =&gt; uint256) public balances;

    modifier onlyOwner() {
        require(msg.sender == owner, "not owner");
        _;
    }

    modifier validAmount(uint256 amount) {
        require(amount &gt; 0, "amount must be positive");
        _;
    }

    // 修飾符按順序執行：先檢查 nonReentrant，再檢查 validAmount
    function withdraw(uint256 amount)
        external
        nonReentrant
        validAmount(amount)
    {
        require(balances[msg.sender] &gt;= amount, "insufficient");
        balances[msg.sender] -= amount;
        (bool ok, ) = msg.sender.call{value: amount}("");
        require(ok, "transfer failed");
    }
}
</code></pre>
<h3 id="417-巧用複合類型-p0"><a class="header" href="#417-巧用複合類型-p0">4.1.7 巧用複合類型 <code>P0</code></a></h3>
<p>重點：</p>
<ul>
<li><code>struct</code> 建模</li>
<li><code>mapping(address =&gt; User)</code> 儲存帳戶資料</li>
<li><code>array</code> 做可遍歷索引</li>
</ul>
<p>常見模式：</p>
<ul>
<li>mapping 存資料 + array 存 key</li>
<li>避免在鏈上做大型遍歷</li>
</ul>
<p>在智能合約中設計資料結構，必須時刻記住 gas 成本。鏈上儲存（SSTORE）是最昂貴的操作之一，寫入一個新的 storage slot 需要 20,000 gas，修改已有 slot 需要 5,000 gas。因此，資料結構的設計直接影響合約的可用性。</p>
<pre><code class="language-solidity">// EnumerableMapping 模式：mapping + array 的組合
contract UserRegistry {
    struct User {
        string name;
        uint256 balance;
        bool exists;
    }

    mapping(address =&gt; User) private users;
    address[] private userList;

    function register(string calldata name) external {
        require(!users[msg.sender].exists, "already registered");
        users[msg.sender] = User({
            name: name,
            balance: 0,
            exists: true
        });
        userList.push(msg.sender);
    }

    function getUser(address addr) external view returns (User memory) {
        require(users[addr].exists, "not found");
        return users[addr];
    }

    // 注意：遍歷 userList 的 gas 成本隨用戶數線性增長
    // 只適合管理員查詢或鏈下使用，不應在高頻函數中呼叫
    function getUserCount() external view returns (uint256) {
        return userList.length;
    }
}
</code></pre>
<p>最佳實踐：</p>
<ul>
<li>大型集合永遠不要在鏈上遍歷，改用 event + 鏈下索引</li>
<li>struct 中的布林值和小整數嘗試 packing</li>
<li>刪除 storage 時使用 <code>delete</code>，可以獲得 gas refund</li>
</ul>
<h3 id="418-斷言處理與自定義修飾符-p0"><a class="header" href="#418-斷言處理與自定義修飾符-p0">4.1.8 斷言處理與自定義修飾符 <code>P0</code></a></h3>
<p>錯誤處理：</p>
<ul>
<li><code>require</code>: 驗證外部輸入或條件</li>
<li><code>revert</code>: 主動回滾</li>
<li><code>assert</code>: 僅用於不變量</li>
</ul>
<pre><code class="language-solidity">error AmountTooSmall(uint256 min, uint256 got);

modifier minAmount(uint256 amount) {
    if (amount &lt; 1 ether) revert AmountTooSmall(1 ether, amount);
    _;
}
</code></pre>
<p>Custom error（自定義錯誤）是 Solidity 0.8.4 引入的特性，強烈建議使用。與 <code>require(condition, "error string")</code> 相比，custom error 有兩個顯著優勢：第一，gas 更低——error string 會完整儲存在 bytecode 中，而 custom error 只需要 4 bytes 的 selector；第二，可以攜帶結構化參數，讓鏈下程式更容易解析錯誤原因。</p>
<p>三種錯誤處理機制的使用場景非常明確：<code>require</code> 用於驗證外部輸入（「用戶給的參數對不對？」）、<code>revert</code> 用於流程中的主動中斷（「走到這一步發現條件不滿足」）、<code>assert</code> 用於不變量檢查（「這個條件如果不成立，代表有 bug」）。<code>assert</code> 失敗會消耗所有剩餘 gas，而 <code>require</code>/<code>revert</code> 會退還剩餘 gas。</p>
<pre><code class="language-solidity">// 完整的錯誤處理範例
error Unauthorized(address caller);
error InsufficientBalance(uint256 required, uint256 available);
error TransferFailed();

contract Treasury {
    address public owner;
    mapping(address =&gt; uint256) public balances;

    function withdraw(uint256 amount) external {
        // require: 驗證外部條件
        if (msg.sender != owner) revert Unauthorized(msg.sender);

        // require: 驗證餘額
        uint256 bal = balances[msg.sender];
        if (bal &lt; amount) revert InsufficientBalance(amount, bal);

        // 更新狀態
        balances[msg.sender] = bal - amount;

        // assert: 不變量——總餘額不應為負（理論上不可能，如果觸發說明有 bug）
        assert(balances[msg.sender] &lt;= bal);

        // 外部呼叫
        (bool ok, ) = msg.sender.call{value: amount}("");
        if (!ok) revert TransferFailed();
    }
}
</code></pre>
<p>在 Go 端解析 custom error：</p>
<pre><code class="language-go">// 解析合約 revert 的 custom error
func parseCustomError(abiObj abi.ABI, data []byte) (string, error) {
    for name, abiError := range abiObj.Errors {
        if bytes.Equal(data[:4], abiError.ID[:4]) {
            values, err := abiError.Inputs.Unpack(data[4:])
            if err != nil {
                return "", err
            }
            return fmt.Sprintf("%s: %v", name, values), nil
        }
    }
    return "", fmt.Errorf("unknown error selector: %x", data[:4])
}
</code></pre>
<h3 id="419-經典智能合約案例-p1"><a class="header" href="#419-經典智能合約案例-p1">4.1.9 經典智能合約案例 <code>P1</code></a></h3>
<p>建議三個練習案例：</p>
<ul>
<li>紅包合約：多收款人分配</li>
<li>銀行合約：存取款 + 日誌</li>
<li>拍賣合約：出價與結算</li>
</ul>
<p>這三個案例的設計意圖是覆蓋智能合約最常見的設計模式。紅包合約練習 ETH 分配與隨機性問題（鏈上隨機數是偽隨機的，可被礦工操控）。銀行合約練習 Checks-Effects-Interactions 模式和重入保護。拍賣合約練習時間鎖、退款模式（Pull over Push）、以及狀態機設計。</p>
<pre><code class="language-solidity">// 英式拍賣合約骨架
contract EnglishAuction {
    address public seller;
    uint256 public endTime;
    address public highestBidder;
    uint256 public highestBid;
    mapping(address =&gt; uint256) public pendingReturns;
    bool public ended;

    event NewBid(address indexed bidder, uint256 amount);
    event AuctionEnded(address winner, uint256 amount);

    constructor(uint256 _duration) {
        seller = msg.sender;
        endTime = block.timestamp + _duration;
    }

    function bid() external payable {
        require(block.timestamp &lt; endTime, "auction ended");
        require(msg.value &gt; highestBid, "bid too low");

        if (highestBidder != address(0)) {
            // Pull over Push: 不直接退款，讓用戶自己來提
            pendingReturns[highestBidder] += highestBid;
        }
        highestBidder = msg.sender;
        highestBid = msg.value;
        emit NewBid(msg.sender, msg.value);
    }

    // Pull 模式：用戶主動提款
    function withdrawPending() external {
        uint256 amount = pendingReturns[msg.sender];
        require(amount &gt; 0, "nothing to withdraw");
        pendingReturns[msg.sender] = 0;
        (bool ok, ) = msg.sender.call{value: amount}("");
        require(ok, "transfer failed");
    }

    function endAuction() external {
        require(block.timestamp &gt;= endTime, "not yet");
        require(!ended, "already ended");
        ended = true;
        emit AuctionEnded(highestBidder, highestBid);
        (bool ok, ) = seller.call{value: highestBid}("");
        require(ok, "transfer failed");
    }
}
</code></pre>
<p>Pull over Push 是這個案例中最重要的模式。如果在 <code>bid()</code> 函數中直接把 ETH 退還給前一個出價者（Push 模式），惡意合約可以讓退款失敗（例如在 <code>receive()</code> 函數中 revert），從而阻塞整個拍賣。Pull 模式讓每個人自己來提款，一個人的失敗不會影響其他人。</p>
<h3 id="4110-智能合約開發技巧-p0"><a class="header" href="#4110-智能合約開發技巧-p0">4.1.10 智能合約開發技巧 <code>P0</code></a></h3>
<p>高頻最佳實務：</p>
<ul>
<li>Checks-Effects-Interactions</li>
<li>Pull over Push（提款模式）</li>
<li>權限最小化</li>
<li>重要參數上鏈事件紀錄</li>
<li>導入 fuzz/invariant 測試</li>
</ul>
<p>Checks-Effects-Interactions（CEI）是智能合約安全的黃金法則。順序是：先檢查條件（Checks），再修改狀態（Effects），最後做外部呼叫（Interactions）。這個順序確保了即使外部呼叫觸發了重入，合約狀態已經更新了，重入時的條件檢查會失敗。</p>
<pre><code class="language-text">Checks-Effects-Interactions 模式：

┌──────────┐     ┌──────────┐     ┌───────────────┐
│ Checks   │────&gt;│ Effects  │────&gt;│ Interactions  │
│          │     │          │     │               │
│ - 權限   │     │ - 改餘額  │     │ - 轉 ETH     │
│ - 餘額   │     │ - 改狀態  │     │ - 呼叫合約    │
│ - 參數   │     │ - emit   │     │ - 外部呼叫    │
└──────────┘     └──────────┘     └───────────────┘

⚠️ 如果順序錯誤（先 Interactions 再 Effects），重入攻擊可以在
   狀態未更新前重複呼叫函數，導致資金被多次提取。
</code></pre>
<p>Fuzz testing 是智能合約測試的殺手鐧。Foundry 的 <code>forge test</code> 內建支持 fuzz testing——只要函數參數沒有被固定，forge 會自動生成隨機輸入來測試。Invariant testing 則更進一步，讓 fuzzer 隨機呼叫合約的不同函數，檢查是否有任何調用序列能破壞合約的不變量（如「總供應量不變」、「餘額非負」）。</p>
<pre><code class="language-solidity">// Foundry fuzz test 範例
contract BankTest is Test {
    SimpleBank bank;

    function setUp() public {
        bank = new SimpleBank();
    }

    // forge 會自動用隨機 amount 測試這個函數
    function testFuzz_DepositWithdraw(uint256 amount) public {
        vm.assume(amount &gt; 0 &amp;&amp; amount &lt; 100 ether);
        vm.deal(address(this), amount);

        bank.deposit{value: amount}();
        assertEq(bank.balanceOf(address(this)), amount);

        bank.withdraw(amount);
        assertEq(bank.balanceOf(address(this)), 0);
    }
}
</code></pre>
<h2 id="42-go-語言與智能合約調用"><a class="header" href="#42-go-語言與智能合約調用">4.2 Go 語言與智能合約調用</a></h2>
<h3 id="421-合約函數如何被調用-p0"><a class="header" href="#421-合約函數如何被調用-p0">4.2.1 合約函數如何被調用 <code>P0</code></a></h3>
<p>兩類呼叫：</p>
<ul>
<li><code>eth_call</code>：讀取，不上鏈</li>
<li><code>eth_sendRawTransaction</code>：寫入，上鏈</li>
</ul>
<p>Go 典型路徑：</p>
<ol>
<li>載入 ABI</li>
<li>打包 calldata</li>
<li>建交易</li>
<li>簽名</li>
<li>廣播</li>
</ol>
<p>理解 <code>eth_call</code> 和 <code>eth_sendRawTransaction</code> 的差異是 Go 區塊鏈開發的基礎。<code>eth_call</code> 是一個本地模擬執行——節點在本地的 EVM 上跑你的呼叫，回傳結果，不消耗 gas，不寫入區塊鏈。<code>eth_sendRawTransaction</code> 則是把簽好名的交易送進交易池（mempool），等待被打包到區塊中。</p>
<pre><code class="language-text">兩種呼叫方式對比：

eth_call（讀取）：                    eth_sendRawTransaction（寫入）：

┌────────┐   calldata    ┌──────┐   ┌────────┐  signed tx   ┌──────┐
│ Go App │ ────────────&gt; │ Node │   │ Go App │ ───────────&gt; │ Node │
└────────┘               └──┬───┘   └────────┘              └──┬───┘
                            │                                   │
                         本地模擬                            進入 mempool
                            │                                   │
                         回傳結果                            等待打包
                      （即時、免費）                       （異步、付 gas）
                                                               │
                                                          寫入區塊
                                                               │
                                                          回傳 receipt
</code></pre>
<p>在 Go 端，如果你用 <code>abigen</code> 生成了 Go binding，這兩種呼叫模式被自動封裝了。但理解底層機制仍然重要，特別是在需要手動組裝 calldata 或處理邊界情況時。</p>
<h3 id="422-智能合約被調用的基本步驟-p0"><a class="header" href="#422-智能合約被調用的基本步驟-p0">4.2.2 智能合約被調用的基本步驟 <code>P0</code></a></h3>
<pre><code class="language-text">Load ABI -&gt; Pack method args -&gt; Build tx -&gt; Sign tx -&gt; Send tx -&gt; Wait receipt
</code></pre>
<p>Go 實作骨架：</p>
<pre><code class="language-go">client, _ := ethclient.Dial(rpcURL)
nonce, _ := client.PendingNonceAt(ctx, from)
gasPrice, _ := client.SuggestGasPrice(ctx)

input, _ := abiObj.Pack("transfer", to, amount)
tx := types.NewTransaction(nonce, contractAddr, big.NewInt(0), gasLimit, gasPrice, input)

signedTx, _ := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
_ = client.SendTransaction(ctx, signedTx)
</code></pre>
<p>讓我們逐步拆解每一行的意義。<code>PendingNonceAt</code> 查詢帳戶的下一個可用 nonce（包含 pending 狀態的交易）。nonce 是帳戶的交易計數器，必須嚴格遞增。如果你同時送出兩筆交易，nonce 必須分別是 N 和 N+1，否則第二筆會被拒絕。</p>
<p><code>SuggestGasPrice</code> 向節點查詢當前建議的 gas price。在 EIP-1559 之後，更推薦使用 <code>SuggestGasTipCap</code> 和 <code>baseFee</code> 來構建 EIP-1559 交易，它們的費用估算更精確。</p>
<pre><code class="language-go">// 完整的 EIP-1559 交易發送流程
func sendContractTx(ctx context.Context, client *ethclient.Client,
    privateKey *ecdsa.PrivateKey, contractAddr common.Address,
    abiObj abi.ABI, method string, args ...interface{}) (*types.Receipt, error) {

    from := crypto.PubkeyToAddress(privateKey.PublicKey)

    // 1. 取得 nonce
    nonce, err := client.PendingNonceAt(ctx, from)
    if err != nil {
        return nil, fmt.Errorf("get nonce: %w", err)
    }

    // 2. 打包 calldata
    input, err := abiObj.Pack(method, args...)
    if err != nil {
        return nil, fmt.Errorf("pack args: %w", err)
    }

    // 3. 估算 gas
    gasLimit, err := client.EstimateGas(ctx, ethereum.CallMsg{
        From: from, To: &amp;contractAddr, Data: input,
    })
    if err != nil {
        return nil, fmt.Errorf("estimate gas: %w", err)
    }

    // 4. 建立 EIP-1559 交易
    chainID, _ := client.ChainID(ctx)
    tipCap, _ := client.SuggestGasTipCap(ctx)
    head, _ := client.HeaderByNumber(ctx, nil)
    feeCap := new(big.Int).Add(
        tipCap,
        new(big.Int).Mul(head.BaseFee, big.NewInt(2)),
    )

    tx := types.NewTx(&amp;types.DynamicFeeTx{
        ChainID:   chainID,
        Nonce:     nonce,
        GasTipCap: tipCap,
        GasFeeCap: feeCap,
        Gas:       gasLimit,
        To:        &amp;contractAddr,
        Data:      input,
    })

    // 5. 簽名
    signer := types.LatestSignerForChainID(chainID)
    signedTx, err := types.SignTx(tx, signer, privateKey)
    if err != nil {
        return nil, fmt.Errorf("sign tx: %w", err)
    }

    // 6. 廣播
    if err := client.SendTransaction(ctx, signedTx); err != nil {
        return nil, fmt.Errorf("send tx: %w", err)
    }

    // 7. 等待 receipt
    receipt, err := bind.WaitMined(ctx, client, signedTx)
    if err != nil {
        return nil, fmt.Errorf("wait mined: %w", err)
    }

    if receipt.Status != types.ReceiptStatusSuccessful {
        return receipt, fmt.Errorf("tx reverted: %s", signedTx.Hash().Hex())
    }

    return receipt, nil
}
</code></pre>
<p>常見坑：</p>
<ul>
<li><code>EstimateGas</code> 回傳的是最低值，實務上建議乘 1.2-1.5 的安全係數</li>
<li><code>bind.WaitMined</code> 會阻塞直到交易被打包，對於批量發送場景需要改用異步模式</li>
</ul>
<h3 id="423-調用合約時如何簽名-p0"><a class="header" href="#423-調用合約時如何簽名-p0">4.2.3 調用合約時如何簽名 <code>P0</code></a></h3>
<p>簽名關鍵：</p>
<ul>
<li>交易欄位完整（nonce, gas, to, data, chain id）</li>
<li>選對 signer（EIP-155 / 1559）</li>
<li>私鑰僅在簽名端使用</li>
</ul>
<p>簽名是整個交易流程中安全要求最高的環節。私鑰永遠不應該離開簽名環境——不應該出現在 log 中、不應該透過網路傳輸、不應該存在非加密的儲存中。在生產環境，簽名通常在 HSM（Hardware Security Module）或 KMS（Key Management Service）中完成。</p>
<p>EIP-155 引入了 chain id 保護，防止一條鏈上的交易被在另一條鏈上重放。例如，一筆 Ethereum mainnet（chain id = 1）的交易如果被廣播到 Polygon（chain id = 137），簽名驗證會失敗，因為 chain id 是簽名的一部分。</p>
<pre><code class="language-go">// 選擇正確的 signer
// Legacy 交易（EIP-155）
signer155 := types.NewEIP155Signer(chainID)

// EIP-1559 交易
signerLatest := types.LatestSignerForChainID(chainID)

// 最佳實踐：永遠用 LatestSignerForChainID，它會自動選擇正確的 signer
signedTx, err := types.SignTx(tx, types.LatestSignerForChainID(chainID), privateKey)
</code></pre>
<p>常見坑：</p>
<ul>
<li><code>invalid sender</code> 多半是 chain id 或 signer 類型錯</li>
<li>nonce 重複導致交易取代或失敗</li>
<li>在 Go 中用 <code>crypto.HexToECDSA</code> 載入私鑰時，不要帶 <code>0x</code> 前綴</li>
<li><code>bind.NewKeyedTransactorWithChainID</code> 是更方便的封裝，但要注意它會快取 nonce</li>
</ul>
<h3 id="424-如何訂閱合約的-event-p0"><a class="header" href="#424-如何訂閱合約的-event-p0">4.2.4 如何訂閱合約的 event <code>P0</code></a></h3>
<p>事件訂閱用途：</p>
<ul>
<li>業務狀態同步</li>
<li>錯誤與風控告警</li>
<li>對帳</li>
</ul>
<p>Go 訂閱骨架：</p>
<pre><code class="language-go">query := ethereum.FilterQuery{Addresses: []common.Address{contractAddr}}
logs := make(chan types.Log)
sub, _ := client.SubscribeFilterLogs(ctx, query, logs)

for {
    select {
    case err := &lt;-sub.Err():
        _ = err
    case vLog := &lt;-logs:
        _ = vLog // decode event
    }
}
</code></pre>
<p>事件訂閱是 DApp 後端最核心的功能之一。鏈上合約的狀態變更透過 event 通知鏈下系統，這是 DApp 實現「響應式」的關鍵機制。例如，一個交易所的充值流程：用戶將 token 轉入充值地址 -&gt; 合約 emit Transfer 事件 -&gt; 後端監聽到事件 -&gt; 更新用戶餘額。</p>
<p><code>SubscribeFilterLogs</code> 使用 WebSocket 連線，能即時接收新事件。但 WebSocket 連線不穩定——網路波動、節點重啟、連線超時都會導致斷線。生產系統必須實作健全的重連機制和歷史事件回補。</p>
<pre><code class="language-go">// 生產級事件監聽器骨架
func watchEvents(ctx context.Context, client *ethclient.Client,
    contractAddr common.Address, startBlock uint64) error {

    for {
        // 1. 先回補從 startBlock 到最新的歷史事件
        currentBlock, err := client.BlockNumber(ctx)
        if err != nil {
            time.Sleep(5 * time.Second)
            continue
        }

        if startBlock &lt; currentBlock {
            query := ethereum.FilterQuery{
                FromBlock: new(big.Int).SetUint64(startBlock),
                ToBlock:   new(big.Int).SetUint64(currentBlock),
                Addresses: []common.Address{contractAddr},
            }
            logs, err := client.FilterLogs(ctx, query)
            if err != nil {
                time.Sleep(5 * time.Second)
                continue
            }
            for _, vLog := range logs {
                processLog(vLog)
            }
            startBlock = currentBlock + 1
        }

        // 2. 訂閱新事件
        logCh := make(chan types.Log)
        sub, err := client.SubscribeFilterLogs(ctx, ethereum.FilterQuery{
            Addresses: []common.Address{contractAddr},
        }, logCh)
        if err != nil {
            time.Sleep(5 * time.Second)
            continue
        }

        // 3. 處理新事件，斷線時跳回外層重連
        func() {
            defer sub.Unsubscribe()
            for {
                select {
                case err := &lt;-sub.Err():
                    log.Printf("subscription error: %v, reconnecting...", err)
                    return
                case vLog := &lt;-logCh:
                    processLog(vLog)
                    startBlock = vLog.BlockNumber + 1
                }
            }
        }()
    }
}
</code></pre>
<p>常見坑：</p>
<ul>
<li>websocket 斷線沒重連</li>
<li>只訂閱新事件，漏補歷史區塊</li>
<li>處理 event 時沒有考慮 chain reorganization（被 reorg 的區塊中的 event 需要回滾）</li>
<li><code>FilterLogs</code> 一次查詢的區塊範圍太大，導致節點返回錯誤或超時（建議每次最多查 2000 blocks）</li>
<li>沒有持久化 <code>startBlock</code>，重啟後從頭開始掃描</li>
</ul>
<h2 id="實訓編寫一個銀行合約-p0"><a class="header" href="#實訓編寫一個銀行合約-p0">實訓：編寫一個銀行合約 <code>P0</code></a></h2>
<p>功能要求：</p>
<ul>
<li><code>deposit()</code></li>
<li><code>withdraw(amount)</code></li>
<li><code>balanceOf(user)</code></li>
<li><code>event Deposited/Withdrawn</code></li>
</ul>
<p>工程要求：</p>
<ul>
<li>withdraw 使用重入保護</li>
<li>超額提款需回滾</li>
<li>Go 客戶端可完成存取款與事件監聽</li>
</ul>
<p>驗收清單：</p>
<ul>
<li>合約單元測試通過</li>
<li>Go 調用成功並拿到 receipt</li>
<li>event 可被訂閱並解析</li>
</ul>
<p>以下是完整的端到端實作思路：</p>
<pre><code class="language-text">端到端開發流程：

1. 合約開發                2. Go Binding 生成        3. Go 客戶端
┌────────────────┐        ┌──────────────────┐      ┌──────────────────┐
│ Bank.sol       │        │ abigen           │      │ main.go          │
│ BankTest.t.sol │ ─────&gt; │ ABI + Bytecode   │ ──&gt;  │ Deploy           │
│                │  forge  │ -&gt; bank.go       │      │ Deposit          │
│                │  build  │                  │      │ Withdraw         │
└────────────────┘        └──────────────────┘      │ WatchEvents      │
                                                     └──────────────────┘
</code></pre>
<pre><code class="language-go">// Go 客戶端使用 abigen 生成的 binding
func main() {
    client, _ := ethclient.Dial("ws://127.0.0.1:8545")
    privateKey, _ := crypto.HexToECDSA("ac0974bec...")
    auth, _ := bind.NewKeyedTransactorWithChainID(privateKey, big.NewInt(31337))

    // 部署合約
    addr, tx, bank, _ := DeployBank(auth, client)
    bind.WaitDeployed(context.Background(), client, tx)
    fmt.Printf("Bank deployed at: %s\n", addr.Hex())

    // 存款 1 ETH
    auth.Value = big.NewInt(1e18) // 1 ETH in wei
    tx, _ = bank.Deposit(auth)
    receipt, _ := bind.WaitMined(context.Background(), client, tx)
    fmt.Printf("Deposit receipt status: %d\n", receipt.Status)
    auth.Value = big.NewInt(0) // reset value

    // 查餘額
    bal, _ := bank.BalanceOf(nil, auth.From)
    fmt.Printf("Balance: %s wei\n", bal.String())

    // 監聽事件
    go func() {
        depositCh := make(chan *BankDeposited)
        sub, _ := bank.WatchDeposited(nil, depositCh, nil)
        defer sub.Unsubscribe()
        for event := range depositCh {
            fmt.Printf("Deposit event: %s deposited %s\n",
                event.Account.Hex(), event.Amount.String())
        }
    }()
}
</code></pre>
<h2 id="章節回顧與工程要點-1"><a class="header" href="#章節回顧與工程要點-1">章節回顧與工程要點</a></h2>
<p>本章完成了從合約開發到 Go 調用的完整鏈路。以下是每個環節的關鍵工程決策和需要牢記的原則：</p>
<p><strong>Solidity 開發基礎</strong>：合約程式碼的品質要求遠高於一般後端程式碼，因為部署後無法修改。CEI 模式、重入保護、custom error、event 設計是四個最重要的基礎技能。永遠先寫測試再寫實作，Foundry 的 fuzz testing 是你最好的朋友。</p>
<p><strong>Go 調用合約完整鏈路</strong>：<code>abigen</code> 是 Go 與 Solidity 之間的橋樑，自動生成類型安全的 binding。理解 <code>eth_call</code>（讀取、免費、同步）和 <code>eth_sendRawTransaction</code>（寫入、付 gas、異步）的區別是基礎中的基礎。</p>
<p><strong>交易簽名</strong>：私鑰永不出簽名邊界。永遠使用 <code>LatestSignerForChainID</code> 確保選對 signer。nonce 管理是高並發場景的核心挑戰。</p>
<p><strong>事件訂閱</strong>：生產系統必須有重連機制和歷史回補邏輯。永遠持久化處理進度（最後處理的 block number），確保服務重啟後不丟事件。</p>
<h2 id="白話總結-23"><a class="header" href="#白話總結-23">白話總結</a></h2>
<p>這章教你怎麼從零開始跟智能合約互動。首先你得會寫 Solidity 合約——它就像是部署在區塊鏈上的微服務，一旦上線就不能改了，所以品質要求很高。然後你得學會用 Go 去呼叫這些合約，這裡面最關鍵的是搞清楚「讀」和「寫」的區別：讀是免費的、即時的，寫要付 gas、要簽名、要等確認。簽名是整個流程中最敏感的環節，私鑰就像你家的鑰匙，絕對不能讓它出現在不該出現的地方。事件訂閱就像是合約的「通知系統」，讓你的後端能即時知道鏈上發生了什麼事。最容易踩的坑是 WebSocket 斷線沒重連、歷史事件沒回補、nonce 管理混亂。把這些搞定，你就能做出一個能跟鏈上合約完整互動的 Go 後端了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第5章-go-語言區塊鏈高級應用開發"><a class="header" href="#第5章-go-語言區塊鏈高級應用開發">第5章 Go 語言區塊鏈高級應用開發</a></h1>
<p>本章以「做出一條可跑的簡化區塊鏈」為目標，重點在資料結構與交易流程是否自洽。</p>
<h2 id="51-go-語言與區塊鏈開發準備"><a class="header" href="#51-go-語言與區塊鏈開發準備">5.1 Go 語言與區塊鏈開發準備</a></h2>
<h3 id="511-go-語言與-hash-函數-p0"><a class="header" href="#511-go-語言與-hash-函數-p0">5.1.1 Go 語言與 hash 函數 <code>P0</code></a></h3>
<p>常用組件：</p>
<ul>
<li><code>crypto/sha256</code></li>
<li><code>encoding/hex</code></li>
<li><code>bytes</code></li>
</ul>
<p>設計原則：</p>
<ul>
<li>區塊、交易都要有穩定序列化</li>
<li>hash 結果用 <code>[]byte</code> 儲存，顯示時才轉 hex</li>
</ul>
<p>在建造自己的區塊鏈之前，必須把 hash 函數的使用方式釘死。不同於第三章的概念介紹，這裡要解決的是工程實作中「如何確保 hash 在所有節點上計算結果一致」的問題。這個問題看似簡單，但在實務中是 bug 最多的地方之一。</p>
<p>hash 一致性的關鍵在於序列化。同一個 <code>Block</code> struct，如果序列化方式不一致，hash 結果就不同。Go 的 <code>encoding/json</code> 在不同版本中可能改變 key 排列順序（雖然實際上它按字母序排列），更危險的是浮點數的序列化——<code>1.0</code> 和 <code>1</code> 在 JSON 中可能被不同實作處理成不同字串。因此，區塊鏈中永遠不要用 JSON 做 hash 前的序列化，而要用 binary encoding。</p>
<pre><code class="language-go">package main

import (
	"bytes"
	"crypto/sha256"
	"encoding/binary"
	"encoding/hex"
	"fmt"
)

// 穩定序列化：用 binary encoding 確保跨平台一致
func IntToBytes(n int64) []byte {
	buf := new(bytes.Buffer)
	_ = binary.Write(buf, binary.BigEndian, n)
	return buf.Bytes()
}

// 計算區塊 header hash
func CalcBlockHash(prevHash, merkleRoot []byte, timestamp, nonce int64) []byte {
	data := bytes.Join([][]byte{
		prevHash,
		merkleRoot,
		IntToBytes(timestamp),
		IntToBytes(nonce),
	}, []byte{})

	hash := sha256.Sum256(data)
	return hash[:]
}

// 雙重 hash（Bitcoin 風格）
func DoubleHash(data []byte) []byte {
	first := sha256.Sum256(data)
	second := sha256.Sum256(first[:])
	return second[:]
}

func main() {
	hash := CalcBlockHash(
		[]byte{0x00}, // prevHash (genesis)
		[]byte("merkle-root"),
		1700000000,
		42,
	)
	fmt.Println(hex.EncodeToString(hash))
}
</code></pre>
<p>最佳實踐：</p>
<ul>
<li>所有整數使用 <code>binary.BigEndian</code> 序列化</li>
<li>hash 結果在記憶體中用 <code>[]byte</code> 傳遞，只在顯示給人看時轉 <code>hex.EncodeToString</code></li>
<li>為每個需要 hash 的結構體寫一個 <code>Serialize()</code> 方法，並用 regression test 鎖定</li>
</ul>
<p>常見坑：</p>
<ul>
<li>用 <code>fmt.Sprintf("%v", block)</code> 做序列化——Go struct 的 print 格式不穩定</li>
<li>忘記 <code>sha256.Sum256</code> 回傳的是 <code>[32]byte</code> 而不是 <code>[]byte</code>，需要用 <code>hash[:]</code> 轉換</li>
<li>不同節點的系統時鐘不同步，如果把 <code>time.Now()</code> 直接放進 hash，可能導致不同節點算出不同的 hash</li>
</ul>
<h3 id="512-go-語言與-base58-編碼-p0"><a class="header" href="#512-go-語言與-base58-編碼-p0">5.1.2 Go 語言與 Base58 編碼 <code>P0</code></a></h3>
<p>Base58 用於人類可讀地址，避免 <code>0/O/I/l</code> 混淆。</p>
<p>典型地址流程：</p>
<ol>
<li>公鑰 hash（<code>SHA256 + RIPEMD160</code>）</li>
<li>加版本前綴</li>
<li>加 checksum</li>
<li>Base58 編碼</li>
</ol>
<p>Base58 是 Bitcoin 專門設計的編碼格式。相比 Base64，Base58 去掉了 <code>0</code>、<code>O</code>、<code>I</code>、<code>l</code>、<code>+</code>、<code>/</code> 這六個容易混淆或在 URL 中有特殊意義的字元。結果是：地址可以被安全地複製貼上、口頭朗讀、列印在紙上，降低了人為出錯的機率。</p>
<p>Checksum 是地址安全的最後一道防線。Bitcoin 地址的 checksum 是對 <code>version + payload</code> 做兩次 SHA256，取前 4 bytes 附加在末尾。當用戶輸入一個地址時，程式可以重新計算 checksum 並比對，如果不匹配就說明地址被輸入錯了。這個機制的錯誤檢測率超過 99.99%。</p>
<pre><code class="language-text">地址生成完整流程：

Public Key (65 bytes, uncompressed)
    │
    v
SHA256 ──&gt; RIPEMD160 ──&gt; PubKeyHash (20 bytes)
    │
    v
Version Byte (0x00 for mainnet) + PubKeyHash
    │
    v
Double SHA256 ──&gt; 取前 4 bytes ──&gt; Checksum
    │
    v
Version + PubKeyHash + Checksum
    │
    v
Base58Encode ──&gt; Bitcoin Address (如: 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa)
</code></pre>
<pre><code class="language-go">// Base58 編碼實作
var b58Alphabet = []byte("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")

func Base58Encode(input []byte) []byte {
	var result []byte
	x := new(big.Int).SetBytes(input)
	base := big.NewInt(58)
	zero := big.NewInt(0)
	mod := new(big.Int)

	for x.Cmp(zero) != 0 {
		x.DivMod(x, base, mod)
		result = append(result, b58Alphabet[mod.Int64()])
	}

	// 反轉
	for i, j := 0, len(result)-1; i &lt; j; i, j = i+1, j-1 {
		result[i], result[j] = result[j], result[i]
	}

	// 處理前導零（對應 Base58 的 '1'）
	for _, b := range input {
		if b != 0x00 {
			break
		}
		result = append([]byte{b58Alphabet[0]}, result...)
	}

	return result
}

// 生成帶 checksum 的地址
func GenerateAddress(pubKeyHash []byte, version byte) []byte {
	versionedPayload := append([]byte{version}, pubKeyHash...)
	checksum := Checksum(versionedPayload)
	fullPayload := append(versionedPayload, checksum...)
	return Base58Encode(fullPayload)
}

func Checksum(payload []byte) []byte {
	first := sha256.Sum256(payload)
	second := sha256.Sum256(first[:])
	return second[:4] // 只取前 4 bytes
}
</code></pre>
<p>常見坑：</p>
<ul>
<li>前導零的處理很容易出錯——在 Base58 中，0x00 對應 '1'，必須特別處理</li>
<li>混淆 Base58 和 Base58Check——後者包含 version byte 和 checksum</li>
<li>使用第三方 Base58 庫時沒有驗證其處理前導零的行為</li>
</ul>
<h3 id="513-go-語言與默克爾樹-p0"><a class="header" href="#513-go-語言與默克爾樹-p0">5.1.3 Go 語言與默克爾樹 <code>P0</code></a></h3>
<p>Merkle Tree 用於交易集合摘要：</p>
<ul>
<li>葉節點：交易 hash</li>
<li>父節點：<code>hash(left || right)</code></li>
<li>根節點：區塊 header 的 <code>MerkleRoot</code></li>
</ul>
<p>Merkle Tree 是區塊鏈中驗證資料完整性的核心資料結構。它的精妙之處在於：你不需要下載所有交易就能驗證某筆交易是否包含在區塊中。只需要提供一條從葉節點到根節點的「證明路徑」（Merkle Proof），大小是 O(log n)，就能完成驗證。Bitcoin 的 SPV（Simplified Payment Verification）輕節點正是基於這個原理運作的。</p>
<pre><code class="language-text">Merkle Tree 結構：

              Root Hash
            /          \
        Hash01          Hash23
       /      \        /      \
    Hash0    Hash1   Hash2    Hash3
      |        |       |        |
    Tx0      Tx1     Tx2      Tx3

驗證 Tx1 是否在樹中，只需要：
  - Tx1 本身
  - Hash0（兄弟節點）
  - Hash23（叔父節點）

路徑：hash(Tx1) -&gt; hash(Hash0 || Hash1) -&gt; hash(Hash01 || Hash23) == Root?
大小：O(log n) 而非 O(n)
</code></pre>
<p>對於輕錢包（如手機端），Merkle Proof 的價值巨大。一個包含 4000 筆交易的區塊，完整下載需要幾百 KB，但 Merkle Proof 只需要 12 個 hash（每個 32 bytes），總共 384 bytes 就能驗證任意一筆交易的存在性。</p>
<pre><code class="language-go">// Merkle Tree 實作
type MerkleTree struct {
	RootNode *MerkleNode
}

type MerkleNode struct {
	Left  *MerkleNode
	Right *MerkleNode
	Data  []byte
}

func NewMerkleNode(left, right *MerkleNode, data []byte) *MerkleNode {
	node := &amp;MerkleNode{}

	if left == nil &amp;&amp; right == nil {
		// 葉節點：直接 hash 交易資料
		hash := sha256.Sum256(data)
		node.Data = hash[:]
	} else {
		// 內部節點：hash(left || right)
		prevHashes := append(left.Data, right.Data...)
		hash := sha256.Sum256(prevHashes)
		node.Data = hash[:]
	}

	node.Left = left
	node.Right = right
	return node
}

func NewMerkleTree(data [][]byte) *MerkleTree {
	if len(data) == 0 {
		return &amp;MerkleTree{}
	}

	var nodes []*MerkleNode

	// 奇數個葉節點時，複製最後一個
	if len(data)%2 != 0 {
		data = append(data, data[len(data)-1])
	}

	// 建立葉節點
	for _, datum := range data {
		nodes = append(nodes, NewMerkleNode(nil, nil, datum))
	}

	// 逐層構建
	for len(nodes) &gt; 1 {
		if len(nodes)%2 != 0 {
			nodes = append(nodes, nodes[len(nodes)-1])
		}
		var level []*MerkleNode
		for i := 0; i &lt; len(nodes); i += 2 {
			node := NewMerkleNode(nodes[i], nodes[i+1], nil)
			level = append(level, node)
		}
		nodes = level
	}

	return &amp;MerkleTree{RootNode: nodes[0]}
}
</code></pre>
<p>常見坑：</p>
<ul>
<li>奇數葉節點時複製最後一個葉節點（Bitcoin 的做法，但這引入了一個已知的「duplicate transaction」漏洞，CVE-2012-2459）</li>
<li>序列化不一致導致根 hash 不一致</li>
<li>沒有處理空交易列表的邊界情況</li>
</ul>
<h3 id="514-go-語言實現-p2p-網絡-p0"><a class="header" href="#514-go-語言實現-p2p-網絡-p0">5.1.4 Go 語言實現 P2P 網絡 <code>P0</code></a></h3>
<p>最小消息定義建議：</p>
<ul>
<li><code>version</code></li>
<li><code>getblocks</code></li>
<li><code>inv</code></li>
<li><code>getdata</code></li>
<li><code>block</code></li>
<li><code>tx</code></li>
</ul>
<p>實現一個最小但可用的 P2P 網路層，需要解決三個核心問題：消息定義、消息路由、狀態同步。Bitcoin 的 P2P 協議定義了超過 30 種消息類型，但對於教學鏈，6 種就足夠讓兩個節點互相同步區塊和交易。</p>
<pre><code class="language-text">節點同步流程（Initial Block Download）：

Node A (新節點)              Node B (已有區塊)

1. version ─────────────&gt;
                          &lt;───────────── version
2. getblocks ───────────&gt;  (告訴 B 自己的最高區塊)
                          &lt;───────────── inv (回覆 B 有但 A 沒有的區塊 hash 列表)
3. getdata ─────────────&gt;  (請求具體的區塊)
                          &lt;───────────── block (回覆完整區塊)
   (驗證並儲存區塊)
   (重複 3 直到同步完成)
</code></pre>
<pre><code class="language-go">// 消息類型定義
const (
	CmdVersion   = "version"
	CmdGetBlocks = "getblocks"
	CmdInv       = "inv"
	CmdGetData   = "getdata"
	CmdBlock     = "block"
	CmdTx        = "tx"
)

// Version 消息
type MsgVersion struct {
	Version     int32
	BestHeight  int64
	AddrFrom    string
}

// Inv 消息（庫存通知）
type MsgInv struct {
	Type  string   // "block" or "tx"
	Items [][]byte // hash 列表
}

// P2P 伺服器骨架
type Server struct {
	nodeAddr   string
	knownPeers map[string]bool
	blockchain *Blockchain
	mempool    map[string]*Transaction
	mu         sync.RWMutex
}

func (s *Server) Start() error {
	ln, err := net.Listen("tcp", s.nodeAddr)
	if err != nil {
		return err
	}
	defer ln.Close()

	// 啟動時向 seed nodes 發送 version
	for peer := range s.knownPeers {
		go s.sendVersion(peer)
	}

	for {
		conn, err := ln.Accept()
		if err != nil {
			log.Printf("accept error: %v", err)
			continue
		}
		go s.handleConnection(conn)
	}
}

func (s *Server) handleConnection(conn net.Conn) {
	defer conn.Close()
	// 設定讀取超時
	conn.SetReadDeadline(time.Now().Add(30 * time.Second))

	msg, err := readMessage(conn)
	if err != nil {
		return
	}

	switch msg.Command {
	case CmdVersion:
		s.handleVersion(msg, conn)
	case CmdGetBlocks:
		s.handleGetBlocks(msg, conn)
	case CmdInv:
		s.handleInv(msg, conn)
	case CmdGetData:
		s.handleGetData(msg, conn)
	case CmdBlock:
		s.handleBlock(msg, conn)
	case CmdTx:
		s.handleTx(msg, conn)
	}
}
</code></pre>
<p>工程建議：</p>
<ul>
<li>每種消息用獨立 handler</li>
<li>建立 peer set 與去重 cache</li>
<li>記錄最後已知區塊高度</li>
<li>為每個 peer 維護一個 send queue，避免在 handler 中直接寫 socket 造成阻塞</li>
<li>用 <code>context.Context</code> 控制 goroutine 生命週期，避免洩漏</li>
</ul>
<h2 id="52-go-語言實現-pow-共識算法"><a class="header" href="#52-go-語言實現-pow-共識算法">5.2 Go 語言實現 PoW 共識算法</a></h2>
<h3 id="521-區塊定義與數據串行化-p0"><a class="header" href="#521-區塊定義與數據串行化-p0">5.2.1 區塊定義與數據串行化 <code>P0</code></a></h3>
<p>核心結構：</p>
<pre><code class="language-go">type Block struct {
    Version    int64
    PrevHash   []byte
    MerkleRoot []byte
    Timestamp  int64
    Bits       int64
    Nonce      int64
    Hash       []byte
    Txs        []*Transaction
}
</code></pre>
<p>區塊結構的設計是整條鏈的基礎。Bitcoin 的區塊 header 固定 80 bytes，包含 6 個欄位：Version、PrevHash、MerkleRoot、Timestamp、Bits、Nonce。這個設計的精妙之處在於：header 與交易資料分離——PoW 挖礦只需要計算 80 bytes 的 header hash，而不需要把所有交易都放進計算。交易資料通過 MerkleRoot 間接綁定到 header 上。</p>
<pre><code class="language-text">區塊結構解剖：

┌─────────────────────────────────────────┐
│              Block Header (80 bytes)     │
│  ┌─────────────┬──────────────────────┐ │
│  │ Version     │ 協議版本號 (4 bytes)  │ │
│  ├─────────────┼──────────────────────┤ │
│  │ PrevHash    │ 前一區塊 hash (32B)  │ │
│  ├─────────────┼──────────────────────┤ │
│  │ MerkleRoot  │ 交易 Merkle 根 (32B) │ │
│  ├─────────────┼──────────────────────┤ │
│  │ Timestamp   │ 出塊時間戳 (4 bytes) │ │
│  ├─────────────┼──────────────────────┤ │
│  │ Bits        │ 難度目標 (4 bytes)    │ │
│  ├─────────────┼──────────────────────┤ │
│  │ Nonce       │ 隨機數 (4 bytes)      │ │
│  └─────────────┴──────────────────────┘ │
├─────────────────────────────────────────┤
│              Transactions                │
│  ┌──────────────────────────────────┐   │
│  │ Coinbase Tx (區塊獎勵)           │   │
│  ├──────────────────────────────────┤   │
│  │ Tx 1                            │   │
│  ├──────────────────────────────────┤   │
│  │ Tx 2                            │   │
│  ├──────────────────────────────────┤   │
│  │ ...                             │   │
│  └──────────────────────────────────┘   │
└─────────────────────────────────────────┘
</code></pre>
<p>序列化建議：</p>
<ul>
<li><code>encoding/gob</code>（教學簡單）或 <code>protobuf</code>（可演進）</li>
<li>解碼錯誤要立即失敗，不可靜默忽略</li>
</ul>
<p><code>encoding/gob</code> 是 Go 原生的序列化格式，使用簡單，但有一個重要限制：它不是跨語言的。如果你的鏈未來需要支持非 Go 客戶端，建議從一開始就使用 protobuf 或 CBOR。</p>
<pre><code class="language-go">// 區塊序列化與反序列化
func (b *Block) Serialize() ([]byte, error) {
	var result bytes.Buffer
	encoder := gob.NewEncoder(&amp;result)
	if err := encoder.Encode(b); err != nil {
		return nil, fmt.Errorf("serialize block: %w", err)
	}
	return result.Bytes(), nil
}

func DeserializeBlock(data []byte) (*Block, error) {
	var block Block
	decoder := gob.NewDecoder(bytes.NewReader(data))
	if err := decoder.Decode(&amp;block); err != nil {
		return nil, fmt.Errorf("deserialize block: %w", err)
	}
	return &amp;block, nil
}

// 建立新區塊的工廠函數
func NewBlock(txs []*Transaction, prevHash []byte, height int64) *Block {
	block := &amp;Block{
		Version:   1,
		PrevHash:  prevHash,
		Timestamp: time.Now().Unix(),
		Txs:       txs,
	}

	// 計算 Merkle Root
	var txHashes [][]byte
	for _, tx := range txs {
		txHashes = append(txHashes, tx.ID)
	}
	tree := NewMerkleTree(txHashes)
	block.MerkleRoot = tree.RootNode.Data

	// 執行 PoW
	pow := NewProofOfWork(block)
	nonce, hash := pow.Mine()
	block.Nonce = nonce
	block.Hash = hash

	return block
}
</code></pre>
<h3 id="522-pow-算法實現-p0"><a class="header" href="#522-pow-算法實現-p0">5.2.2 PoW 算法實現 <code>P0</code></a></h3>
<p>流程：</p>
<ol>
<li>準備區塊 header bytes</li>
<li>從 nonce=0 迭代</li>
<li>計算 hash，與 target 比較</li>
<li>命中後寫入區塊 <code>Nonce</code> 與 <code>Hash</code></li>
</ol>
<pre><code class="language-text">PrepareHeader -&gt; Hash -&gt; CompareTarget -&gt; Success? -&gt; next nonce
</code></pre>
<p>PoW 的實作看似簡單（就是個 for 迴圈），但有幾個工程細節決定了正確性和效能。首先，<code>prepareData</code> 必須確保欄位順序和序列化方式在所有節點上完全一致。其次，target 的計算必須從 <code>Bits</code> 欄位正確轉換——Bitcoin 使用一種壓縮格式來表示 256 bit 的 target。</p>
<pre><code class="language-go">// PoW 完整實作
const targetBits = 16 // 教學用低難度

type ProofOfWork struct {
	block  *Block
	target *big.Int
}

func NewProofOfWork(b *Block) *ProofOfWork {
	target := big.NewInt(1)
	target.Lsh(target, uint(256-targetBits))
	return &amp;ProofOfWork{b, target}
}

// 準備用於 hash 的資料
func (pow *ProofOfWork) prepareData(nonce int64) []byte {
	return bytes.Join([][]byte{
		pow.block.PrevHash,
		pow.block.MerkleRoot,
		IntToBytes(pow.block.Timestamp),
		IntToBytes(int64(targetBits)),
		IntToBytes(nonce),
	}, []byte{})
}

// 挖礦
func (pow *ProofOfWork) Mine() (int64, []byte) {
	var hashInt big.Int
	var hash [32]byte
	nonce := int64(0)
	maxNonce := int64(math.MaxInt64)

	fmt.Printf("Mining block with %d transactions...\n", len(pow.block.Txs))

	for nonce &lt; maxNonce {
		data := pow.prepareData(nonce)
		hash = sha256.Sum256(data)
		hashInt.SetBytes(hash[:])

		if hashInt.Cmp(pow.target) == -1 {
			fmt.Printf("Found! nonce=%d hash=%x\n", nonce, hash)
			break
		}
		nonce++
	}
	return nonce, hash[:]
}

// 驗證——收到區塊後必須執行
func (pow *ProofOfWork) Validate() bool {
	var hashInt big.Int
	data := pow.prepareData(pow.block.Nonce)
	hash := sha256.Sum256(data)
	hashInt.SetBytes(hash[:])
	isValid := hashInt.Cmp(pow.target) == -1

	// 額外驗證：重算的 hash 必須與區塊聲稱的 hash 一致
	if isValid &amp;&amp; !bytes.Equal(hash[:], pow.block.Hash) {
		return false
	}
	return isValid
}
</code></pre>
<p>驗證函數：</p>
<ul>
<li>每個節點收到區塊都必須重算驗證</li>
<li>不能信任對方提供的 <code>Hash</code> 欄位</li>
<li>驗證成本是 O(1)（一次 hash 計算），但挖礦成本是 O(2^targetBits) 期望值</li>
</ul>
<p>最佳實踐：</p>
<ul>
<li>在挖礦過程中定期檢查是否有新區塊到達（如果有，應該中止當前挖礦，基於新區塊重新開始）</li>
<li>將挖礦邏輯放在獨立的 goroutine 中，用 <code>context.WithCancel</code> 控制中止</li>
</ul>
<h2 id="53-區塊數據如何持久化"><a class="header" href="#53-區塊數據如何持久化">5.3 區塊數據如何持久化</a></h2>
<h3 id="531-go-語言與-boltdb-實戰-p0"><a class="header" href="#531-go-語言與-boltdb-實戰-p0">5.3.1 Go 語言與 boltDB 實戰 <code>P0</code></a></h3>
<p>BoltDB（bbolt）特性：</p>
<ul>
<li>單機嵌入式 KV</li>
<li>ACID 交易</li>
<li>讀多寫少場景適合教學鏈</li>
</ul>
<p>BoltDB（現在的維護版本是 bbolt，由 etcd 團隊維護）是 Go 生態中最受歡迎的嵌入式 KV 儲存之一。它的 API 非常簡潔：所有操作都在 <code>Tx</code>（事務）中完成，<code>View</code> 是唯讀事務，<code>Update</code> 是讀寫事務。bbolt 使用 B+ tree 作為底層資料結構，所有資料按 key 排序存儲，支持高效的範圍查詢。</p>
<p>對於教學鏈，bbolt 是理想的選擇：不需要安裝外部資料庫、不需要管理連線池、不需要網路通訊。但它有一個重要限制：同一時間只允許一個寫事務（因為使用了檔案鎖）。對於生產級區塊鏈，通常會選擇 LevelDB（Bitcoin Core 使用）或 RocksDB（Ethereum geth 使用）。</p>
<p>建議 bucket：</p>
<ul>
<li><code>blocks</code>：<code>hash -&gt; block bytes</code></li>
<li><code>meta</code>：<code>lastHash -&gt; ...</code></li>
<li><code>utxo</code>：<code>txid:vout -&gt; output</code></li>
</ul>
<pre><code class="language-go">// 資料庫初始化
func InitDB(dbPath string) (*bolt.DB, error) {
	db, err := bolt.Open(dbPath, 0600, &amp;bolt.Options{Timeout: 1 * time.Second})
	if err != nil {
		return nil, fmt.Errorf("open db: %w", err)
	}

	err = db.Update(func(tx *bolt.Tx) error {
		// 建立必要的 bucket
		for _, bucket := range []string{"blocks", "meta", "utxo"} {
			_, err := tx.CreateBucketIfNotExists([]byte(bucket))
			if err != nil {
				return fmt.Errorf("create bucket %s: %w", bucket, err)
			}
		}
		return nil
	})
	return db, err
}

// 儲存區塊
func SaveBlock(db *bolt.DB, block *Block) error {
	return db.Update(func(tx *bolt.Tx) error {
		blocksBucket := tx.Bucket([]byte("blocks"))
		metaBucket := tx.Bucket([]byte("meta"))

		// 序列化並寫入
		data, err := block.Serialize()
		if err != nil {
			return err
		}
		if err := blocksBucket.Put(block.Hash, data); err != nil {
			return err
		}

		// 更新 lastHash
		return metaBucket.Put([]byte("lastHash"), block.Hash)
	})
}
</code></pre>
<h3 id="532-區塊數據如何持久化-p0"><a class="header" href="#532-區塊數據如何持久化-p0">5.3.2 區塊數據如何持久化 <code>P0</code></a></h3>
<p>寫入流程：</p>
<ol>
<li>驗證區塊</li>
<li>寫入 <code>blocks</code></li>
<li>更新 <code>lastHash</code></li>
<li>更新 UTXO 索引</li>
</ol>
<p>持久化流程的正確性至關重要——如果寫入過程中崩潰，資料庫可能處於不一致狀態。bbolt 的 ACID 事務保證了原子性：要麼所有操作都成功，要麼都不生效。但我們仍然需要確保寫入順序的邏輯正確性。</p>
<pre><code class="language-go">// 完整的區塊持久化流程
func (bc *Blockchain) AddBlock(block *Block) error {
	// 1. 驗證區塊
	if err := bc.validateBlock(block); err != nil {
		return fmt.Errorf("invalid block: %w", err)
	}

	// 2. 在一個事務中完成所有寫入
	return bc.db.Update(func(tx *bolt.Tx) error {
		blocksBucket := tx.Bucket([]byte("blocks"))
		metaBucket := tx.Bucket([]byte("meta"))
		utxoBucket := tx.Bucket([]byte("utxo"))

		// 2a. 寫入區塊
		data, _ := block.Serialize()
		if err := blocksBucket.Put(block.Hash, data); err != nil {
			return err
		}

		// 2b. 更新 UTXO 索引
		for _, txn := range block.Txs {
			// 刪除已花費的 UTXO
			for _, vin := range txn.Vin {
				key := fmt.Sprintf("%x:%d", vin.Txid, vin.Vout)
				if err := utxoBucket.Delete([]byte(key)); err != nil {
					return err
				}
			}
			// 添加新的 UTXO
			for idx, vout := range txn.Vout {
				key := fmt.Sprintf("%x:%d", txn.ID, idx)
				data, _ := SerializeOutput(vout)
				if err := utxoBucket.Put([]byte(key), data); err != nil {
					return err
				}
			}
		}

		// 2c. 更新 lastHash
		return metaBucket.Put([]byte("lastHash"), block.Hash)
	})
}
</code></pre>
<h3 id="533-區塊數據如何遍歷-p0"><a class="header" href="#533-區塊數據如何遍歷-p0">5.3.3 區塊數據如何遍歷 <code>P0</code></a></h3>
<p>從 <code>lastHash</code> 反向走 <code>PrevHash</code> 到 genesis：</p>
<pre><code class="language-text">last -&gt; prev -&gt; prev -&gt; ... -&gt; genesis
</code></pre>
<p>區塊鏈的遍歷與普通鏈表相反——我們從最新的區塊開始，沿著 <code>PrevHash</code> 指標一路走到創世區塊。這個設計的原因是：新區塊總是引用前一個區塊，而不是前一個區塊引用後一個區塊（因為出塊時還不知道下一個區塊是什麼）。</p>
<pre><code class="language-go">// 區塊鏈迭代器
type BlockchainIterator struct {
	currentHash []byte
	db          *bolt.DB
}

func (bc *Blockchain) Iterator() *BlockchainIterator {
	var lastHash []byte
	bc.db.View(func(tx *bolt.Tx) error {
		meta := tx.Bucket([]byte("meta"))
		lastHash = meta.Get([]byte("lastHash"))
		return nil
	})
	return &amp;BlockchainIterator{currentHash: lastHash, db: bc.db}
}

func (it *BlockchainIterator) Next() (*Block, error) {
	if len(it.currentHash) == 0 {
		return nil, nil // 已到達 genesis 之前
	}

	var block *Block
	err := it.db.View(func(tx *bolt.Tx) error {
		blocksBucket := tx.Bucket([]byte("blocks"))
		data := blocksBucket.Get(it.currentHash)
		if data == nil {
			return fmt.Errorf("block not found: %x", it.currentHash)
		}
		var err error
		block, err = DeserializeBlock(data)
		return err
	})

	if err != nil {
		return nil, err
	}

	it.currentHash = block.PrevHash
	return block, nil
}

// 使用範例：列印所有區塊
func PrintChain(bc *Blockchain) {
	it := bc.Iterator()
	for {
		block, err := it.Next()
		if err != nil || block == nil {
			break
		}
		fmt.Printf("Block %x\n", block.Hash)
		fmt.Printf("  PrevHash: %x\n", block.PrevHash)
		fmt.Printf("  Timestamp: %d\n", block.Timestamp)
		fmt.Printf("  Nonce: %d\n", block.Nonce)
		fmt.Printf("  Transactions: %d\n", len(block.Txs))
		fmt.Println()
	}
}
</code></pre>
<p>常見坑：</p>
<ul>
<li>遍歷未處理空 hash 終止條件（genesis block 的 PrevHash 是全零）</li>
<li>DB 交易未關閉造成資源泄漏（bbolt 的 <code>View</code> 和 <code>Update</code> 會自動管理，但如果手動使用 <code>tx.Begin()</code>，必須確保 <code>Commit</code> 或 <code>Rollback</code>）</li>
<li>遍歷過程中修改資料庫，導致迭代器失效</li>
</ul>
<h2 id="54-go-語言實現-utxo-模型"><a class="header" href="#54-go-語言實現-utxo-模型">5.4 Go 語言實現 UTXO 模型</a></h2>
<h3 id="541-如何定義交易-p0"><a class="header" href="#541-如何定義交易-p0">5.4.1 如何定義交易 <code>P0</code></a></h3>
<pre><code class="language-go">type TXInput struct {
    Txid      []byte
    Vout      int
    Signature []byte
    PubKey    []byte
}

type TXOutput struct {
    Value      int
    PubKeyHash []byte
}

type Transaction struct {
    ID   []byte
    Vin  []TXInput
    Vout []TXOutput
}
</code></pre>
<p>交易結構是 UTXO 模型的核心。<code>TXInput</code> 引用一個之前的 <code>TXOutput</code>（通過 <code>Txid</code> 和 <code>Vout</code> 索引），<code>TXOutput</code> 定義了新的資產歸屬。一筆交易可以有多個輸入和多個輸出，這讓「合併」和「分割」UTXO 成為可能。</p>
<p>交易 ID 的計算方式很重要：它是整筆交易（去除簽名後）的 hash。為什麼要去除簽名？因為簽名本身依賴於交易 ID（你要先知道交易的內容才能簽名），如果交易 ID 包含簽名，就會形成循環依賴。Bitcoin 的做法是：先計算不含簽名的交易 hash 作為 ID，然後用私鑰對這個 ID 簽名。</p>
<pre><code class="language-go">// 計算交易 ID
func (tx *Transaction) CalcHash() {
	// 暫時清除簽名，避免循環依賴
	txCopy := *tx
	for i := range txCopy.Vin {
		txCopy.Vin[i].Signature = nil
		txCopy.Vin[i].PubKey = nil
	}

	var buf bytes.Buffer
	enc := gob.NewEncoder(&amp;buf)
	_ = enc.Encode(txCopy)

	hash := sha256.Sum256(buf.Bytes())
	tx.ID = hash[:]
}

// TXOutput 的鎖定與解鎖
func (out *TXOutput) Lock(address []byte) {
	pubKeyHash := Base58Decode(address)
	pubKeyHash = pubKeyHash[1 : len(pubKeyHash)-4] // 去除 version 和 checksum
	out.PubKeyHash = pubKeyHash
}

func (out *TXOutput) IsLockedWithKey(pubKeyHash []byte) bool {
	return bytes.Equal(out.PubKeyHash, pubKeyHash)
}
</code></pre>
<h3 id="542-如何判斷-coinbase-交易-p0"><a class="header" href="#542-如何判斷-coinbase-交易-p0">5.4.2 如何判斷 CoinBase 交易 <code>P0</code></a></h3>
<p>規則：</p>
<ul>
<li><code>len(Vin) == 1</code></li>
<li><code>Vin[0].Txid == nil</code></li>
<li><code>Vin[0].Vout == -1</code></li>
</ul>
<p>CoinBase 交易是區塊鏈中「創造新幣」的唯一途徑。每個區塊的第一筆交易必須是 CoinBase，它沒有任何輸入（因為幣是憑空產生的），只有輸出。礦工通過 CoinBase 交易獲得區塊獎勵和該區塊中所有交易的手續費。</p>
<p>Bitcoin 的 CoinBase 交易有一個額外功能：它的「輸入」欄位可以攜帶任意資料（最多 100 bytes）。Satoshi 在創世區塊的 CoinBase 中寫入了著名的 "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"。礦池通常在這裡寫入礦池標識和區塊高度。</p>
<pre><code class="language-go">// 建立 CoinBase 交易
func NewCoinbaseTX(to string, data string) *Transaction {
	if data == "" {
		data = fmt.Sprintf("Reward to %s", to)
	}

	txin := TXInput{
		Txid:      nil,
		Vout:      -1,
		Signature: nil,
		PubKey:    []byte(data), // CoinBase 可以攜帶任意資料
	}

	txout := NewTXOutput(BlockReward, to) // BlockReward 如 50 BTC

	tx := Transaction{
		Vin:  []TXInput{txin},
		Vout: []TXOutput{*txout},
	}
	tx.CalcHash()
	return &amp;tx
}

// 判斷是否為 CoinBase 交易
func (tx *Transaction) IsCoinbase() bool {
	return len(tx.Vin) == 1 &amp;&amp;
		tx.Vin[0].Txid == nil &amp;&amp;
		tx.Vin[0].Vout == -1
}
</code></pre>
<h3 id="543-如何使用-coinbase-交易-p0"><a class="header" href="#543-如何使用-coinbase-交易-p0">5.4.3 如何使用 CoinBase 交易 <code>P0</code></a></h3>
<p>CoinBase 用於區塊獎勵，通常每個區塊第一筆交易。</p>
<p>實作要點：</p>
<ul>
<li>獎勵值可參數化</li>
<li>高度可寫入 <code>scriptSig</code> 或附加欄位</li>
</ul>
<p>Bitcoin 的區塊獎勵每 210,000 個區塊減半一次：最初是 50 BTC，2012 年減半到 25 BTC，2016 年 12.5 BTC，2020 年 6.25 BTC，2024 年 3.125 BTC。這個減半機制確保了 Bitcoin 的總量上限為 2100 萬枚。在教學鏈中，可以簡化為固定獎勵或以區塊高度計算減半。</p>
<pre><code class="language-go">const InitialReward = 50

// 根據區塊高度計算獎勵
func CalcBlockReward(height int64) int {
	halvings := height / 210000
	if halvings &gt;= 64 { // 超過 64 次減半後獎勵為 0
		return 0
	}
	return InitialReward &gt;&gt; uint(halvings)
}
</code></pre>
<h3 id="544-如何查找賬戶的-utxo-p0"><a class="header" href="#544-如何查找賬戶的-utxo-p0">5.4.4 如何查找賬戶的 UTXO <code>P0</code></a></h3>
<p>流程：</p>
<ol>
<li>從 UTXO 集索引查 <code>PubKeyHash</code> 匹配輸出</li>
<li>累加直到滿足轉帳金額</li>
<li>回傳可用輸入與總額</li>
</ol>
<p>UTXO 查找是錢包最高頻的操作之一。查餘額等於掃描所有屬於某個地址的未花費輸出並求和。為了效率，我們維護一個獨立的 UTXO 集合索引，而不是每次都遍歷整條鏈。</p>
<pre><code class="language-go">// UTXO 集合
type UTXOSet struct {
	db *bolt.DB
}

// 查詢地址餘額
func (u *UTXOSet) GetBalance(pubKeyHash []byte) int {
	balance := 0
	u.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte("utxo"))
		c := b.Cursor()
		for k, v := c.First(); k != nil; k, v = c.Next() {
			out := DeserializeOutput(v)
			if out.IsLockedWithKey(pubKeyHash) {
				balance += out.Value
			}
		}
		return nil
	})
	return balance
}

// 查找足夠的 UTXO 用於交易（coin selection）
func (u *UTXOSet) FindSpendableOutputs(pubKeyHash []byte, amount int) (int, map[string][]int) {
	unspentOutputs := make(map[string][]int)
	accumulated := 0

	u.db.View(func(tx *bolt.Tx) error {
		b := tx.Bucket([]byte("utxo"))
		c := b.Cursor()
		for k, v := c.First(); k != nil; k, v = c.Next() {
			// key 格式: "txid:vout"
			parts := strings.SplitN(string(k), ":", 2)
			txID := parts[0]
			outIdx, _ := strconv.Atoi(parts[1])

			out := DeserializeOutput(v)
			if out.IsLockedWithKey(pubKeyHash) {
				accumulated += out.Value
				unspentOutputs[txID] = append(unspentOutputs[txID], outIdx)

				if accumulated &gt;= amount {
					return nil // 夠了，提前終止
				}
			}
		}
		return nil
	})
	return accumulated, unspentOutputs
}
</code></pre>
<p>常見坑：</p>
<ul>
<li>沒標記已花費輸出，導致雙花</li>
<li>未處理變更輸出導致餘額錯誤</li>
<li>coin selection 沒有考慮手續費——找到剛好夠轉帳金額的 UTXO 後，扣除手續費就不夠了</li>
<li>在高並發場景下，同一個 UTXO 被兩筆交易同時選中</li>
</ul>
<h3 id="545-如何發送交易-p0"><a class="header" href="#545-如何發送交易-p0">5.4.5 如何發送交易 <code>P0</code></a></h3>
<p>完整流程：</p>
<ol>
<li>選 UTXO（coin selection）</li>
<li>建輸入輸出（含找零）</li>
<li>對每個輸入簽名</li>
<li>計算 txid</li>
<li>廣播到交易池</li>
</ol>
<pre><code class="language-text">SelectUTXO -&gt; BuildTx -&gt; SignInputs -&gt; Verify -&gt; Broadcast
</code></pre>
<p>發送交易是 UTXO 模型中最複雜的操作。每一步都有嚴格的正確性要求：coin selection 要確保輸入金額足夠、找零必須產生、簽名必須覆蓋所有輸入、驗證必須重算 hash。</p>
<pre><code class="language-go">// 發送交易的完整實作
func NewTransaction(from, to string, amount int, utxoSet *UTXOSet, wallets *Wallets) (*Transaction, error) {
	wallet := wallets.GetWallet(from)
	pubKeyHash := HashPubKey(wallet.PublicKey)

	// 1. Coin Selection
	accumulated, validOutputs := utxoSet.FindSpendableOutputs(pubKeyHash, amount)
	if accumulated &lt; amount {
		return nil, fmt.Errorf("insufficient funds: have %d, need %d", accumulated, amount)
	}

	// 2. 建立輸入
	var inputs []TXInput
	for txid, outs := range validOutputs {
		txIDBytes, _ := hex.DecodeString(txid)
		for _, out := range outs {
			inputs = append(inputs, TXInput{
				Txid:   txIDBytes,
				Vout:   out,
				PubKey: wallet.PublicKey,
			})
		}
	}

	// 3. 建立輸出（收款人 + 找零）
	outputs := []TXOutput{*NewTXOutput(amount, to)}
	if accumulated &gt; amount {
		// 找零回到發送者——這一步絕對不能忘！
		outputs = append(outputs, *NewTXOutput(accumulated-amount, from))
	}

	tx := Transaction{Vin: inputs, Vout: outputs}
	tx.CalcHash()

	// 4. 簽名
	utxoSet.Blockchain.SignTransaction(&amp;tx, wallet.PrivateKey)

	return &amp;tx, nil
}
</code></pre>
<p>最佳實踐：</p>
<ul>
<li>永遠在 <code>NewTransaction</code> 結束前驗證 <code>sum(inputs) == sum(outputs) + fee</code></li>
<li>找零地址最好用新地址（提升隱私性）</li>
<li>coin selection 策略：優先選擇「剛好夠用」的 UTXO，其次選擇「最大的一個」，避免碎片化</li>
</ul>
<h2 id="55-區塊鏈賬戶地址如何生成"><a class="header" href="#55-區塊鏈賬戶地址如何生成">5.5 區塊鏈賬戶地址如何生成</a></h2>
<h3 id="551-公鑰加密與數字簽名-p0"><a class="header" href="#551-公鑰加密與數字簽名-p0">5.5.1 公鑰加密與數字簽名 <code>P0</code></a></h3>
<p>常用曲線：<code>secp256k1</code></p>
<p>簽名驗證核心：</p>
<ul>
<li>私鑰簽</li>
<li>公鑰驗</li>
<li>交易內容變動則簽名失效</li>
</ul>
<p><code>secp256k1</code> 是 Bitcoin 和 Ethereum 共同使用的橢圓曲線。它的安全性基於橢圓曲線離散對數問題（ECDLP）：已知公鑰（一個曲線上的點），要反推私鑰（一個標量）在計算上不可行。</p>
<p>數位簽名的數學原理可以簡化理解為：私鑰 <code>k</code> 和待簽資料 <code>m</code> 通過 ECDSA 演算法產生簽名 <code>(r, s)</code>。任何人只要有公鑰 <code>K</code> 和原始資料 <code>m</code>，就能驗證 <code>(r, s)</code> 是否由持有 <code>k</code> 的人產生。整個過程中，私鑰從未被暴露。</p>
<pre><code class="language-go">// 使用 Go 標準庫進行 ECDSA 簽名和驗證
import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"math/big"
)

// 生成金鑰對
func NewKeyPair() (ecdsa.PrivateKey, []byte) {
	curve := elliptic.P256() // 教學用 P256，Bitcoin 用 secp256k1
	privateKey, _ := ecdsa.GenerateKey(curve, rand.Reader)

	// 公鑰 = 曲線上的點 (X, Y)，拼接成 bytes
	pubKey := append(privateKey.PublicKey.X.Bytes(), privateKey.PublicKey.Y.Bytes()...)
	return *privateKey, pubKey
}

// 簽名交易
func (tx *Transaction) Sign(privKey ecdsa.PrivateKey, prevTXs map[string]Transaction) {
	if tx.IsCoinbase() {
		return // CoinBase 不需要簽名
	}

	txCopy := tx.TrimmedCopy() // 去除簽名的副本

	for inIdx, vin := range txCopy.Vin {
		prevTX := prevTXs[hex.EncodeToString(vin.Txid)]
		txCopy.Vin[inIdx].PubKey = prevTX.Vout[vin.Vout].PubKeyHash

		txCopy.CalcHash()
		dataToSign := txCopy.ID

		r, s, _ := ecdsa.Sign(rand.Reader, &amp;privKey, dataToSign)
		signature := append(r.Bytes(), s.Bytes()...)
		tx.Vin[inIdx].Signature = signature

		txCopy.Vin[inIdx].PubKey = nil // 重置，處理下一個輸入
	}
}

// 驗證交易簽名
func (tx *Transaction) Verify(prevTXs map[string]Transaction) bool {
	txCopy := tx.TrimmedCopy()
	curve := elliptic.P256()

	for inIdx, vin := range tx.Vin {
		prevTX := prevTXs[hex.EncodeToString(vin.Txid)]
		txCopy.Vin[inIdx].PubKey = prevTX.Vout[vin.Vout].PubKeyHash

		txCopy.CalcHash()
		dataToVerify := txCopy.ID

		// 解析簽名
		r := big.Int{}
		s := big.Int{}
		sigLen := len(vin.Signature)
		r.SetBytes(vin.Signature[:sigLen/2])
		s.SetBytes(vin.Signature[sigLen/2:])

		// 解析公鑰
		x := big.Int{}
		y := big.Int{}
		keyLen := len(vin.PubKey)
		x.SetBytes(vin.PubKey[:keyLen/2])
		y.SetBytes(vin.PubKey[keyLen/2:])

		rawPubKey := ecdsa.PublicKey{Curve: curve, X: &amp;x, Y: &amp;y}
		if !ecdsa.Verify(&amp;rawPubKey, dataToVerify, &amp;r, &amp;s) {
			return false
		}

		txCopy.Vin[inIdx].PubKey = nil
	}
	return true
}
</code></pre>
<h3 id="552-生成區塊鏈賬戶地址-p0"><a class="header" href="#552-生成區塊鏈賬戶地址-p0">5.5.2 生成區塊鏈賬戶地址 <code>P0</code></a></h3>
<p>流程：</p>
<ol>
<li>生成私鑰</li>
<li>推導公鑰</li>
<li>公鑰 hash</li>
<li>加版本與 checksum</li>
<li>Base58 編碼</li>
</ol>
<p>安全要求：</p>
<ul>
<li>私鑰不落盤明文</li>
<li>助記詞/私鑰分離備份</li>
</ul>
<p>這個流程串聯了前面學到的所有密碼學元件：橢圓曲線產生金鑰對、hash 函數壓縮公鑰、Base58 編碼產生人類可讀地址。每一步都不可逆——從地址無法推導公鑰，從公鑰無法推導私鑰。</p>
<pre><code class="language-go">// 錢包結構
type Wallet struct {
	PrivateKey ecdsa.PrivateKey
	PublicKey  []byte
}

// 建立新錢包
func NewWallet() *Wallet {
	private, public := NewKeyPair()
	return &amp;Wallet{PrivateKey: private, PublicKey: public}
}

// 從公鑰推導地址
func (w *Wallet) GetAddress() []byte {
	// Step 1: SHA256 + RIPEMD160
	pubKeyHash := HashPubKey(w.PublicKey)

	// Step 2: 加版本前綴（0x00 = mainnet）
	versionedPayload := append([]byte{0x00}, pubKeyHash...)

	// Step 3: 計算 checksum
	checksum := Checksum(versionedPayload)

	// Step 4: 拼接並 Base58 編碼
	fullPayload := append(versionedPayload, checksum...)
	address := Base58Encode(fullPayload)

	return address
}

func HashPubKey(pubKey []byte) []byte {
	publicSHA256 := sha256.Sum256(pubKey)

	RIPEMD160Hasher := ripemd160.New()
	_, _ = RIPEMD160Hasher.Write(publicSHA256[:])
	publicRIPEMD160 := RIPEMD160Hasher.Sum(nil)

	return publicRIPEMD160
}
</code></pre>
<pre><code class="language-text">地址生成完整流程圖：

  Private Key (32 bytes, 隨機生成)
       │
       │  橢圓曲線乘法 (不可逆)
       v
  Public Key (65 bytes, uncompressed)
       │
       │  SHA256
       v
  SHA256(PubKey) (32 bytes)
       │
       │  RIPEMD160
       v
  PubKeyHash (20 bytes)
       │
       │  加版本前綴 (0x00)
       v
  Version + PubKeyHash (21 bytes)
       │
       │  雙重 SHA256，取前 4 bytes
       v
  Checksum (4 bytes)
       │
       │  拼接
       v
  Version + PubKeyHash + Checksum (25 bytes)
       │
       │  Base58 編碼
       v
  Bitcoin Address (如: 1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa)
</code></pre>
<h2 id="實訓結合區塊鏈賬戶地址發送區塊鏈交易-p0"><a class="header" href="#實訓結合區塊鏈賬戶地址發送區塊鏈交易-p0">實訓：結合區塊鏈賬戶地址，發送區塊鏈交易 <code>P0</code></a></h2>
<p>目標：</p>
<ul>
<li>建立兩個地址 A/B</li>
<li>A 先獲得 coinbase</li>
<li>A 向 B 轉帳並找零</li>
<li>打包出塊後驗證餘額</li>
</ul>
<p>驗收：</p>
<ul>
<li>A/B 餘額符合預期</li>
<li>交易可驗簽</li>
<li>UTXO 集狀態正確更新</li>
</ul>
<p>以下是完整的端到端測試場景：</p>
<pre><code class="language-go">func TestFullFlow(t *testing.T) {
	// 1. 建立錢包
	walletA := NewWallet()
	walletB := NewWallet()
	addrA := string(walletA.GetAddress())
	addrB := string(walletB.GetAddress())

	// 2. 建立區塊鏈（genesis block 獎勵給 A）
	bc := NewBlockchain(addrA)
	defer bc.db.Close()
	utxoSet := UTXOSet{bc}
	utxoSet.Reindex()

	// 3. 驗證 A 的初始餘額
	balA := utxoSet.GetBalance(HashPubKey(walletA.PublicKey))
	assert.Equal(t, 50, balA) // 假設獎勵 50

	// 4. A 向 B 轉帳 30
	tx, err := NewTransaction(addrA, addrB, 30, &amp;utxoSet, wallets)
	assert.NoError(t, err)

	// 5. 打包出塊
	newBlock := bc.MineBlock([]*Transaction{tx})

	// 6. 更新 UTXO 集
	utxoSet.Update(newBlock)

	// 7. 驗證餘額
	balA = utxoSet.GetBalance(HashPubKey(walletA.PublicKey))
	balB := utxoSet.GetBalance(HashPubKey(walletB.PublicKey))

	// A: 50 (coinbase) - 30 (轉帳) = 20 (找零)
	// 加上新區塊的 coinbase 獎勵（如果 A 是礦工）
	assert.Equal(t, 20, balA) // 不含新 coinbase
	assert.Equal(t, 30, balB)

	// 8. 驗證交易簽名
	assert.True(t, tx.Verify(prevTXs))
}
</code></pre>
<pre><code class="language-text">完整流程時序圖：

Time ──────────────────────────────────────────────&gt;

Block 0 (Genesis):              Block 1:
┌──────────────────────┐        ┌──────────────────────┐
│ Coinbase -&gt; A: 50    │        │ Coinbase -&gt; A: 50    │
│                      │        │ A -&gt; B: 30           │
│                      │        │ A -&gt; A: 20 (找零)    │
└──────────────────────┘        └──────────────────────┘

UTXO 集變化：
Block 0 後: {A: [50]}
Block 1 後: {A: [50(新coinbase), 20(找零)], B: [30]}
</code></pre>
<h2 id="章節回顧與工程要點-2"><a class="header" href="#章節回顧與工程要點-2">章節回顧與工程要點</a></h2>
<p>本章完成了一條簡化但完整的區塊鏈實作。以下是每個模組的核心工程知識和需要銘記的設計決策：</p>
<p><strong>核心資料結構</strong>：區塊、交易、UTXO 三者的結構定義決定了整條鏈的能力邊界。序列化的穩定性是 hash 一致性的基礎，永遠使用 binary encoding 而非 JSON。區塊 header 與交易資料分離，通過 Merkle Root 連接，這個設計支撐了 SPV 輕節點的可行性。</p>
<p><strong>PoW 出塊與驗證流程</strong>：挖礦的計算成本和驗證的低成本形成了非對稱性，這是 PoW 安全的根本。驗證必須重算 header hash，絕不信任對方聲稱的 hash 值。挖礦過程需要能被中斷（當新區塊到達時），否則會浪費算力。</p>
<p><strong>UTXO 交易與地址生成</strong>：UTXO 模型的核心是「消費舊輸出、產生新輸出」。找零是最容易出錯的環節——忘記產生找零等於把剩餘金額當手續費送給了礦工。地址生成串聯了橢圓曲線、hash 函數、Base58 三個密碼學元件，每一步都不可逆。</p>
<p><strong>DB 持久化與遍歷</strong>：bbolt 的 ACID 事務保證了寫入的原子性。UTXO 集合索引是效能的關鍵——沒有它，每次查餘額都需要遍歷整條鏈。區塊鏈遍歷從最新區塊沿 PrevHash 反向走到 genesis。</p>
<h2 id="白話總結-24"><a class="header" href="#白話總結-24">白話總結</a></h2>
<p>這一章就是帶你從零開始造一條能跑的區塊鏈。首先你得把 hash、Base58、Merkle Tree 這些密碼學工具都用 Go 實作出來，這些是區塊鏈的「零件」。然後你把這些零件組裝成區塊和交易的資料結構，用 PoW 讓區塊不能被隨便偽造。UTXO 模型是最燒腦的部分，你得理解「餘額」其實不存在，存在的只是一堆散落的「未花費輸出」。發交易就是選幾個舊的輸出消耗掉，然後產生新的輸出——一定要記得找零，不然剩下的錢就白送給礦工了。最後用 bbolt 把所有資料存到硬碟上。做完這些，你手上就有一條能生成地址、發送交易、挖礦出塊、驗證簽名的完整簡化鏈了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="第6章-go-語言離線錢包開發"><a class="header" href="#第6章-go-語言離線錢包開發">第6章 Go 語言離線錢包開發</a></h1>
<p>本章目標是做出「簽名在離線端、查詢在在線端」的實務錢包架構。</p>
<h2 id="61-區塊鏈錢包原理"><a class="header" href="#61-區塊鏈錢包原理">6.1 區塊鏈錢包原理</a></h2>
<h3 id="611-區塊鏈錢包的核心原理-p0"><a class="header" href="#611-區塊鏈錢包的核心原理-p0">6.1.1 區塊鏈錢包的核心原理 <code>P0</code></a></h3>
<p>錢包不是資產保險箱，而是：</p>
<ul>
<li>金鑰管理器</li>
<li>簽名器</li>
<li>地址與交易組裝工具</li>
</ul>
<p>核心分層：</p>
<pre><code class="language-text">Key Management -&gt; Tx Builder -&gt; Signer -&gt; Broadcaster -&gt; Index/Query
</code></pre>
<p>設計原則：</p>
<ul>
<li>私鑰永不出簽名邊界</li>
<li>查詢與簽名分離</li>
<li>所有交易可重現與可審計</li>
</ul>
<p>很多初學者誤以為錢包「儲存了加密貨幣」。事實上，資產存在區塊鏈上——準確地說，是存在於 UTXO 集合或帳戶狀態中。錢包的真正作用是管理私鑰，並用私鑰對交易進行簽名。如果你失去了私鑰，你並沒有「丟失」了幣——幣還在區塊鏈上，你只是永遠無法再移動它們了。</p>
<p>離線錢包（也稱為冷錢包）的核心設計思想是「簽名環境與網路完全隔離」。這意味著私鑰所在的機器永遠不連接網際網路，攻擊者即使入侵了在線系統，也無法觸及私鑰。交易的組裝可以在在線端完成（因為需要查詢餘額、nonce、gas price 等資訊），但最終的簽名必須在離線端執行。</p>
<pre><code class="language-text">離線錢包架構：

┌────────────────────────────┐     ┌────────────────────────────┐
│        在線端 (Hot)         │     │       離線端 (Cold)         │
│                            │     │                            │
│  ┌──────────────────────┐  │     │  ┌──────────────────────┐  │
│  │ 查詢餘額 / UTXO      │  │     │  │ 私鑰管理             │  │
│  │ 查詢 nonce / gas     │  │     │  │ (加密儲存)           │  │
│  │ 組裝交易 (unsigned)  │  │     │  └──────────┬───────────┘  │
│  └──────────┬───────────┘  │     │             │              │
│             │              │     │             v              │
│             │  未簽名交易   │     │  ┌──────────────────────┐  │
│             │ ──────────&gt;  │ USB │  │ 驗證交易內容          │  │
│             │              │ / QR│  │ 簽名                  │  │
│             │  已簽名交易   │     │  └──────────┬───────────┘  │
│             │ &lt;──────────  │     │             │              │
│             v              │     │             v              │
│  ┌──────────────────────┐  │     │  ┌──────────────────────┐  │
│  │ 廣播交易             │  │     │  │ 產生已簽名交易        │  │
│  │ 監聽確認             │  │     │  │ (不含私鑰)           │  │
│  └──────────────────────┘  │     │  └──────────────────────┘  │
└────────────────────────────┘     └────────────────────────────┘
          有網路連線                        無網路連線
</code></pre>
<p>在線端和離線端之間的資料傳輸方式有幾種選擇：USB 隨身碟、QR code 掃描、或者藍牙（如 Ledger Nano X）。最安全的方式是 QR code，因為它是單向的、可視的——你能用肉眼確認傳輸的內容不包含私鑰。</p>
<p>真實案例：2022 年 Ronin Bridge 被盜 6.25 億美元，根本原因是 9 個驗證者中有 5 個的私鑰被駭客取得——因為這些私鑰都在聯網的伺服器上。如果使用離線簽名架構，即使伺服器被入侵，攻擊者也無法動用資金。</p>
<h3 id="612-助記詞如何生成與驗證-p0"><a class="header" href="#612-助記詞如何生成與驗證-p0">6.1.2 助記詞如何生成與驗證 <code>P0</code></a></h3>
<p>建議標準：</p>
<ul>
<li>BIP-39（助記詞）</li>
<li>BIP-32（HD 主私鑰）</li>
<li>BIP-44（路徑規範）</li>
</ul>
<p>流程：</p>
<ol>
<li>生成熵</li>
<li>轉助記詞</li>
<li>助記詞 + passphrase 推導 seed</li>
<li>seed 推導主私鑰與子私鑰</li>
</ol>
<p>助記詞（Mnemonic）是私鑰的人類友好表示形式。BIP-39 定義了從隨機熵到 12/24 個英文單詞的轉換規則。這些單詞來自一個固定的 2048 個詞的字典，每個詞編碼 11 bits 的資訊。12 個詞的助記詞對應 128 bits 的熵（加上 4 bits checksum），安全性與 128 bit AES 等效。</p>
<pre><code class="language-text">助記詞生成流程（BIP-39）：

1. 生成隨機熵（128/160/192/224/256 bits）
   例如 128 bits: 0c1e24e5917779d297e14d45f14e1a1a

2. 計算 checksum（SHA256 前 N bits，N = 熵長度 / 32）
   128 bits 熵 -&gt; 4 bits checksum

3. 將熵 + checksum 分成 11-bit 段
   132 bits / 11 = 12 組

4. 每組映射到 BIP-39 字典中的一個單詞
   army van defense carry jealous true
   garbage claim echo media make crunch

5. 助記詞 + 可選 passphrase 通過 PBKDF2 推導 512-bit seed
   PBKDF2(mnemonic, "mnemonic" + passphrase, 2048, 64, SHA512)
</code></pre>
<p>HD（Hierarchical Deterministic）錢包是 BIP-32 定義的金鑰衍生架構。從一個 master seed 可以推導出無限數量的子私鑰，而且整個衍生過程是確定性的——相同的 seed 永遠產生相同的金鑰樹。這意味著你只需要備份一組助記詞，就能恢復所有帳戶。</p>
<p>BIP-44 進一步定義了衍生路徑的標準格式：<code>m / purpose' / coin_type' / account' / change / address_index</code>。例如 Bitcoin 的第一個地址路徑是 <code>m/44'/0'/0'/0/0</code>，Ethereum 是 <code>m/44'/60'/0'/0/0</code>。這個標準確保了不同錢包軟體之間的相容性——在 MetaMask 生成的助記詞可以在 Trust Wallet 中恢復。</p>
<pre><code class="language-go">// 使用 go-bip39 和 go-bip32 生成 HD 錢包
import (
	"github.com/tyler-smith/go-bip39"
	"github.com/tyler-smith/go-bip32"
)

func GenerateHDWallet() (*HDWallet, error) {
	// 1. 生成 128 bits 熵 -&gt; 12 個助記詞
	entropy, err := bip39.NewEntropy(128)
	if err != nil {
		return nil, err
	}

	// 2. 熵轉助記詞
	mnemonic, err := bip39.NewMnemonic(entropy)
	if err != nil {
		return nil, err
	}
	// mnemonic 類似: "army van defense carry jealous true ..."

	// 3. 助記詞 + passphrase 推導 seed
	seed := bip39.NewSeed(mnemonic, "optional-passphrase")

	// 4. seed 推導 master key
	masterKey, err := bip32.NewMasterKey(seed)
	if err != nil {
		return nil, err
	}

	// 5. 按 BIP-44 路徑衍生子金鑰
	// m/44'/60'/0'/0/0 (Ethereum 第一個地址)
	purpose, _ := masterKey.NewChildKey(bip32.FirstHardenedChild + 44)
	coinType, _ := purpose.NewChildKey(bip32.FirstHardenedChild + 60)
	account, _ := coinType.NewChildKey(bip32.FirstHardenedChild + 0)
	change, _ := account.NewChildKey(0)
	addressKey, _ := change.NewChildKey(0)

	return &amp;HDWallet{
		Mnemonic:  mnemonic,
		MasterKey: masterKey,
		FirstKey:  addressKey,
	}, nil
}
</code></pre>
<pre><code class="language-text">HD 錢包衍生樹：

                     Master Key (m)
                          |
              ┌───────────┼───────────┐
              |           |           |
         m/44'/0'    m/44'/60'   m/44'/501'
         (Bitcoin)   (Ethereum)  (Solana)
              |           |
         ┌────┴────┐      |
         |         |      |
     m/.../0'  m/.../1'  m/.../0'
     (Account 0) (Account 1)  (Account 0)
         |
    ┌────┴────┐
    |         |
   0/0       0/1       1/0       1/1
  (外部0)   (外部1)   (找零0)   (找零1)

  外部地址 (change=0): 用於收款
  找零地址 (change=1): 用於交易找零
</code></pre>
<p>常見坑：</p>
<ul>
<li>未檢查 checksum（某些第三方庫不驗證助記詞的 checksum，接受了無效的詞組）</li>
<li>passphrase 遺失造成資產永久不可恢復（passphrase 是 seed 推導的一部分，忘記它等於忘記了私鑰）</li>
<li>在聯網設備上生成助記詞（應該在離線設備上生成，然後安全轉移）</li>
<li>衍生路徑不同的錢包軟體之間無法互相恢復（雖然 BIP-44 是標準，但有些錢包使用非標準路徑）</li>
</ul>
<h3 id="613-如何存儲私鑰-p0"><a class="header" href="#613-如何存儲私鑰-p0">6.1.3 如何存儲私鑰 <code>P0</code></a></h3>
<p>推薦做法：</p>
<ul>
<li>私鑰 at-rest 加密（如 AES-GCM）</li>
<li>KDF（Argon2/scrypt）保護口令</li>
<li>記憶體中使用後清理</li>
<li>備份採多地分片或硬體介質</li>
</ul>
<p>禁止做法：</p>
<ul>
<li>私鑰明文寫 DB/日誌</li>
<li>私鑰透過 HTTP 傳輸</li>
<li>把助記詞截圖存聊天工具</li>
</ul>
<p>私鑰存儲是錢包安全的最後一道防線。Ethereum 生態廣泛使用的 Keystore 格式（Web3 Secret Storage）提供了一個成熟的參考實作：用戶的口令通過 KDF（如 scrypt 或 Argon2）轉換成加密金鑰，然後用 AES-128-CTR 或 AES-256-GCM 加密私鑰。解密時需要同樣的口令和 KDF 參數。</p>
<pre><code class="language-go">// 私鑰加密存儲的簡化實作
import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"golang.org/x/crypto/scrypt"
)

type EncryptedKey struct {
	CipherText []byte `json:"cipher_text"`
	Salt       []byte `json:"salt"`
	Nonce      []byte `json:"nonce"`
	N          int    `json:"n"`     // scrypt CPU/memory cost
	R          int    `json:"r"`     // scrypt block size
	P          int    `json:"p"`     // scrypt parallelism
}

// 加密私鑰
func EncryptPrivateKey(privKey []byte, passphrase string) (*EncryptedKey, error) {
	// 1. 生成隨機 salt
	salt := make([]byte, 32)
	if _, err := rand.Read(salt); err != nil {
		return nil, err
	}

	// 2. KDF：口令 + salt -&gt; 加密金鑰
	// N=2^18, R=8, P=1 提供足夠的安全性（解密需要約 1 秒）
	key, err := scrypt.Key([]byte(passphrase), salt, 1&lt;&lt;18, 8, 1, 32)
	if err != nil {
		return nil, err
	}

	// 3. AES-256-GCM 加密
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	nonce := make([]byte, gcm.NonceSize())
	if _, err := rand.Read(nonce); err != nil {
		return nil, err
	}

	cipherText := gcm.Seal(nil, nonce, privKey, nil)

	// 4. 清理記憶體中的明文金鑰
	for i := range key {
		key[i] = 0
	}

	return &amp;EncryptedKey{
		CipherText: cipherText,
		Salt:       salt,
		Nonce:      nonce,
		N:          1 &lt;&lt; 18,
		R:          8,
		P:          1,
	}, nil
}

// 解密私鑰
func DecryptPrivateKey(encrypted *EncryptedKey, passphrase string) ([]byte, error) {
	key, err := scrypt.Key([]byte(passphrase), encrypted.Salt, encrypted.N, encrypted.R, encrypted.P, 32)
	if err != nil {
		return nil, err
	}
	defer func() {
		for i := range key {
			key[i] = 0
		}
	}()

	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, err
	}

	return gcm.Open(nil, encrypted.Nonce, encrypted.CipherText, nil)
}
</code></pre>
<p>記憶體中的私鑰清理是容易被忽略的安全措施。Go 的 GC 不保證何時回收記憶體，未被覆蓋的私鑰可能長時間殘留在記憶體中。最佳做法是在使用完私鑰後立即用零覆蓋對應的 byte slice。雖然 Go 不像 C 那樣能完全控制記憶體，但主動清零比什麼都不做要安全得多。</p>
<pre><code class="language-text">私鑰存儲安全等級對比：

Level 1 (最差): 明文存 DB / 環境變數 / 設定檔
Level 2: 加密存儲（AES-GCM + 口令）
Level 3: HSM / KMS（AWS KMS / Azure Key Vault）
Level 4: 離線冷儲存（紙錢包 / 硬體錢包 / 鋼板備份）
Level 5 (最佳): 多簽 + 離線 + 地理分散

生產系統至少要達到 Level 3。
</code></pre>
<p>備份策略也是私鑰管理的一部分。Shamir's Secret Sharing（SSS）允許將一個秘密分成 N 份，只要收集到 M 份就能恢復原始秘密（M &lt;= N）。例如，將助記詞分成 5 份，任意 3 份即可恢復。這些分片分別存放在不同的地理位置或交給不同的信任方，確保單一分片洩漏不會導致資產被盜。</p>
<h2 id="62-區塊鏈錢包核心功能實現"><a class="header" href="#62-區塊鏈錢包核心功能實現">6.2 區塊鏈錢包核心功能實現</a></h2>
<h3 id="621-flag-使用與開發框架搭建-p1"><a class="header" href="#621-flag-使用與開發框架搭建-p1">6.2.1 flag 使用與開發框架搭建 <code>P1</code></a></h3>
<p>CLI 建議命令：</p>
<ul>
<li><code>wallet init</code></li>
<li><code>wallet addr list</code></li>
<li><code>wallet coin transfer</code></li>
<li><code>wallet token transfer</code></li>
<li><code>wallet tx query</code></li>
</ul>
<p>目錄建議：</p>
<ul>
<li><code>cmd/</code></li>
<li><code>internal/key</code></li>
<li><code>internal/tx</code></li>
<li><code>internal/rpc</code></li>
<li><code>internal/store</code></li>
</ul>
<p>一個結構良好的 CLI 錢包不僅方便用戶使用，也方便自動化腳本整合。Go 的 <code>flag</code> 包適合簡單場景，但對於子命令式的 CLI（<code>wallet init</code>、<code>wallet transfer</code> 等），推薦使用 <code>cobra</code> 或 <code>urfave/cli</code>。</p>
<pre><code class="language-text">錢包 CLI 架構：

wallet/
├── cmd/
│   ├── root.go          # cobra 根命令
│   ├── init.go          # wallet init
│   ├── address.go       # wallet addr list/new
│   ├── transfer.go      # wallet coin/token transfer
│   └── query.go         # wallet tx query
├── internal/
│   ├── key/
│   │   ├── keystore.go  # 加密存儲
│   │   ├── hd.go        # HD 衍生
│   │   └── signer.go    # 簽名接口
│   ├── tx/
│   │   ├── builder.go   # 交易組裝
│   │   ├── coin.go      # 原生幣轉帳
│   │   └── token.go     # ERC-20 轉帳
│   ├── rpc/
│   │   ├── client.go    # RPC 客戶端
│   │   └── retry.go     # 重試邏輯
│   └── store/
│       ├── db.go        # 本地資料庫
│       └── cache.go     # metadata 快取
├── go.mod
└── main.go
</code></pre>
<pre><code class="language-go">// cobra 命令註冊範例
func NewRootCmd() *cobra.Command {
	root := &amp;cobra.Command{
		Use:   "wallet",
		Short: "Blockchain wallet CLI",
	}

	root.AddCommand(
		newInitCmd(),
		newAddrCmd(),
		newTransferCmd(),
		newQueryCmd(),
	)
	return root
}

func newTransferCmd() *cobra.Command {
	cmd := &amp;cobra.Command{
		Use:   "transfer",
		Short: "Transfer coins or tokens",
	}

	cmd.AddCommand(
		&amp;cobra.Command{
			Use:   "coin",
			Short: "Transfer native coin (ETH/BTC)",
			RunE:  runCoinTransfer,
		},
		&amp;cobra.Command{
			Use:   "token",
			Short: "Transfer ERC-20 token",
			RunE:  runTokenTransfer,
		},
	)
	return cmd
}
</code></pre>
<h3 id="622-錢包如何支持-coin-轉移-p0"><a class="header" href="#622-錢包如何支持-coin-轉移-p0">6.2.2 錢包如何支持 Coin 轉移 <code>P0</code></a></h3>
<p>UTXO 鏈流程：</p>
<ol>
<li>查可用 UTXO</li>
<li>選擇輸入與找零</li>
<li>建交易</li>
<li>離線簽名</li>
<li>在線廣播</li>
</ol>
<p>Account 鏈流程：</p>
<ol>
<li>查 nonce 與 gas</li>
<li>建交易（to/value/data）</li>
<li>離線簽名</li>
<li>在線廣播</li>
</ol>
<p>理解 UTXO 鏈（如 Bitcoin）和 Account 鏈（如 Ethereum）的轉帳流程差異，是錢包開發的基礎。兩者的核心差異在於狀態模型：UTXO 鏈需要選擇具體的「鈔票」來花費，Account 鏈只需要知道帳戶當前的 nonce。</p>
<pre><code class="language-text">UTXO 鏈轉帳流程：                Account 鏈轉帳流程：

┌─────────────────┐             ┌─────────────────┐
│ 1. 查 UTXO 集   │             │ 1. 查 nonce     │
│    (在線端)      │             │    (在線端)      │
└────────┬────────┘             └────────┬────────┘
         │                               │
┌────────v────────┐             ┌────────v────────┐
│ 2. Coin Select  │             │ 2. 估算 gas     │
│    選擇輸入      │             │    (在線端)      │
│    計算找零      │             └────────┬────────┘
└────────┬────────┘                      │
         │                      ┌────────v────────┐
┌────────v────────┐             │ 3. 建交易       │
│ 3. 建未簽名交易  │             │    {to, value,  │
│    {inputs,      │             │     nonce, gas}  │
│     outputs}     │             └────────┬────────┘
└────────┬────────┘                      │
         │                               │
    ┌────v──────────────────────────v────┐
    │        4. 離線簽名                  │
    │     (Cold Wallet / HSM)             │
    └────┬──────────────────────────┬────┘
         │                               │
┌────────v────────┐             ┌────────v────────┐
│ 5. 廣播         │             │ 5. 廣播         │
│    (在線端)      │             │    (在線端)      │
└─────────────────┘             └─────────────────┘
</code></pre>
<pre><code class="language-go">// Ethereum 原生幣轉帳（離線簽名模式）
func BuildUnsignedCoinTx(ctx context.Context, client *ethclient.Client,
	from, to common.Address, amount *big.Int) (*types.Transaction, error) {

	// 在線端：查詢必要資訊
	nonce, err := client.PendingNonceAt(ctx, from)
	if err != nil {
		return nil, fmt.Errorf("get nonce: %w", err)
	}

	chainID, err := client.ChainID(ctx)
	if err != nil {
		return nil, fmt.Errorf("get chain id: %w", err)
	}

	tipCap, err := client.SuggestGasTipCap(ctx)
	if err != nil {
		return nil, fmt.Errorf("suggest tip: %w", err)
	}

	header, err := client.HeaderByNumber(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("get header: %w", err)
	}

	feeCap := new(big.Int).Add(
		tipCap,
		new(big.Int).Mul(header.BaseFee, big.NewInt(2)),
	)

	// 建立未簽名交易
	tx := types.NewTx(&amp;types.DynamicFeeTx{
		ChainID:   chainID,
		Nonce:     nonce,
		GasTipCap: tipCap,
		GasFeeCap: feeCap,
		Gas:       21000, // ETH 轉帳固定 21000 gas
		To:        &amp;to,
		Value:     amount,
	})

	return tx, nil
}

// 離線端：簽名
func SignTxOffline(tx *types.Transaction, chainID *big.Int, privateKey *ecdsa.PrivateKey) (*types.Transaction, error) {
	signer := types.LatestSignerForChainID(chainID)
	signedTx, err := types.SignTx(tx, signer, privateKey)
	if err != nil {
		return nil, fmt.Errorf("sign tx: %w", err)
	}
	return signedTx, nil
}

// 在線端：廣播
func BroadcastSignedTx(ctx context.Context, client *ethclient.Client, signedTx *types.Transaction) error {
	return client.SendTransaction(ctx, signedTx)
}
</code></pre>
<h3 id="623-錢包如何支持-coin-查詢-p0"><a class="header" href="#623-錢包如何支持-coin-查詢-p0">6.2.3 錢包如何支持 Coin 查詢 <code>P0</code></a></h3>
<p>兩種方式：</p>
<ul>
<li>直連節點 RPC</li>
<li>走索引服務 API</li>
</ul>
<p>查詢策略：</p>
<ul>
<li>即時餘額（pending + confirmed）</li>
<li>可花費餘額（按確認數門檻）</li>
</ul>
<p>餘額查詢看似簡單，但在生產環境中有很多需要考慮的細節。「即時餘額」和「可花費餘額」的區別在於確認數：一筆交易被打包到區塊中（1 confirmation）不代表它是安全的，因為該區塊可能被 reorg 回滾。對於大額交易，通常需要等待 12-64 個確認才認為資金是「安全的」。</p>
<pre><code class="language-go">// 餘額查詢（支持不同確認數）
type BalanceInfo struct {
	Pending   *big.Int // 包含 mempool 中的交易
	Latest    *big.Int // 最新區塊的餘額
	Safe      *big.Int // 安全確認數後的餘額（如 12 confirmations）
	Finalized *big.Int // 最終確認的餘額（如 64 confirmations）
}

func GetBalanceInfo(ctx context.Context, client *ethclient.Client, addr common.Address) (*BalanceInfo, error) {
	pending, err := client.PendingBalanceAt(ctx, addr)
	if err != nil {
		return nil, err
	}

	latest, err := client.BalanceAt(ctx, addr, nil) // nil = latest block
	if err != nil {
		return nil, err
	}

	// 安全餘額：最新區塊高度 - 12
	currentBlock, _ := client.BlockNumber(ctx)
	safeBlock := new(big.Int).SetUint64(currentBlock - 12)
	safe, err := client.BalanceAt(ctx, addr, safeBlock)
	if err != nil {
		return nil, err
	}

	return &amp;BalanceInfo{
		Pending: pending,
		Latest:  latest,
		Safe:    safe,
	}, nil
}
</code></pre>
<p>對於 UTXO 鏈，餘額查詢更複雜，因為不存在「帳戶餘額」的概念。需要掃描所有屬於該地址的 UTXO 並求和。Bitcoin Core 提供了 <code>getbalance</code> RPC，但如果你使用的是第三方 API（如 Blockstream、Mempool.space），需要分別查詢 confirmed 和 unconfirmed UTXO。</p>
<h3 id="624-erc-20-標準與實現-p0"><a class="header" href="#624-erc-20-標準與實現-p0">6.2.4 ERC-20 標準與實現 <code>P0</code></a></h3>
<p>必懂函數：</p>
<ul>
<li><code>balanceOf</code></li>
<li><code>transfer</code></li>
<li><code>approve</code></li>
<li><code>transferFrom</code></li>
<li><code>allowance</code></li>
</ul>
<p>必懂事件：</p>
<ul>
<li><code>Transfer</code></li>
<li><code>Approval</code></li>
</ul>
<p>ERC-20 是 Ethereum 上最重要的代幣標準，定義了同質化代幣（Fungible Token）的統一接口。幾乎所有 DeFi 協議都依賴這個標準。理解 ERC-20 的每個函數和事件，是錢包開發的必備知識。</p>
<p><code>approve</code> + <code>transferFrom</code> 的二步授權模式是 ERC-20 最核心也最容易出問題的設計。它的存在是為了讓合約能代替用戶操作代幣。例如，在 Uniswap 上交易代幣時，你需要先 <code>approve</code> Uniswap Router 合約一定額度的代幣，然後 Router 通過 <code>transferFrom</code> 把代幣從你的帳戶轉出。</p>
<pre><code class="language-text">ERC-20 approve + transferFrom 流程：

Step 1: 用戶 approve
┌──────┐   approve(spender, amount)   ┌─────────────┐
│ User │ ────────────────────────────&gt; │ Token 合約  │
└──────┘                               │ allowance   │
                                       │ [user][DEX] │
                                       │ = amount    │
                                       └─────────────┘

Step 2: DEX 合約代為轉帳
┌──────────┐  transferFrom(user, pool, amount)  ┌─────────────┐
│ DEX 合約 │ ──────────────────────────────────&gt; │ Token 合約  │
└──────────┘                                     │ balance更新  │
                                                 │ allowance減少│
                                                 └─────────────┘
</code></pre>
<pre><code class="language-go">// ERC-20 token 互動的完整範例
func GetTokenBalance(ctx context.Context, client *ethclient.Client,
	tokenAddr, userAddr common.Address) (*big.Int, error) {

	// 載入 ERC-20 ABI
	erc20ABI, _ := abi.JSON(strings.NewReader(erc20ABIJson))

	// 打包 balanceOf 呼叫
	data, _ := erc20ABI.Pack("balanceOf", userAddr)

	// eth_call（不上鏈，免費）
	result, err := client.CallContract(ctx, ethereum.CallMsg{
		To:   &amp;tokenAddr,
		Data: data,
	}, nil)
	if err != nil {
		return nil, err
	}

	// 解析結果
	outputs, err := erc20ABI.Unpack("balanceOf", result)
	if err != nil {
		return nil, err
	}

	return outputs[0].(*big.Int), nil
}

// 查詢 decimals（緩存這個值！）
func GetTokenDecimals(ctx context.Context, client *ethclient.Client,
	tokenAddr common.Address) (uint8, error) {

	erc20ABI, _ := abi.JSON(strings.NewReader(erc20ABIJson))
	data, _ := erc20ABI.Pack("decimals")

	result, err := client.CallContract(ctx, ethereum.CallMsg{
		To: &amp;tokenAddr, Data: data,
	}, nil)
	if err != nil {
		return 0, err
	}

	outputs, _ := erc20ABI.Unpack("decimals", result)
	return uint8(outputs[0].(*big.Int).Uint64()), nil
}
</code></pre>
<p>工程坑點：</p>
<ul>
<li>小數位 <code>decimals</code> 處理錯誤（USDC 是 6 位，WBTC 是 8 位，大部分 token 是 18 位）</li>
<li><code>approve</code> 競態（建議先歸零再設新值，即先 <code>approve(spender, 0)</code> 再 <code>approve(spender, newAmount)</code>）</li>
<li>有些 token 不完全符合 ERC-20 標準（如 USDT 的 <code>transfer</code> 不回傳 bool）</li>
<li>轉帳前沒有檢查合約是否存在（對不存在的地址呼叫 <code>transfer</code> 不會報錯，只是靜默失敗）</li>
</ul>
<h3 id="625-錢包如何支持-token-轉移-p0"><a class="header" href="#625-錢包如何支持-token-轉移-p0">6.2.5 錢包如何支持 token 轉移 <code>P0</code></a></h3>
<p>流程：</p>
<ol>
<li>載入 token ABI</li>
<li><code>Pack("transfer", to, amount)</code></li>
<li>建合約交易</li>
<li>簽名並送出</li>
<li>根據 receipt 與 event 確認結果</li>
</ol>
<p>token 轉帳與原生幣轉帳的關鍵差異在於：token 轉帳是對合約的函數呼叫，而不是 ETH value transfer。交易的 <code>to</code> 欄位是 token 合約地址（不是收款人地址），<code>value</code> 欄位是 0（不需要發送 ETH），收款人地址和金額被編碼在 <code>data</code> 欄位中。</p>
<pre><code class="language-go">// ERC-20 token 轉帳
func BuildTokenTransferTx(ctx context.Context, client *ethclient.Client,
	tokenAddr, from, to common.Address, amount *big.Int) (*types.Transaction, error) {

	erc20ABI, _ := abi.JSON(strings.NewReader(erc20ABIJson))

	// 打包 transfer(to, amount) 的 calldata
	data, err := erc20ABI.Pack("transfer", to, amount)
	if err != nil {
		return nil, fmt.Errorf("pack transfer: %w", err)
	}

	nonce, _ := client.PendingNonceAt(ctx, from)
	chainID, _ := client.ChainID(ctx)
	tipCap, _ := client.SuggestGasTipCap(ctx)
	header, _ := client.HeaderByNumber(ctx, nil)
	feeCap := new(big.Int).Add(tipCap, new(big.Int).Mul(header.BaseFee, big.NewInt(2)))

	// 估算 gas（token transfer 通常約 50,000-65,000 gas）
	gasLimit, err := client.EstimateGas(ctx, ethereum.CallMsg{
		From: from,
		To:   &amp;tokenAddr,
		Data: data,
	})
	if err != nil {
		return nil, fmt.Errorf("estimate gas: %w", err)
	}
	gasLimit = gasLimit * 12 / 10 // 加 20% 安全邊際

	tx := types.NewTx(&amp;types.DynamicFeeTx{
		ChainID:   chainID,
		Nonce:     nonce,
		GasTipCap: tipCap,
		GasFeeCap: feeCap,
		Gas:       gasLimit,
		To:        &amp;tokenAddr, // 注意：to 是合約地址，不是收款人
		Value:     big.NewInt(0), // 不發送 ETH
		Data:      data,
	})

	return tx, nil
}

// 確認 token 轉帳結果
func ConfirmTokenTransfer(ctx context.Context, client *ethclient.Client,
	receipt *types.Receipt, erc20ABI abi.ABI, expectedTo common.Address, expectedAmount *big.Int) error {

	if receipt.Status != types.ReceiptStatusSuccessful {
		return fmt.Errorf("transaction reverted")
	}

	// 解析 Transfer event
	for _, vLog := range receipt.Logs {
		event, err := erc20ABI.EventByID(vLog.Topics[0])
		if err != nil || event.Name != "Transfer" {
			continue
		}
		// Topics[1] = from, Topics[2] = to
		to := common.BytesToAddress(vLog.Topics[2].Bytes())
		// Data = amount
		outputs, _ := event.Inputs.NonIndexed().Unpack(vLog.Data)
		amount := outputs[0].(*big.Int)

		if to == expectedTo &amp;&amp; amount.Cmp(expectedAmount) == 0 {
			return nil // 確認成功
		}
	}
	return fmt.Errorf("expected Transfer event not found")
}
</code></pre>
<h3 id="626-錢包如何支持-token-查詢-p0"><a class="header" href="#626-錢包如何支持-token-查詢-p0">6.2.6 錢包如何支持 token 查詢 <code>P0</code></a></h3>
<p>查詢項目：</p>
<ul>
<li>token 餘額</li>
<li>allowance</li>
<li>持倉清單</li>
</ul>
<p>工程建議：</p>
<ul>
<li>緩存 metadata（symbol/decimals）</li>
<li>多鏈資產用 <code>chainId + contract + address</code> 當主鍵</li>
</ul>
<p>token 查詢在使用者體驗上需要做到「開啟錢包即看到所有資產」。這意味著錢包需要維護一個 token 列表，並批量查詢餘額。對於支持多條鏈的錢包，資產索引的主鍵必須包含 chain id，否則不同鏈上同地址的 token 合約會衝突。</p>
<pre><code class="language-go">// Token metadata 緩存
type TokenMeta struct {
	ChainID  int64
	Address  common.Address
	Symbol   string
	Decimals uint8
	Name     string
}

type TokenCache struct {
	mu    sync.RWMutex
	cache map[string]*TokenMeta // key: "chainId:contractAddr"
}

func (c *TokenCache) GetOrFetch(ctx context.Context, client *ethclient.Client,
	chainID int64, tokenAddr common.Address) (*TokenMeta, error) {

	key := fmt.Sprintf("%d:%s", chainID, tokenAddr.Hex())

	c.mu.RLock()
	if meta, ok := c.cache[key]; ok {
		c.mu.RUnlock()
		return meta, nil
	}
	c.mu.RUnlock()

	// Cache miss: 從鏈上查詢
	symbol, _ := queryTokenSymbol(ctx, client, tokenAddr)
	decimals, _ := GetTokenDecimals(ctx, client, tokenAddr)
	name, _ := queryTokenName(ctx, client, tokenAddr)

	meta := &amp;TokenMeta{
		ChainID:  chainID,
		Address:  tokenAddr,
		Symbol:   symbol,
		Decimals: decimals,
		Name:     name,
	}

	c.mu.Lock()
	c.cache[key] = meta
	c.mu.Unlock()

	return meta, nil
}

// 批量查詢 token 餘額（使用 multicall 減少 RPC 次數）
func GetMultiTokenBalances(ctx context.Context, client *ethclient.Client,
	userAddr common.Address, tokens []common.Address) (map[common.Address]*big.Int, error) {

	balances := make(map[common.Address]*big.Int)

	// 簡化版：逐一查詢（生產環境用 multicall 合約批量查詢）
	for _, token := range tokens {
		bal, err := GetTokenBalance(ctx, client, token, userAddr)
		if err != nil {
			balances[token] = big.NewInt(0) // 查詢失敗不中斷
			continue
		}
		balances[token] = bal
	}
	return balances, nil
}
</code></pre>
<p>最佳實踐：</p>
<ul>
<li>token metadata（symbol, decimals, name）幾乎不會變，查一次就緩存</li>
<li>使用 multicall 合約在一個 RPC 呼叫中查詢多個 token 餘額，減少延遲</li>
<li>維護一個「已知 token 列表」（如 CoinGecko token list），自動偵測用戶持有的 token</li>
</ul>
<h3 id="627-交易明細查詢-p0"><a class="header" href="#627-交易明細查詢-p0">6.2.7 交易明細查詢 <code>P0</code></a></h3>
<p>最小交易明細模型：</p>
<ul>
<li><code>txHash</code></li>
<li><code>from</code>, <code>to</code></li>
<li><code>value</code> / <code>tokenAmount</code></li>
<li><code>status</code></li>
<li><code>blockNumber</code></li>
<li><code>timestamp</code></li>
<li><code>fee</code></li>
</ul>
<p>狀態機：</p>
<pre><code class="language-text">created -&gt; signed -&gt; pending -&gt; confirmed -&gt; finalized
                              -&gt; failed/dropped
</code></pre>
<p>交易狀態追蹤是錢包 UX 的關鍵。用戶需要知道他的交易在哪個階段：是還在等待簽名、已經廣播但還沒被打包、已經被打包但還沒有足夠確認數、還是已經完全確認？每個狀態轉換都應該有對應的通知機制。</p>
<pre><code class="language-go">// 交易明細模型
type TxDetail struct {
	TxHash      string    `json:"tx_hash"`
	From        string    `json:"from"`
	To          string    `json:"to"`
	Value       string    `json:"value"`        // 原生幣金額（wei）
	TokenAmount string    `json:"token_amount"` // token 金額（最小單位）
	TokenAddr   string    `json:"token_addr"`   // token 合約地址（如果是 token 交易）
	Status      TxStatus  `json:"status"`
	BlockNumber uint64    `json:"block_number"`
	Timestamp   time.Time `json:"timestamp"`
	GasUsed     uint64    `json:"gas_used"`
	GasPrice    string    `json:"gas_price"`
	Fee         string    `json:"fee"` // gasUsed * effectiveGasPrice
}

type TxStatus int

const (
	TxStatusCreated   TxStatus = iota // 交易已建立
	TxStatusSigned                    // 已簽名
	TxStatusPending                   // 已廣播，等待打包
	TxStatusConfirmed                 // 已打包，等待足夠確認
	TxStatusFinalized                 // 完全確認
	TxStatusFailed                    // 執行失敗（revert）
	TxStatusDropped                   // 被替換或逾時丟棄
)

// 追蹤交易狀態
func TrackTransaction(ctx context.Context, client *ethclient.Client,
	txHash common.Hash, confirmations uint64) (&lt;-chan TxStatus, error) {

	statusCh := make(chan TxStatus, 10)

	go func() {
		defer close(statusCh)
		statusCh &lt;- TxStatusPending

		// 等待被打包
		receipt, err := bind.WaitMined(ctx, client, &amp;types.Transaction{})
		if err != nil {
			statusCh &lt;- TxStatusDropped
			return
		}

		if receipt.Status == 0 {
			statusCh &lt;- TxStatusFailed
			return
		}

		statusCh &lt;- TxStatusConfirmed

		// 等待足夠確認數
		for {
			currentBlock, _ := client.BlockNumber(ctx)
			if currentBlock-receipt.BlockNumber.Uint64() &gt;= confirmations {
				statusCh &lt;- TxStatusFinalized
				return
			}
			time.Sleep(12 * time.Second) // 大約一個區塊的時間
		}
	}()

	return statusCh, nil
}
</code></pre>
<p>常見坑：</p>
<ul>
<li>只看 tx 成功，不看 event 是否符合預期（tx status = 1 只代表沒有 revert，不代表業務邏輯正確——例如 token transfer 的 amount 可能因為精度問題與預期不同）</li>
<li>發生重組時沒有回滾本地狀態（如果一個已確認的交易被 reorg 移除，本地資料庫必須同步回滾）</li>
<li>pending 狀態的交易長時間不被打包（可能因為 gas 價格太低），需要提供「加速」（用更高 gas 重發同 nonce 交易）和「取消」（用同 nonce 發送 0 value 給自己）功能</li>
<li>沒有處理 nonce gap——如果 nonce 5 的交易被取消了，nonce 6 和 7 的交易也會一直卡住</li>
</ul>
<h2 id="章節回顧與工程要點-3"><a class="header" href="#章節回顧與工程要點-3">章節回顧與工程要點</a></h2>
<p>離線錢包是區塊鏈工程中安全要求最高的模組。本章涵蓋了從金鑰管理到交易追蹤的完整鏈路，以下是每個環節的核心工程原則：</p>
<p><strong>私鑰隔離</strong>：私鑰永遠不出簽名邊界。離線端和在線端之間通過未簽名/已簽名交易進行資料交換。私鑰存儲必須加密（至少 AES-256-GCM + scrypt KDF），記憶體中使用後立即清零。助記詞是私鑰的最終備份，其安全等級不應低於私鑰本身。</p>
<p><strong>交易可驗證</strong>：每筆交易在簽名前必須在離線端展示完整內容（to、amount、gas、data）供用戶確認。簽名後的交易可以被任何人獨立驗證，不依賴簽名端的在線狀態。對於 token 交易，不僅要檢查 tx receipt 的 status，還要解析 Transfer event 確認收款人和金額正確。</p>
<p><strong>狀態可追蹤</strong>：交易從建立到最終確認經歷多個狀態轉換，每個狀態都應該被持久化並可查詢。重組（reorg）是真實存在的威脅，本地狀態必須有回滾能力。對於大額交易，確認數門檻應該更高。</p>
<p><strong>錯誤可恢復</strong>：網路故障、節點故障、交易被卡住都是正常情況。錢包必須支持交易加速（replace-by-fee）和取消功能。RPC 呼叫需要重試機制和超時控制。本地資料庫需要備份策略。</p>
<p>做到這四點，才算可上線的錢包系統。</p>
<h2 id="白話總結-25"><a class="header" href="#白話總結-25">白話總結</a></h2>
<p>離線錢包的核心概念其實很簡單：私鑰放在一台完全不連網的機器上，需要簽名的時候把未簽名的交易透過 USB 或 QR code 傳過去，簽好名再傳回來廣播。這樣即使在線端被駭了，攻擊者也拿不到私鑰。助記詞就是私鑰的「人話版本」——12 或 24 個英文單詞，記住它們就能恢復所有帳戶。私鑰存儲一定要加密，密碼要用 scrypt 這類 KDF 處理，讓暴力破解變得極其昂貴。做 token 轉帳的時候要注意，你實際上是在呼叫合約函數，收款人地址藏在 calldata 裡面，不是交易的 to 欄位。最後一點經常被忽略但非常重要：交易確認不是看 receipt status 就夠了，你還得去解析 event log，確認收款人和金額跟你預期的一樣。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
