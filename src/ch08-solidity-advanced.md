# 第8章 Solidity智能合約開發進階

本章目標是把合約能力提升到可上線等級：標準、升級、架構模式、安全最佳實踐與 Python 調用。

## 8.1 Solidity經典案例

### 8.1.1 智能合約開發的一般步驟 `P1`
通用流程：
1. 寫規格與狀態機
2. 先寫測試（unit/fuzz/invariant）
3. 實作合約
4. 審計與修補
5. 部署與監控

### 8.1.2 土豪發紅包 `P2`
練習重點：
- 批量分發
- 名單驗證
- 防重複領取

### 8.1.3 我要開銀行 `P1`
練習重點：
- 存取款模型
- 權限與限額
- 事件記錄與對帳

### 8.1.4 智能拍賣 `P1`
練習重點：
- 出價排序
- 截止時間
- 未中標退款安全性

## 8.2 ERC標準 `P0`

### 8.2.1 ERC概述 `P0`
ERC 是互操作標準，讓錢包、交易所、DApp 可以一致整合。

### 8.2.2 ERC-20標準 `P0`
核心函數：
- `transfer`
- `approve`
- `transferFrom`
- `balanceOf`

常見坑：
- allowance 覆蓋競態
- decimals 顯示錯誤

### 8.2.3 ERC-165標準 `P0`
用途：合約能力探測（`supportsInterface`）。

### 8.2.4 ERC-721（NFT標準） `P1`
重點：
- 單 token 唯一性
- metadata 管理
- 批量 mint 與授權策略

## 8.3 可升級合約 `P0`

### 8.3.1 不可篡改與可升級之間的矛盾 `P0`
矛盾點：
- 不可變保安全與可預期
- 可升級保可維護與修復

平衡做法：
- Proxy + Timelock + 多簽治理

### 8.3.2 跨合約調用 `P0`
跨合約是組合能力來源，也是攻擊面來源。

要點：
- 外部調用前先更新內部狀態
- 外部合約回傳值必檢查

### 8.3.3 透過底層函數呼叫合約 `P0`
`call/delegatecall/staticcall` 使用要點：
- 僅在必要時用底層調用
- 必須檢查 success 與返回資料

### 8.3.4 主—從式可升級合約 `P1`
主從模式可隔離邏輯與配置，但需清楚權限邊界。

### 8.3.5 代理程式—儲存式可升級合約 `P0`
Proxy 模式關鍵：
- storage layout 不可破壞
- initializer 只能執行一次
- 升級權限需多簽與延遲

## 8.4 合約開發最佳實踐 `P0`

### 8.4.1 最佳實務概述 `P0`
- 權限最小化
- 事件完整記錄
- 失敗可回滾
- 測試先行

### 8.4.2 工廠模式 `P1`
用工廠合約批量部署同類合約，提高一致性。

### 8.4.3 儲存註冊表模式 `P1`
中心註冊表管理版本、地址與參數，利於治理。

### 8.4.4 遍歷表疊代器 `P1`
避免鏈上大迴圈，採分批與游標式遍歷。

### 8.4.5 避免重入攻擊 `P0`
防禦組合：
- CEI
- reentrancy guard
- pull payment

### 8.4.6 警惕外部合約調用 `P0`
外部調用要當成不可信：
- 可能回滾
- 可能耗盡 gas
- 可能惡意 callback

## 8.5 Python與智能合約調用 `P0`

### 8.5.1 RPC原理分析 `P0`
RPC 是節點對外接口，典型方法：
- `eth_call`
- `eth_estimateGas`
- `eth_sendRawTransaction`

### 8.5.2 Python-SDK簡介 `P1`
常用 `web3.py`：
- 連節點
- 載 ABI
- 發交易
- 查回執

### 8.5.3 Python呼叫智能合約步驟 `P0`
1. 建立 provider
2. 載入 ABI + address
3. 建 call/tx
4. 簽名與發送

### 8.5.4 節點連接 `P0`
建議：
- 主備 RPC
- 請求重試與超時
- 連線健康檢查

### 8.5.5 ABI分析與編譯 `P0`
ABI 是調用契約，版本漂移會導致調用錯誤。

### 8.5.6 透過Python調用智能合約 `P0`
工程要點：
- nonce 競態控制
- gas 估算與上限保護
- 交易狀態追蹤（pending -> confirmed）

## 本章總結
- 能寫合約不等於能上線，升級治理與安全流程才是核心。
- SDK 調用端同樣是風險面，必須納入測試與監控。
