# 第4章 初識區塊鏈

本章聚焦於區塊鏈最底層共識與資料結構，目標是建立可實作的工程理解。

## 4.1 區塊鏈的誕生與發展 `P1`

### 4.1.1 區塊鏈的誕生 `P1`
區塊鏈誕生的核心背景是：
- 中心化系統容易形成單點故障與信任成本
- 網路原生資產需要「不靠中心機構」的記帳方式
- 雙花問題需要在開放網路中可被驗證地解決

在區塊鏈出現之前，所有的數位交易都需要一個可信的中間人。銀行、支付平台、清算所——這些機構扮演著「記帳員」的角色，負責確保 Alice 轉給 Bob 的那筆錢不會同時轉給 Charlie。這套模式在實體世界運作得不錯，但它有一個根本性的代價：你必須信任這個中間人不會倒閉、不會被攻破、不會審查你的交易。2008 年金融危機讓這個代價變得格外刺眼——全球最「可信」的金融機構幾乎同時失信。

Satoshi Nakamoto 在 2008 年 10 月發表的白皮書《Bitcoin: A Peer-to-Peer Electronic Cash System》提出了一個關鍵洞見：如果我們能讓網路中所有參與者共同維護一本帳本，並且用密碼學和經濟激勵來取代對單一機構的信任，那麼我們就能實現「trustless」的數位價值轉移。這裡的 trustless 不是「不信任」，而是「不需要預先信任特定對象」。

雙花問題（double spending）是數位貨幣的核心難題。實體鈔票轉手後就不在原持有者手上了，但數位資料可以被無限複製。過去解決這個問題的唯一方式是中心化帳本。比特幣的突破在於：透過 PoW 共識機制，讓全網節點就交易順序達成一致，從而在去中心化環境中解決了雙花問題。任何人想要「撤回」已確認的交易，都必須重做大量計算工作，使得攻擊在經濟上不可行。

工程結論：區塊鏈不是單一技術，而是密碼學、分散式網路、經濟激勵三者結合。這三根支柱缺一不可——沒有密碼學，資料無法被驗證；沒有分散式網路，系統會退化為中心化架構；沒有經濟激勵，節點沒有動力誠實運作。理解這一點對工程設計至關重要，因為它意味著區塊鏈工程師需要同時具備這三個領域的知識。

### 4.1.2 認識密碼龐克組織 `P1`
密碼龐克（Cypherpunk）核心理念：
- 以密碼學工具保護個體自由
- 系統要「最小信任」而非「善意假設」
- 協議透明、程式可驗證

密碼龐克運動可以追溯到 1990 年代初期。Eric Hughes 在 1993 年發表的《A Cypherpunk's Manifesto》中寫道：「隱私不是秘密。隱私是選擇性地向世界展示自己的權力。」這個運動匯聚了一群密碼學家、程式設計師和社會活動家，他們相信強密碼學是對抗監控和保護個人自由的最後防線。

這個群體中產生了許多區塊鏈的前身技術：Adam Back 的 Hashcash（PoW 的原型）、Wei Dai 的 b-money（去中心化電子現金提案）、Hal Finney 的 Reusable Proof of Work、Nick Szabo 的 Bit Gold。這些方案各自解決了部分問題，但都未能完整地解決拜占庭容錯環境下的共識問題。比特幣可以被理解為站在這些巨人肩膀上的集大成者。

對工程的直接影響：
- 預設 hostile environment
- 重要規則寫進協議而非寫在文件
- 採用可公開審計的安全模型

密碼龐克的思維方式對現代區塊鏈工程有深遠影響。「Don't trust, verify」不只是口號，它是一種設計哲學。在傳統軟體工程中，我們經常假設輸入是善意的、伺服器是可信的、網路是可靠的。但在區塊鏈工程中，每一個假設都可能被利用。例如，Smart Contract 開發中的 reentrancy attack 就是因為開發者「假設」外部合約不會在回調中做壞事。密碼龐克教會我們：安全模型必須基於對手可以做什麼，而不是期望對手會做什麼。

### 4.1.3 區塊鏈技術的高速發展 `P1`
發展主軸：
- Bitcoin：價值轉移與 PoW 安全
- Ethereum：可程式化狀態與合約平台
- L2：擴容與低成本
- ZK/模組化：可驗證計算與分層架構

區塊鏈的發展可以用「四個時代」來理解。第一個時代（2009-2014）是比特幣時代，核心創新是去中心化的價值轉移。這個階段的工程挑戰集中在 P2P 網路穩定性、UTXO 模型設計、PoW 難度調整演算法。比特幣證明了一件事：不需要銀行也能轉帳，而且這個系統在真實的對抗環境中是安全的。

第二個時代（2015-2019）由以太坊開啟，引入了圖靈完備的智能合約平台。Vitalik Buterin 的洞見是：如果區塊鏈能執行任意程式碼，那它就不只是一個帳本，而是一台「世界電腦」。EVM（Ethereum Virtual Machine）讓開發者可以在鏈上部署任意邏輯，催生了 ICO、DeFi、NFT 等應用。但這也帶來了新的工程挑戰：Gas 計費、狀態膨脹、合約安全。

第三個時代（2020-2023）是 DeFi 爆發與 L2 擴容。DeFi Summer（2020 年夏天）讓以太坊主網擁堵到 Gas 費高達數十美元，直接推動了 L2 方案的發展。Optimistic Rollup（如 Arbitrum、Optimism）和 ZK Rollup（如 zkSync、StarkNet）提供了在繼承 L1 安全性的前提下擴容的路徑。

```text
時代演進：

2009         2015         2020         2024+
  |            |            |            |
  v            v            v            v
Bitcoin    Ethereum    DeFi/L2      Modular/ZK
(帳本)     (程式化)    (擴容)       (可驗證)
  |            |            |            |
  v            v            v            v
UTXO       EVM/Gas     Rollup      DA+Exec分離
PoW        PoW->PoS    Bridge      ZK Proof
```

第四個時代（2024 至今）是模組化與可驗證計算。Celestia 提出的「模組化區塊鏈」概念將傳統單體鏈拆分為 Data Availability、Execution、Settlement、Consensus 四層，每層可以獨立優化。ZK 技術從 L2 擴展到更廣泛的應用場景——ZK 身份驗證、ZK 機器學習推論驗證、ZK coprocessor 等。工程師的思維方式也從「寫一條鏈」轉變為「組合模組」。

## 4.2 P2P網絡 `P0`

### 4.2.1 P2P網絡概述 `P0`
P2P 網路特徵：
- 無中心主機，節點對等交換資料
- 新交易/新區塊透過 gossip 擴散
- 每節點只需連少量鄰居即可參與全網同步

P2P（Peer-to-Peer）網路是區塊鏈去中心化的基礎設施層。與傳統的 Client-Server 架構不同，P2P 網路中每個節點既是客戶端也是伺服器。這意味著沒有單一的故障點——即使部分節點離線，其餘節點仍能正常運作。比特幣網路自 2009 年上線以來，除了早期的一些軟體 bug 導致的短暫異常，從未「宕機」過。這種韌性正是 P2P 架構的核心優勢。

Gossip 協議是區塊鏈 P2P 網路中最常見的訊息傳播機制。它的運作方式類似謠言傳播：當一個節點收到新交易或新區塊時，會隨機選擇幾個鄰居轉發。這些鄰居再轉發給它們的鄰居，如此遞迴，直到整個網路都收到消息。在數學上，gossip 協議可以在 O(log N) 輪中將消息傳播到 N 個節點，效率極高。比特幣網路的實測顯示，一筆新交易通常在 2-5 秒內就能傳播到全網大多數節點。

```text
Gossip 傳播示意圖：

時間 T0:        時間 T1:           時間 T2:

   [A]             [A]                [A]
    |              / \               / | \
   新TX          [B] [C]          [B] [C] [D]
                  |                |   |   |
                 [D]             [E] [F] [G]

   A 收到交易     A 傳給 B,C       繼續擴散到全網
```

在工程實務上，P2P 網路的設計需要考慮 NAT 穿越問題。大多數家用網路環境下，節點位於 NAT 後方，無法被外部直接連接。解決方案包括 UPnP、STUN/TURN 協議、以及像 libp2p 這種框架提供的 relay 機制。以太坊使用的 devp2p 協議棧和 libp2p（被 Polkadot、Filecoin 等採用）是目前最主流的兩個區塊鏈 P2P 網路框架。

### 4.2.2 P2P網絡的搭建重點 `P0`
搭建重點：
- 節點發現：seed/bootnode/mDNS
- 連線治理：限速、黑名單、重試退避
- 訊息設計：消息類型、版本協商、校驗碼
- 韌性策略：避免 eclipse attack、避免單點 seed

**節點發現**是 P2P 網路的第一個工程挑戰。新加入網路的節點需要找到至少一個已有節點才能開始同步。常見策略包括：硬編碼的 bootnode 清單（比特幣的 DNS seed）、DHT（Distributed Hash Table）自動發現、以及區域網路的 mDNS 廣播。以太坊使用 Kademlia DHT 的變體作為節點發現層，每個節點維護一張路由表，按照 XOR 距離將其他節點分組存儲。

```text
Kademlia DHT 節點發現：

Node ID: 0x1A3F (本節點)

路由表 (k-bucket):
┌──────────────────────────────────────────┐
│ 距離範圍    │ 儲存的鄰居節點              │
├──────────────────────────────────────────┤
│ 2^0 - 2^1  │ 0x1A3E                      │
│ 2^1 - 2^2  │ 0x1A3D, 0x1A3C              │
│ 2^2 - 2^4  │ 0x1A3B, 0x1A38              │
│ ...        │ ...                          │
│ 2^15-2^16  │ 0x8F21, 0xC4A2, 0xE103      │
└──────────────────────────────────────────┘

越遠的距離範圍，儲存的節點數量上限一樣（k 個），
但覆蓋的 ID 空間更大 → 保證 O(log N) 查找效率
```

**連線治理**是防止資源耗盡的關鍵。一個節點不可能連接全網所有節點，因此需要設定最大連接數（通常 25-50 個）、入站/出站比例、連線品質評分。如果某個 peer 頻繁傳送無效資料或響應過慢，應降低其評分並最終斷開連線。指數退避（exponential backoff）是處理連線失敗的標準做法——第一次失敗等 1 秒重試，第二次等 2 秒，第三次等 4 秒，以此類推，避免在網路異常時產生重試風暴。

**Eclipse Attack** 是 P2P 網路中最嚴重的威脅之一。攻擊者控制受害節點的所有入站和出站連接，使其與真實網路隔離。防禦措施包括：限制同一 IP 段的連接數量、保持一定比例的出站連接（出站連接由本節點主動發起，較難被攻擊者控制）、以及定期隨機替換 peer。比特幣在 2015 年的論文《Eclipse Attacks on Bitcoin's Peer-to-Peer Network》之後強化了相關防禦。

### 4.2.3 區塊鏈網絡的資料同步機制 `P0`
資料同步常見流程：
1. 節點互報高度與 tip hash
2. 缺塊節點請求區塊清單
3. 逐塊拉取並驗證
4. 更新本地鏈狀態與交易池

區塊同步是新節點加入網路後最耗時的過程。以比特幣為例，從創世塊同步到最新狀態需要下載超過 500 GB 的區塊資料。以太坊的全節點同步則可能需要數天甚至數週。因此，同步效率直接影響了網路的可及性。

```text
區塊同步流程：

新節點 N                    已同步節點 P
   |                            |
   |--- Handshake (版本/鏈 ID) -->|
   |                            |
   |<-- Status (高度/tip hash) --|
   |                            |
   |--- GetHeaders (起點 hash)->|
   |                            |
   |<-- Headers[] --------------|
   |                            |
   |--- GetBodies (hash[]) ---->|
   |                            |
   |<-- Bodies[] ---------------|
   |                            |
   |   [本地驗證每個區塊]         |
   |   [更新狀態]                |
   |                            |
```

主要有三種同步策略：**Full Sync** 從創世塊開始逐塊執行所有交易，安全性最高但耗時最長。**Fast Sync**（以太坊的術語）先下載所有區塊頭，驗證 PoW/PoS，然後只下載最近狀態的快照（state trie），再從快照點開始全量執行。**Snap Sync** 是 Fast Sync 的改進，透過 range proof 分批下載狀態樹，大幅減少同步時間。**Light Client** 只下載區塊頭，需要查詢交易時向全節點請求 Merkle proof。

工程要點：
- 交易池去重
- 區塊驗證先於入庫
- fork 時保留分叉資料以便重組

交易池（mempool）的管理是另一個重要的工程問題。每個全節點維護一個未確認交易的記憶體池。當新交易進入時，需要檢查：(1) 格式是否正確；(2) 簽名是否有效；(3) 是否與池中已有交易衝突（雙花檢測）；(4) 手續費是否高於最低門檻。交易池通常有容量限制（比特幣預設 300 MB），當池滿時會驅逐低費率交易。

Fork 處理是區塊同步中最複雜的部分。當網路中同時出現兩個有效但互斥的區塊時，節點需要保留兩個分支，直到其中一個分支變得更長（在 PoW 中是更多累積工作量）。此時節點執行 **reorg**（鏈重組）：回滾較短分支的交易，應用較長分支的交易。工程實作上，這要求資料庫支持高效的回滾操作，通常使用 journal/undo log 機制。

## 4.3 區塊鏈的資料結構 `P0`

### 4.3.1 哈希函數 `P0`
hash 函數在鏈中用途：
- 交易 ID
- 區塊 ID
- Merkle 根
- 狀態承諾

哈希函數是區塊鏈最基礎的密碼學工具。它將任意長度的輸入映射為固定長度的輸出（稱為摘要或 hash），並具有三個關鍵特性：(1) **抗碰撞性**（collision resistance）——找不到兩個不同的輸入產生相同的輸出；(2) **抗原像性**（preimage resistance）——無法從 hash 反推原始輸入；(3) **雪崩效應**（avalanche effect）——輸入的微小改動導致輸出完全不同。

比特幣使用 SHA-256（雙重 SHA-256 用於區塊頭），以太坊使用 Keccak-256（注意：這與 NIST 標準化的 SHA-3 略有不同）。選擇哪種 hash 函數對系統設計有深遠影響——它決定了地址長度、proof 大小、以及未來的量子安全性。

```text
Hash 函數示意：

輸入: "Hello, Blockchain!"
           |
      ┌────v────┐
      │ SHA-256  │
      └────┬────┘
           |
輸出: 0x7f83b1657ff1fc53b92dc18148a1d65d
      fc2d4b1fa3d677284addd200126d9069

改一個字元:
輸入: "Hello, Blockchain?"  (! -> ?)
           |
      ┌────v────┐
      │ SHA-256  │
      └────┬────┘
           |
輸出: 0x3e23e8160039594a33894f6564e1b134  <-- 完全不同
      8bbd7a0088d42c4acb73eeaed59c009d
```

工程原則：
- 序列化必須穩定
- hash 算法版本變更要有兼容策略

**序列化穩定性**是容易被忽視但極其關鍵的工程問題。Hash 函數的輸入是位元組串，因此在計算 hash 之前，必須將結構化資料（如交易、區塊頭）序列化為位元組。如果不同實作使用不同的序列化順序或格式，即使資料相同也會產生不同的 hash。比特幣使用嚴格定義的 little-endian 二進位格式；以太坊使用 RLP（Recursive Length Prefix）編碼。常見的坑包括：整數的大小端問題、字串的編碼方式、空值的處理方式。在跨語言實作時，這些問題尤其容易出錯。

### 4.3.2 時序的鏈塊式結構 `P0`
區塊透過 `prev_block_hash` 串連，形成時間順序。
任一歷史區塊被改動，都會破壞後續鏈接校驗。

鏈塊式結構是區塊鏈最具標誌性的設計。每個區塊包含前一個區塊的 hash，形成一條不可篡改的鏈條。如果攻擊者試圖修改歷史區塊中的任何一筆交易，這個區塊的 hash 會改變，導致下一個區塊中記錄的 `prev_block_hash` 不再匹配，進而使整條後續鏈條失效。攻擊者必須從被修改的區塊開始，重新計算所有後續區塊的 hash——在 PoW 系統中，這意味著重做大量計算工作。

```text
區塊結構與鏈接：

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│    Block 0       │    │    Block 1       │    │    Block 2       │
│  (Genesis)       │    │                  │    │                  │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ prev_hash: 0x00 │    │ prev_hash: 0xA1 │◄───│ prev_hash: 0xB2 │
│ timestamp       │    │ timestamp        │    │ timestamp        │
│ nonce           │    │ nonce            │    │ nonce            │
│ merkle_root     │    │ merkle_root      │    │ merkle_root      │
│ tx_list         │    │ tx_list          │    │ tx_list          │
├─────────────────┤    ├─────────────────┤    ├─────────────────┤
│ hash: 0xA1...   │───►│ hash: 0xB2...   │───►│ hash: 0xC3...    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

一個區塊頭通常包含以下欄位：前區塊 hash、時間戳記、難度目標（PoW 專用）、nonce（PoW 專用）、Merkle root、以及可能的額外資料欄位。區塊體則包含該區塊中打包的所有交易。以比特幣為例，區塊頭固定 80 bytes，而區塊體的大小取決於包含的交易數量，上限約 1 MB（SegWit 後有效容量約 4 MB weight）。

工程上需要注意的一個細節是「孤塊」（orphan block）的處理。由於網路延遲，節點可能先收到子區塊後收到父區塊。此時需要暫存這些找不到父區塊的孤塊，待父區塊到達後再連接。同時要防止攻擊者發送大量無效孤塊來耗盡記憶體，因此孤塊快取通常有大小限制。

### 4.3.3 梅克爾樹 `P0`
Merkle Tree 解決兩件事：
- 大量交易的摘要承諾
- 只用路徑證明即可驗證交易包含性

Merkle Tree（梅克爾樹）是由 Ralph Merkle 在 1979 年提出的資料結構。它的核心思想是：將所有交易兩兩配對做 hash，再將結果兩兩配對做 hash，層層往上，最終得到一個根 hash（Merkle Root）。這個根 hash 是所有交易的「指紋」——只要任何一筆交易被修改，根 hash 就會完全不同。

```text
Merkle Tree 結構：

              Root Hash
             (= H(H01 + H23))
            /                \
         H01                  H23
     (= H(H0+H1))        (= H(H2+H3))
       /      \             /      \
     H0        H1         H2        H3
     |         |          |         |
   Tx 0      Tx 1       Tx 2      Tx 3


Merkle Proof 示例（證明 Tx2 存在於此區塊）：
驗證者只需要：Tx2, H3, H01, Root

驗證步驟：
1. 計算 H2 = hash(Tx2)
2. 計算 H23 = hash(H2 + H3)      ← 需要 H3
3. 計算 Root' = hash(H01 + H23)   ← 需要 H01
4. 比對 Root' == Root              ← 驗證通過
```

Merkle Proof 的效率非常驚人。假設一個區塊包含 4096 筆交易，要驗證某筆交易是否存在，只需要提供 12 個 hash（log2(4096) = 12），而不是所有 4096 筆交易。這使得輕節點（light client）成為可能——手機錢包不需要下載整條鏈，只需要區塊頭和 Merkle Proof 就能驗證交易。

常見坑：
- 奇數葉節點複製規則未統一
- 葉節點 hash 前處理不一致

**奇數葉節點問題**值得詳細說明。當交易數量是奇數時，最後一個交易沒有配對對象。比特幣的做法是複製最後一個 hash 與自己配對。但這引入了一個已知的攻擊向量：攻擊者可以構造一個包含重複交易的區塊，使其 Merkle Root 與正常區塊相同（CVE-2012-2459）。修復方法是在驗證時檢查是否存在重複的交易 hash。以太坊使用的 Modified Merkle Patricia Trie 結構不同，不存在這個問題，但引入了其他複雜性（如 trie 路徑編碼）。

**葉節點前處理**也是常見的坑。為了防止第二原像攻擊（second preimage attack），葉節點和內部節點的 hash 計算應使用不同的前綴。例如，葉節點 hash = H(0x00 + data)，內部節點 hash = H(0x01 + left + right)。如果不區分，攻擊者可能將某個內部節點偽裝成葉節點。

## 4.4 PoW機制 `P0`

### 4.4.1 分佈式網絡中共識的意義 `P0`
共識要回答：
- 哪筆交易先發生
- 哪個區塊是有效延伸
- 網路分割後如何收斂到單一歷史

在分散式系統中，「共識」是一個經典的難題。FLP 不可能定理告訴我們：在異步網路中，即使只有一個節點可能故障，也無法保證所有正確節點在有限時間內達成共識。區塊鏈的突破在於：它不追求確定性共識，而是接受機率性共識——交易被確認的機率隨時間遞增，但永遠不會達到 100%。

為什麼交易排序如此重要？考慮這個場景：Alice 的帳戶有 10 ETH，她同時發送兩筆交易——一筆轉 10 ETH 給 Bob，另一筆轉 10 ETH 給 Charlie。兩筆交易都是「合法」的（簽名正確、餘額充足），但它們不能同時有效。網路必須對它們的順序達成一致，且這個順序一旦確定就不能被更改。這就是共識要解決的核心問題。

```text
共識的必要性（雙花場景）：

Alice 餘額: 10 ETH

     Tx1: Alice -> Bob (10 ETH)
    /
Alice
    \
     Tx2: Alice -> Charlie (10 ETH)

如果沒有共識：
  節點 A 看到 Tx1 先到 → Bob 得到 10 ETH
  節點 B 看到 Tx2 先到 → Charlie 得到 10 ETH
  → 系統狀態不一致！

有共識（PoW）：
  礦工打包 Tx1 進區塊 → 全網同意 Bob 得到 10 ETH
  Tx2 變成無效交易 → 被丟棄
```

### 4.4.2 什麼是PoW `P0`
PoW：透過計算成本取得出塊權。
有效區塊條件：`hash(header) < target`。

Proof of Work 的核心機制極其簡單：礦工不斷改變區塊頭中的 nonce 值，重新計算 hash，直到 hash 值小於一個目標值。這個過程本質上是暴力搜索——沒有捷徑，唯一的加速方式是增加計算能力。找到符合條件的 nonce 被稱為「挖到區塊」，礦工獲得區塊獎勵和交易手續費。

```
PoW 挖礦過程（偽代碼）：

function mine(block_header, target):
    nonce = 0
    while true:
        block_header.nonce = nonce
        hash = SHA256(SHA256(block_header))
        if hash < target:
            return nonce    // 找到了！
        nonce += 1

// 例如 target 前面需要 20 個零位元：
// target:  0x00000FFFFFFFFFFFFFFFFFFFFFFFFFFF...
// hash1:   0x7A3B1...  ← 不符合，繼續
// hash2:   0x2F8C4...  ← 不符合，繼續
// ...
// hash N:  0x00000123... ← 符合！出塊成功
```

難度調整是 PoW 系統的精妙設計。比特幣每 2016 個區塊（約兩週）調整一次難度，確保平均出塊時間維持在 10 分鐘。如果這 2016 個區塊的實際耗時少於兩週，說明算力增加了，就提高難度；反之則降低。這個負回饋機制使比特幣的出塊速率在算力劇烈變化的十多年間保持了驚人的穩定。

### 4.4.3 PoW的本質原理 `P0`
本質是「用客觀成本限制作惡」：
- 想改歷史要重做工作量
- 攻擊成本與鏈安全預算相關

PoW 的安全性來自一個經濟學論證：攻擊區塊鏈需要付出的電力和硬體成本必須超過攻擊的預期收益。以比特幣為例，2024 年全網算力超過 500 EH/s，要發動 51% 攻擊需要控制超過 250 EH/s 的算力。按當時的 ASIC 礦機價格和電費計算，這需要數十億美元的投資。而攻擊成功後能獲得的收益（主要是雙花攻擊）遠小於這個成本。

工程觀點：
- PoW 提供機率最終性
- 大額交易要提高確認數

**機率最終性**是一個重要的工程概念。一筆交易被包含在區塊中後，並不是立即「最終確認」的。攻擊者有一定機率能夠建立更長的替代鏈來替換包含這筆交易的區塊。但隨著後續區塊的累積，攻擊成功的機率呈指數下降。比特幣社群的慣例是等待 6 個確認（約 1 小時）才認為交易是「安全」的。Satoshi 在白皮書中計算過：假設攻擊者擁有 10% 的算力，6 個確認後攻擊成功的機率不到 0.02%。

```text
確認數與安全性：

確認數    攻擊成功機率（攻擊者 10% 算力）
  1          ~20%
  2          ~4%
  3          ~1%
  6          ~0.02%
  12         ~0.000004%

實務建議：
┌─────────────────┬───────────┐
│ 交易金額         │ 建議確認數 │
├─────────────────┼───────────┤
│ < $1,000        │ 1-2       │
│ $1,000-$10,000  │ 3-4       │
│ $10,000-$100k   │ 6         │
│ > $100k         │ 12+       │
└─────────────────┴───────────┘
```

PoW 的一個常見批評是能源消耗。比特幣網路的年耗電量已經超過許多中小型國家。這推動了業界對替代共識機制（尤其是 PoS）的探索。但支持者認為，PoW 的能源消耗正是其安全性的來源——正是因為攻擊需要消耗大量能源，攻擊才不可行。這個辯論涉及「安全性每單位成本」的經濟學分析，超出了純技術範疇。

## 4.5 UTXO與交易 `P0`

### 4.5.1 什麼是UTXO `P0`
UTXO 是尚未花費輸出。
交易透過消耗舊輸出、創建新輸出完成轉移。

UTXO（Unspent Transaction Output，未花費交易輸出）是比特幣的帳本模型。與我們直覺中的「帳戶餘額」不同，UTXO 模型不存在「帳戶」的概念。你的「餘額」實際上是分散在區塊鏈上所有屬於你的 UTXO 的總和。這就像你的錢包裡有好幾張不同面額的鈔票——你不能撕碎一張 100 元鈔票來付 50 元，你必須把整張 100 元交出去，然後收到 50 元的找零。

```text
UTXO 模型示意：

Alice 的 "餘額" = 3 BTC，實際上是：
┌──────────────────┐
│ UTXO-1: 1.5 BTC  │ (來自交易 TX-A，輸出 #0)
│ UTXO-2: 0.8 BTC  │ (來自交易 TX-B，輸出 #1)
│ UTXO-3: 0.7 BTC  │ (來自交易 TX-C，輸出 #0)
└──────────────────┘

Alice 要轉 2 BTC 給 Bob：
  消耗: UTXO-1 (1.5) + UTXO-2 (0.8) = 2.3 BTC
  產生: Output-0: Bob 2.0 BTC  (新 UTXO)
        Output-1: Alice 0.29 BTC (找零 UTXO)
        Fee: 0.01 BTC (隱含手續費)
```

UTXO 模型有幾個工程上的重要優勢：(1) **天然支援並行驗證**——不同交易如果消耗不同的 UTXO，它們之間沒有依賴關係，可以並行驗證。(2) **隱私性較好**——每次交易可以使用新地址接收找零，增加交易圖分析的難度。(3) **確定性驗證**——交易的有效性只取決於它引用的 UTXO 是否存在且未被花費，不受其他交易影響。

UTXO 的劣勢在於狀態查詢和複雜邏輯的實作難度較高。要查詢某個地址的「餘額」，需要掃描整個 UTXO 集合找出屬於該地址的所有 UTXO。實作智能合約式的複雜邏輯也比帳戶模型困難得多，因為每個 UTXO 都是獨立的，沒有共享狀態。

### 4.5.2 比特幣交易模型 `P0`
基本結構：
- Inputs：引用前序輸出
- Outputs：新輸出（收款 + 找零）
- Fee：輸入總額減輸出總額

一筆比特幣交易的完整結構如下：

```text
交易結構：

┌─────────────────────────────────────────┐
│ Transaction                              │
├─────────────────────────────────────────┤
│ version: 2                               │
│                                          │
│ inputs: [                                │
│   {                                      │
│     prev_tx_hash: 0xABC...,              │
│     prev_output_index: 0,                │
│     script_sig: <signature> <pubkey>,    │
│     sequence: 0xFFFFFFFF                 │
│   }                                      │
│ ]                                        │
│                                          │
│ outputs: [                               │
│   {                                      │
│     value: 200000000,   // 2 BTC (satoshi)│
│     script_pubkey: OP_DUP OP_HASH160     │
│                    <pubkey_hash>          │
│                    OP_EQUALVERIFY         │
│                    OP_CHECKSIG            │
│   },                                     │
│   {                                      │
│     value: 29000000,    // 0.29 BTC (找零)│
│     script_pubkey: ...                   │
│   }                                      │
│ ]                                        │
│                                          │
│ locktime: 0                              │
└─────────────────────────────────────────┘
```

```text
old outputs -> tx inputs -> validation -> tx outputs
```

手續費的計算方式是隱含的：輸入總額減去輸出總額就是手續費。如果 Alice 消耗了 2.3 BTC 的輸入，產生了 2.0 BTC 給 Bob 和 0.29 BTC 給自己，那麼 0.01 BTC 就是手續費。一個常見的新手錯誤是忘記加找零輸出，導致全部差額變成手續費。曾經有人因此在一筆交易中付了超過 80 BTC 的手續費。

比特幣手續費以「每 vByte 的 satoshi」（sat/vB）為單位。交易的虛擬大小取決於它包含的輸入和輸出數量。更多的輸入意味著更多的簽名資料，交易更大，手續費更高。因此，管理 UTXO 的「碎片化」是錢包工程中的重要課題——太多小額 UTXO 會導致未來交易的手續費比 UTXO 本身的價值還高。

### 4.5.3 交易腳本 `P0`
腳本負責定義「誰能花這筆錢」：
- locking script（鎖定條件）
- unlocking witness/script（解鎖證明）

比特幣的腳本系統是一個基於堆疊的、非圖靈完備的腳本語言（稱為 Bitcoin Script）。它故意限制了功能——沒有迴圈、沒有遞迴——以避免程式執行時間不可預測的問題。每個 UTXO 被一個 locking script（也稱 scriptPubKey）鎖定；要花費這個 UTXO，花費者必須提供一個滿足條件的 unlocking script（也稱 scriptSig 或 witness）。

```text
P2PKH (Pay-to-Public-Key-Hash) 腳本執行：

Locking Script (存在 UTXO 中):
  OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG

Unlocking Script (花費時提供):
  <signature> <publicKey>

堆疊執行過程：
Stack: []
  → push <signature>         Stack: [sig]
  → push <publicKey>         Stack: [sig, pubKey]
  → OP_DUP                   Stack: [sig, pubKey, pubKey]
  → OP_HASH160                Stack: [sig, pubKey, hash(pubKey)]
  → push <pubKeyHash>        Stack: [sig, pubKey, hash(pubKey), pubKeyHash]
  → OP_EQUALVERIFY           Stack: [sig, pubKey]  (hash 相等，繼續)
  → OP_CHECKSIG              Stack: [true]  (簽名驗證通過)
```

工程重點：
- 支援常見模板（P2PKH/P2WPKH/P2TR）
- 驗證失敗要可追蹤錯誤原因

隨著比特幣的演進，腳本類型也在進化。P2PKH 是最早的標準類型。P2SH（Pay-to-Script-Hash）允許將複雜的鎖定條件壓縮成一個 hash，讓付款者不需要了解解鎖條件的細節。P2WPKH（SegWit）將見證資料移出交易主體，降低了交易大小和手續費。P2TR（Taproot，2021 年啟用）引入了 Schnorr 簽名和 MAST（Merkelized Alternative Script Trees），同時提升了隱私性和多簽場景的效率。

工程實作中，驗證失敗的錯誤追蹤非常重要。腳本驗證失敗可能有多種原因——簽名無效、hash 不匹配、時間鎖未到期等。一個好的實作應該在驗證過程中記錄堆疊狀態和失敗的操作碼，以便於除錯。在開發期間，使用 Bitcoin Core 的 `signrawtransactionwithwallet` 或類似的 debug 工具可以幫助定位腳本問題。

## 4.6 區塊鏈帳本的安全與挑戰 `P0`

### 4.6.1 雙花攻擊 `P0`
同一資產被提交兩筆互斥交易。
防護：
- UTXO/nonce 檢查
- 足夠確認數
- 高風險交易延遲出貨

雙花攻擊（Double Spending Attack）是區塊鏈系統最基本的威脅模型。攻擊者試圖將同一筆資產花費兩次——例如，用同一個 UTXO 同時支付給兩個不同的收款人。在 UTXO 模型中，每個 UTXO 只能被花費一次；在帳戶模型中，每筆交易的 nonce 必須嚴格遞增。這是第一道防線。

常見的雙花攻擊變體包括：

```text
1. Race Attack（競速攻擊）:
   攻擊者同時向網路廣播兩筆衝突交易
   → 防護：等待至少 1 個確認

2. Finney Attack:
   攻擊者預先挖好包含 Tx1 的區塊，
   然後廣播 Tx2 到商家，再公佈區塊
   → 防護：等待多個確認

3. 51% Attack（多數算力攻擊）:
   攻擊者秘密挖一條更長的鏈
   → 防護：增加確認數、監控異常
```

**案例研究：2018 年 Bitcoin Gold 雙花事件。** Bitcoin Gold（BTG）是比特幣的一個分叉幣，使用 Equihash 演算法。2018 年 5 月，攻擊者控制了 BTG 網路超過 51% 的算力，成功執行了雙花攻擊，從交易所竊取了約 1800 萬美元。攻擊者的手法是：先在交易所存入大量 BTG 並兌換成其他幣種提走，然後用秘密挖的更長鏈重組帳本，使存入交易消失。這個事件說明了兩個工程教訓：(1) 小算力幣種的安全性本質上較弱；(2) 交易所的確認數設定需要根據幣種的安全預算來調整。

### 4.6.2 51%攻擊 `P0`
若攻擊者控制多數算力/權益，可提高重組與審查能力。
防護：
- 提升經濟安全（算力/質押分散）
- 增加確認數策略
- 監控異常重組

51% 攻擊是區塊鏈安全模型中最被廣泛討論的威脅。控制多數共識資源（PoW 中的算力、PoS 中的質押）的攻擊者可以：(1) 雙花已確認的交易（透過鏈重組）；(2) 審查特定交易（拒絕將其打包進區塊）；(3) 阻止其他礦工/驗證者出塊。但攻擊者「不能」做的事也很重要：不能偽造簽名、不能花費不屬於自己的資產、不能修改共識規則。

```text
51% 攻擊原理：

正常鏈:     A - B - C - D - E  (公開)
                    \
攻擊者秘密鏈:         C'- D'- E'- F' (秘密挖礦)

當攻擊者的秘密鏈更長時：
公佈秘密鏈 → 全網重組到 C'- D'- E'- F'
→ 區塊 C, D, E 中的交易被撤銷
→ 攻擊者在 C' 中放入不同的交易（雙花）
```

在 PoS 系統中，51% 攻擊的動態有所不同。攻擊者需要控制超過 1/3 的質押量才能阻止共識達成（BFT 系統），或超過 2/3 的質押量才能單方面確認區塊。但 PoS 系統有一個獨特的防禦手段：**slashing**（罰沒）。如果驗證者被發現簽署了兩個衝突的區塊，其質押會被沒收。這意味著攻擊者即使成功，也會損失大量資本。以太坊的 Casper FFG 設計中，成功的 51% 攻擊需要至少 1/3 的質押被罰沒，按當前質押量計算約 100 億美元。

監控異常重組是工程防禦的重要手段。正常運作下，1-2 個區塊深度的重組偶爾會發生。但 3 個區塊以上的重組就值得警惕，6 個以上幾乎肯定是攻擊。工程上可以部署監控系統，偵測重組深度，一旦超過閾值就觸發警報，暫停高價值操作（如交易所提款）。

### 4.6.3 激勵相容 `P0`
協議應讓誠實行為獲得最大期望收益。

激勵相容（Incentive Compatibility）是機制設計理論中的核心概念，意思是：協議的設計應該使得理性參與者的最優策略就是誠實行為。換句話說，不需要假設參與者是「好人」——即使每個人都只追求自利，系統仍能正常運作。

比特幣的激勵設計是一個經典案例。礦工有兩個選擇：(1) 誠實挖礦，獲得區塊獎勵和手續費；(2) 嘗試攻擊（如雙花），可能獲得更大收益但也可能失敗。中本聰在白皮書中論證了：只要誠實礦工控制多數算力，攻擊的期望收益就是負的。因此，理性的礦工會選擇誠實挖礦。

```text
激勵相容分析：

礦工策略選擇：

策略 A（誠實挖礦）：
  收入 = 區塊獎勵 + 手續費
  成本 = 電費 + 硬體折舊
  期望利潤 = 穩定正數

策略 B（51% 攻擊）：
  收入 = 雙花金額（如果成功）
  成本 = 電費 + 硬體 + 被攻擊幣種價格崩跌的損失
  成功率 = 取決於算力佔比
  期望利潤 = 通常為負數（因為攻擊成功後幣價崩跌）

結論：理性礦工選擇策略 A
```

工程檢核：
- 出塊獎勵與費率模型是否合理
- 作惡成本是否高於收益
- 懲罰機制是否可執行

工程上需要特別關注激勵失衡的邊緣情況。例如，比特幣的區塊獎勵每四年減半，最終將完全依賴手續費。如果手續費不足以覆蓋挖礦成本，礦工可能會退出，導致安全性下降。另一個例子是 MEV（Maximal Extractable Value）——在以太坊上，礦工/驗證者可以透過重新排序交易來獲取額外收益（如三明治攻擊、清算搶跑）。MEV 的存在改變了激勵結構，可能導致共識不穩定（如 time-bandit attack）。PBS（Proposer-Builder Separation）等設計試圖在協議層面解決 MEV 帶來的激勵問題。

## 工程核心回顧

本章最重要的是三條線：
- 結構線：hash + 鏈塊 + Merkle
- 網路線：P2P 傳播與同步
- 共識線：PoW + 激勵 + 安全邊界

這三條線構成了區塊鏈系統的骨架。**結構線**確保資料不可篡改——hash 函數提供資料指紋，鏈塊結構確保時序不可逆，Merkle Tree 使輕量驗證成為可能。**網路線**確保資料可傳播——P2P 網路讓系統沒有單點故障，gossip 協議讓訊息在秒級傳遍全網，同步機制讓新節點能加入網路。**共識線**確保系統收斂——PoW 讓出塊有成本，激勵相容讓理性行為等於誠實行為，安全邊界讓攻擊在經濟上不可行。

對工程師而言，理解這三條線的相互作用至關重要。例如，P2P 網路的延遲會影響 PoW 的有效性（高延遲導致更多孤塊，降低有效安全性）；Merkle Tree 的設計影響輕客戶端的可行性（進而影響網路的去中心化程度）；激勵設計影響節點運營者的行為（進而影響網路的健康度）。一個好的區塊鏈工程師需要能夠在這三個維度之間做出合理的取捨。

## 白話總結

簡單講，區塊鏈就是一群互不認識的電腦，在沒有「老大」的情況下，共同維護一本大家都認可的帳本。為了防止有人動手腳改帳，每一頁帳本都蓋了一個跟前一頁相關的「章」（hash），你改了任何一頁，後面所有頁的章就對不上了。消息在電腦之間像八卦一樣傳開（gossip），幾秒鐘全網都知道了。而 PoW 挖礦本質上就是「用電費來保證你不敢亂來」——你要作弊得花的電費比你能賺到的還多。UTXO 模型有點反直覺，你的比特幣不是存在「帳戶」裡的，而是像散落在區塊鏈各處的「零錢」，花的時候拼起來用，多的再找零回來。Merkle Tree 讓你的手機錢包不用下載幾百 GB 的資料就能驗證交易是否存在。整個系統最精妙的地方在於「激勵相容」——不需要假設大家是好人，只要大家是理性的，系統就能正常運作。
